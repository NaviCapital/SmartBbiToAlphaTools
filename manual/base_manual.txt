AlphaTools API documentation
Module instruments (Instrumentos)
add_instruments(instruments)
    Inserts new instruments.

    instruments: [instrument]
        instrument: {'symbol': str, 'market_id': int}

    returns: default success dictionary
round_quantity_to_round_lot(instrument_id, quantity, round_to_floor=None, round_lot=None)
    Returns a new quantity rounded to a multiple of the instrument round_lot.

    If round_to_floor is False, nearest-integer rounding is used.
    If round_to_floor is True, floor-rounding is used.
    If round_to_floor is None (the default), nearest-integer is used if round_lot is 1, otherwise floor is used.

    returns: decimal
get_issuer_group_names(ids=None, use_for_portfolio_grouping=None, get_issuers=None, names=None)
    Retrieves the names of matching issuer groups. Optional filters are available.

    ids: [int] or None
    use_for_portfolio_grouping: bool or None
    get_issuers: bool or None  # default: False
    names: [str] or None

    returns: {issuer_group_id (int): issuer_group}
        issuer: {'id': int, 'name': string, 'use_for_portfolio_grouping': bool, 'issuer_ids': [int] or missing}
get_corporate_actions_factors(instrument_ids, start_date=None, end_date=None)
    Returns corporate_actions_factor by instrument and by date

    instrument_ids: [int]

    returns: {'instrument_id' (int): ca_by_date}
        ca_by_date: {date (date): corporate_action_factor (Decimal)}
get_instruments_administrator_symbols(admin_template)
    Retrieves the names of the instruments in the given administrator.

    returns: { symbol (string): instrument_id (int) }
get_price_divisor(instrument_id)
    Retrieves the price divisor of provided instrument id.

    instrument_id: int

    returns: decimal or None
get_instrument_prices_by_date(instrument_id, administrator_id=None, start_date=None, end_date=None)
    Get all prices for a single instrument, indexed by date
    returns: {date: price}
get_instrument_default_strategy(instrument_ids=None, strategy_ids=None, is_active=None, only_explicit=False)
    Retrieves the default strategies for instruments. Accepts optional filters.
    If only_explicit is True, only instruments which have explicitly assigned default strategies are returned.
    Otherwise, all matching instruments are returned, and those without an explicit strategy are assigned
    either the default strategy or the cash strategy (if enabled), depending on the instrument type.

    instrument_ids: [int] or None
    strategy_ids: [int] or None
    is_active: bool or None
    only_explicit: bool  # default: False

    returns: {instrument_id (int): strategy_id (int)}
send_instrument_groups_email()
    Sends an email about all instrument groups associated with a block operation compliance rule
compare_prices(file_prices, date)
    Compares imported prices against local pricing information.

    file_prices: {instrument_id (int): [price]}
        price: { 'imported_price': decimal }

    returns: {instrument_id (int): [compared_price]}
        compared_price: price + {'nav_unit_value': decimal}
get_instrument_symbols(ids=None, symbols=None, isin_codes=None, cusip_codes=None, sedol_codes=None, tickers=None, instrument_type_identifiers=None, is_active=None)
    Retrieves the symbols of all instruments in the database (or in the id list, if provided).
    Returns only active instruments, except if ids are provided.
    Symbols list may be provided to retrive respectives ids.

    ids: [int] or None
    symbols: [str] or None
    isin_codes: [str] or None
    cusip_codes: [str] or None
    sedol_codes: [str] or None
    tickers: [str] or None
    instrument_type_identifiers: [string] or None
    is_active: boolean or None

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, 'symbol': str, 'isin_code': str, 'currency_id': int}
save_imported_prices(prices, date, price_source)
    Saves prices imported from file after user confirmation.

    'prices': {instrument_id (int): price}
        price: {'delta': decimal, 'price': decimal}  # TODO: Include extra values.
    'date': date
    'price_source': PRICE_SOURCES (int)

    returns: {'success': bool}
get_instrument_auto_accept_settings(ids)
    Retrieves auto-accept settings for the given instruments.

    ids: [int]

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, 'type': AUTO_ACCEPT_TYPES (int), 'price_variation_percent': Decimal or None}
get_types(type_ids=None)
    Retrieves information on instrument types.

    type_ids: [int] or None

    returns: {type_id (int): type}
        type: {'id': int, 'identifier': string, 'display_name': string, 'module_name': string, 'class_name': string}
update_issuer(issuer)
    Updates existing instruments analysis.

    'issuer': {'listing_segment': int }

    returns: default success dictionary
import_prices(filename, contents=None, date=None, use_dummy_with=True)
    Imports a XLS file containing prices by symbol.
    Optionaly, the file may contain a third collumn containing price date. In this case the date from file overrides
    the date provided as input (if any).

    Multi-date files will be imported directly to database, while single date files will only be parsed and results
    will be presented to user in a confirmation screen.

    filename: string
    contents: string
    date: date or None  # required if the file does not contain the Date column

    returns: default success dictionary + {'file_id': int, }
get_extended_prices(instrument_ids, date=None, administrator_id=None, apply_price_divisor=None, is_exact_date=False, excluded_price_sources=None, price_sources=None)
    Retrieves the given instruments' price at the given date, with detailed information.
    If 'date' is None, the instruments' most recent prices are used.

    If 'apply_price_divisor' is True, instruments' price divisors will be applied, so returned values will be per unit.
    To obtain values as-is, suitable for display, pass False.

    instrument_ids: [instrument_id (int)]
    date: date or None
    administrator_id: int or None
    apply_price_divisor: boolean or None  # default: True
    price_sources: [int] or None

    returns: {instrument_id (int): extended_prices or None}
    extended_prices: {'instrument_id': int, 'nav_unit_value': Decimal, 'exposure_unit_value': Decimal,
                      'average_value': Decimal, 'price_divisor': Decimal, 'price_source': int, 'actual_date': date,
                      'extra_values': JSON, 'generated_on': datetime, 'modified_on': datetime,
                      'corporate_actions_factor': float, 'price_id': int, 'administrator_id': int or None}
get_vol(instrument_ids, start_date, end_date, conversion_rates=[])
    Calculates instrument prices volatility as the standard deviation
    of daily returns multiplied by the square root of 252.

    instrument_ids: [int]
    start_date: date
    end_date: date
    conversion_rates: [rate]

    returns {instrument_id (int): vol (decimal)}
update_prices_historical_series(date, historical_factors)
    Updates the corporate actions factor for prices from the date specified onwards. If no price is registered by this date,
    a new Price will be registered.

    date: date
    historical_factors: {'instrument_id': int, 'today_price': decimal, # the price registered if no price is found
                         'corporate_actions_factor': decimal}
get_prices_multiple_dates(instrument_ids, dates, administrator_id=None, apply_price_divisor=None, apply_adjustment_factor=False, use_settlement_price_for_futures=False, use_first_newest_price=False, get_extra_values=False, return_exposure_unit_value_for_options=False)
    Gets the prices for the given instruments, on the given dates (or the closest price for the date)

    If use_first_newest_price is True, when there is no price for a given date, use the first newest price
    in relation to the date being requested.

    instrument_ids: [int]
    dates: [date]
    administrator_id: int
    apply_price_divisor: bool or None
    apply_price_divisor: bool
    use_settlement_price_for_futures: bool # default: False
    get_extra_values: bool


    returns {instrument_id (int): {date: price (decimal)}} if get_extra_values is False
     else {instrument_id (int): {date: extra_values}}
         extra_values: dict
         obs: nav_unit_value will be available on 'price' key
get_instruments_to_skip_in_ideal_portfolio(ids=None)
    Returns the instruments which are set to never participate in ideal portfolio calculation.
    An ID list can be passed for filtering.

    ids: [int] or None

    returns: {'instrument_ids': [int]}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_prices_for_display(instrument_ids=None, market_id=None, instrument_type=None, start_date=None, end_date=None, price_source=None, show_month_last_price=False)
    Get prices data.

    instrument_ids: [int] or None
    market_id: int or None
    instrument_type: int or None
    start_date: date or None
    end_date: date or None
    price_source: int or None
    show_month_last_price: bool  # default: False

    returns: {'prices': [price]}
        price: {'id': int, 'instrument_id': int, 'nav_unit_value': decimal, 'date': date, 'modified_on': datetime,
                'instrument__currency_id': int, 'is_latest_entry': bool, 'settlement_price': decimal or None,
                'delta': decimal or None, 'vol': decimal or None, 'variation_percent': decimal or None,
                'price_source': PRICE_SOURCES (int), 'price_source_display': string,
                'administrator_id': int, 'administrator_name': string, 'trade_volume': decimal or None,
                'is_preview': bool}
add_issuers(issuers)
    Inserts new issuers.

    'issuers': [issuer]
        issuer: {'name': str, 'symbol': str, 'sector_id': int, 'legal_id': str or None, 'country_id': int}
    returns: default success dictionary
get_instruments_by_alternative_symbols(symbols, types=None, instrument_active=None)
    Retrieves the instruments associated with the given alternative symbols, optionally filtered by symbol type.
    If multiple instruments have the same symbol, the one with the lowest ID is returned.

    symbols: [string]
    types: [INSTRUMENT_SYMBOL_TYPES (int)] or None

    returns: {symbol (string): entry}  # only matches are returned
        entry: {'symbol_id': int, 'symbol': string, 'symbol_type': INSTRUMENT_SYMBOL_TYPES (int),
                'symbol_description': string, 'instrument_id': int, 'main_symbol': string, 'name': string,
                'instrument_type_id': int}
get_new_quantity_and_exposure(fund_nav, fund_currency_id, date, preferred_source_ids=None, new_quantity=None, new_exposure=None, round_quantity=True, price=None, default_price=None, instrument_id=None, ignore_round_lot=False, fund_id=None, convert_price_to_instrument_currency=True)
    Returns the simulated new quantity and exposure of an instrument inside a generic fund_nav.
    Must pass either new_quantity OR new_exposure. The 'not passed' value will be calculated in this method.
    Must pass either price OR instrument_id to get the price of the instrument. Prefere price prior to instrument_id for
    optimizations purposes. If the instrument currency is different from fund currency this method applies the conversion.
    In case fund_nav is equal 0, returns 0 for quantity and exposure.
    If round_quantity is True, the quantity will be rounded.
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    fund_nav: Decimal
    fund_currency_i: int
    date: date
    preferred_source_ids: [int] or None
    new_quantity: Decimal or None
    new_exposure: Decimal or None
    round_quantity: bool
    price: Decimal or None  # if supplied, it is used forcefully
    default_price: Decimal or None  # if supplied, it is used only when there is no price in the database
    instrument_id: int
    ignore_round_lot: boolean

    returns: {'quantity': Decimal, 'exposure': Decimal}
check_if_price_should_be_calculated(instruments)
    Check if a list of instruments should have their prices recalculated.

    instruments: [instrument]
        instrument: {'instrument_info': {...}, 'instrument_extended_price': {...}, 'detailed_prices': {...}} # TODO

    returns: {'instrument_ids': [int]}
get_instruments_analysis(ids=None, instrument_ids=None, instrument_id_is_null=False, date=None, contents=None)
    Retrieves instruments analysis information. Accepts optional filters.
    'ids': [id]
            id: int
    'instrument_ids': [int] or None
    'date': date or None
    'contents': str or None

    returns: {'instruments_analysis': [instrument_analysis]}
         instrument_analysis: {'instrument_analysis_id': int, 'instrument_id': int, 'date': date  # use always the first day of the month
                              'contents' = str}.
get_issuer_sector_names(ids=None, name=None)
    Retrieves the names of matching issuer sector. Optional filters are available.

    ids: [int] or None
    name: str or None

    returns: {issuer_sector_id (int): issuer_sector}
        issuer: {'id': int, 'name': string, 'parent_id': int or None, 'name_en': string}
get_instruments_for_bloomberg_price_monitoring(instrument_ids=None)
    Gets a list of instruments that should have their prices monitored by Bloomberg, along
    with all data required to subscribe to their market data via the Bloomberg API.
    Also returns a list of price sources that have equal or lower priority than the Bloomberg prices,
    so they can be safely overwritten.

    returns: {'instruments': [instrument], 'overridable_sources': [PRICE_SOURCE (int)]}
        instrument: {'id': int, 'type_identifier': INSTRUMENT_TYPE_IDENTIFIERS (string), 'pricing_source': string,
                     'isin': string or None, 'ticker': string or None, 'market_sector': string or None,
                     'market_id': int, 'time_zone': TIME_ZONE (string)}
add_instruments_analysis(instruments_analysis)
    Inserts new instruments analysis.

    'instruments_analysis': [instrument_analysis]
        instrument_analysis: {'instrument_id': int, 'date': date  # use always the first day of the month
                              'contents' = str}

    returns: default success dictionary
update_instruments_group_composition(group_id, instrument_ids)
    Overrides instruments group's composition.
    group_id: int
    instrument_ids: [int]

    returns: {'success': bool}
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
get_instruments_by_any_symbol(symbols, instrument_type_ids=None, only_symbol=None)
    Retrieves a dict with the Instrument's symbol and id.
    Filter by any type of symbol (symbol, isin, sedol, cusip, bbg ticker, alternative symbols and alternative admin symbols)

    symbols: [str]
    instrument_type_ids: [int] or None

    returns: { any_symbol: id (int) }
get_instrument_types(ids=None, instrument_type_ids=None, instrument_type_identifiers=None, symbols=None, is_active=None)
    Retrieves the instrument types of matching instruments. Optional filters are available.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    instrument_type_ids: [int] or None
    instrument_type_identifiers: [string] or None
    symbols: [string] or None

    returns: {instrument_id (int): instrument}
        instrument: {'instrument_id': int, 'name': string, 'type_id': int, 'type_name': string,
                     'type_identifier': string}
get_issuers_by_group(issuer_group_ids)
    Retrieves all issuers from the given issuer groups.

    issuer_group_ids: [int]

    returns: {issuer_id (int): issuer}
        instrument: {'id': int, 'name': string}
get_listing_segment_names(ids=None, name=None)
    Retrieves the names of matching issuer listing segments. Optional filters are available.

    ids: [int] or None
    name: str or None

    returns: {listing_segment_id (int): listing_segment}
        listing_segment: {'id': int, 'name': string}
import_instruments_from_xls(filename, contents)
    Imports a XLS file containing instruments.

    filename: string
    contents: string

    returns: default success dictionary + {file_id: int}
set_instrument_isin(instruments)
    Sets the ISIN code of an array of instruments.

    'instruments': {instrument_id (int): ISIN (string)}

    returns: {'success': boolean, 'error_message': string or None}
get_instruments(ids=None, is_active=None, type_ids=None, group_ids=None)
    Retrieves basic information for instruments. Optional filters are available.

    ids: [int] or None
    is_active: bool or None
    type_ids: [int] or None
    group_ids: [int] or None

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, , 'symbol': string or None, 'isin_code': string or None, 'name': string or None,
                     'display_name': string, 'currency_id': int, 'type_id': int, 'issuer_id': int}

    Differently from get_instrument_names(), 'symbol' and 'name' are the actual stored values,
    which means one of them may be None. The field 'display_name' is guaranteed to be filled with a display-ready name.
get_price_yield_from_future_bond(yield_by_inst_id, log=None)
    parameters:
        rate_by_inst_id: {
            instrument_id: {
                date: Date or None, if None date will be today,
                price: Decimal or None,
                yield_value = Decimal or None
            }
        }

    return:
        success : bool,
        errors: [ error]
        values :
            price: Decimal,
            yield_value: Decimal
add_issuer_sector(name, parent_id=None)
get_instruments_price_evolution(instrument_ids, start_date, end_date)
    Returns the price evolution of the given instruments in a period.

    instrument_ids: [int]
    start_date: date
    end_date: date

    returns: {'instrument_id' (int): instrument_price}
        instrument_price: {'instrument_id': int, 'instrument_name': string, 'prices': [price]}
            price: {'date': date, 'value': Decimal}
get_group_by_instrument(date, instruments_ids, show_instruments_as_group=None, use_together_for_allocation=None)
    Returns an existing group for each instrument.

    date: date
    instruments_ids: [int]

    returns {instrument_id (int): group}
        group: {'id': int, 'name': string, 'show_instruments_as_group': boolean, 'instrument_ids': [int]}
del_prices(price_ids)
    Delete prices by ID.

    price_ids: [int]

    returns: default success dictionary
update_next_prices_vol(prices, date, price_sources)
    Copies vol and delta of each price to the price of the next day

    prices: {instrument_id (int): price}
        price: {'price': decimal, 'delta': decimal or None, 'vol': decimal or None}
    'date': date

    returns: {'success': bool}
get_num_prices_inside_period(instrument_id, start_date, end_date, administrator_id=None)
add_instruments_groups(instruments_groups)
    If the instrument_groups has a id key, should update it, otherwise insert a new Intrument Group.
    'instruments_groups': [instrument_group]
        'instrument_group': {
            'name': string
            'instruments': [int]
            'differentiate_in_email': bool or None # default False
            'date': date or None
            'show_instruments_as_group : Bool or None # default False
            'use_together_for_allocation: Bool or None # default False
            }
        }
    returns: default success dictionary + {'instruments_groups_ids: [int]}
get_prices(instrument_ids, date=None, administrator_id=None, apply_price_divisor=None, is_exact_date=False)
    Retrieves the given instruments' price at the given date.
    If 'date' is None, the instruments' most recent prices are used.

    If 'apply_price_divisor' is True, instruments' price divisors will be applied, so returned values will be per unit.
    To obtain values as-is, suitable for display, pass False.

    If 'is_exact_date' is True, then only prices at the provided date are returned (instead of the most recent one)

    instrument_ids: [int]
    date: date or None
    administrator_id: int or None
    apply_price_divisor: boolean or None  # default: True
    is_exact_date: boolean or None

    returns: {instrument_id (int): nav_unit_value (Decimal) or None}
add_listing_segments(listing_segments)
    Insert a new Listing Segment.
    listing_segments: [listing_segment]
        listing_segment:{
            'id': int or None,
            'name': str
        }

    return: default success dictionary
get_issuer_names(ids=None, symbols=None, names=None, sector_ids=None, listing_segment_ids=None, issuer_partial_search=None, country_ids=None, issuer_types=None)
    Retrieves the names of matching issuers. Optional filters are available.

    ids: [int] or None
    symbols: [srt] or None
    names: [srt] or None
    listing_segment_ids: [int] or None
    issuer_partial_search: string or None
    country_ids: [int] or None
    issuer_types: [int] or None

    returns: {issuer_id (int): issuer}
        issuer: {'id': int, 'name': string, 'sector_id': int}
get_instrument_names(ids=None, instrument_type_ids=None, instrument_type_identifiers=None, symbols=None, partial_name=None, issuer_ids=None, market_ids=None, show_not_actives=None, get_non_defined=None)
    Retrieves display-ready names of matching instruments. Optional filters are available.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    instrument_type_ids: [int] or None
    instrument_type_identifiers: [string] or None
    symbols: [string] or None
    partial_name: str or None
    issuer_ids: [int] or None
    market_ids: [int] or None
    show_not_actives: bool or None
    get_non_defined: bool or None

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, 'name': string, 'full_name': string, 'issuer_id': int, 'currency_id': int,
                    'name_and_symbol': string, 'issuer_name': string, 'type_id': int, 'type_identifier': string,
                    market_id: int, 'symbol': string, 'yahoo_ticker': string}
get_instruments_administrator_names(instrument_ids, administrator_id=None, administrator_ids=None)
    Retrieves the names of the instruments in the given administrator.

    returns: { instrument_id (int): name (string) }
update_instrument_analysis(instrument_analysis)
    Updates existing instruments analysis.

    'instrument_analysis': {'instrument_analysis_id': int, 'instrument_id': int,
                            'date': date, 'contents' = str}

    returns: default success dictionary
set_instrument_price(instrument_id, nav_unit_value, date=None, administrator_id=None, price_source=None, opening_value=None, average_value=None, extra_values=None, generated_on=None, corporate_actions_factor=None)
    Sets the price of an instrument. If the administrator ID is specified, the price will be
    valid only for that administrator.

    'instrument_id': int
    'nav_unit_value': decimal
    'date': date or None
    'administrator_id': int or None
    'price_source': PRICE_SOURCES (int) or None
    'opening_value': decimal or None
    'average_value': decimal or None
    'extra_values': dict or None
    'generated_on': datetime or None
    'corporate_actions_factor': decimal, float or None

    returns: {'success': boolean, 'error_message': string or None}
impact_nav(instrument_ids=None, instrument_types=None)
    For each instrument or instrument types, indicates rather it impacts or not the nav.
    instrument_ids: [int] or None
    instrument_types: [INSTRUMENT_TYPES] or None

    returns:
    if a list of instruments was passed as parameter:
        {instrument_id (int): impacts_nav (bool)}
    else:
        {instrument_type_id (int): impacts_nav (bool)}
set_instrument_prices_multiple_dates(prices, price_source=None, administrator_id=None, redirect_index_prices=True)
    Sets the price of instruments in batch, in multiple dates.
    For more information on input parameters, refer to the set_instrument_prices API's documentation.

    'prices': [price]
        price: {'date': date} + set_instrument_prices' "price" format
    'price_source': PRICE_SOURCES (int) or None
    'administrator_id': int or None
    'redirect_index_prices': bool  # defeult: None

    returns: {'success': boolean, 'error_message': string or None}
get_sectors_root_parent()
    Returns the parent root sector for all registered sectors.

    returns: {issuer_sector_id (int): root_parent_id (int or None)}
get_instrument_types_by_identifiers(identifiers=None)
    Retrieves information for all instruments types registered. Accepts optional filters.

    identifiers: [string] or None

    returns: {identifier (string): type}
    type: {'id': int, 'identifier': string, 'display_name': string}
get_price_variations(params, apply_adjustment_factor=False, use_first_newest_price=False, use_delta_adjusted_price=True)
    Calculates price variations for multiple date pairs and/or indices.
    If currency exchange information is given, the variation will consider the exchange rates.
    If apply_adjustment_factor is True, multiplies all prices by it's corresponding corporate_actions_factor.

    params: [param]
        param: {'instrument_id': int, 'administrator_id': int or None, 'start_date': date, 'end_date': date,
                'to_currency_id': int or None, 'preferred_source_ids': [int] or None, 'max_decimal_places': int or None}
    apply_adjustment_factor: bool

    returns: {'items': [item]}
        item:  {'instrument_id': int, 'administrator_id': int or None, 'start_date': date, 'end_date': date,
                'variation': decimal or None}
    The items list is returned in the same order as the params list.
set_daily_traded_volume(volume_by_instrument, date)
    Records daily traded volume of a list of instruments in a certain date.
    This value is recoded inside the extra_values of current Price.
    If instrument has no price in this date, it's skiped.

    volume_by_instrument: {instrument_id (int): volume (decimal)}
    date: date

    returns: {'success': bool, 'updated_instrument_ids': [(int)]}
delete_instruments_groups(instruments_groups_ids)
    Delete all instruments groups in the list
    'instruments_groups_ids': [int]

    return dictionary success message
get_settlement_days(ids, date=None)
    Retrieves the settlement days for the given instruments.
    If a date is also informed, the settlement date is given for each instrument.

    ids: [int]

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, 'days': int, 'market_id': int, 'date': date or None}
get_instrument_market_info(ids=None, market_ids=None, get_country=None, active_instruments_only=True)
    Retrieves market information for instruments. Accepts optional filters.
    Returns only active instruments, except if ids are provided.
    If get_country is True, the country is also returned.

    ids: [int] or None
    market_ids: [int] or None
    get_country: bool or None  # default: False
    active_instruments_only: bool or None # default: True - if set, only active instruments are retrieved

    returns: {instrument_id (int): instrument}
        instrument: {'id': int, 'market_id': int, 'currency_id': int, 'country_id': int}
set_instrument_prices(*args, **kwargs)
get_specific_price(price_id)
    Returns data from specified price
    :param price_id:
    :return price object:
get_instruments_info(ids=None, types=None, values=None, is_monitoring_enabled=None, is_morningstar_monitoring_enabled=None, is_yahoo_monitoring_enabled=None)
    Retrieves all basic information of instruments.
    Optionally a 'values' param can be passed to filter the fields that the this funcions returns. This is good for
    optimization purposes. If no values is passed, all the fields from Instrument will be retrieved.

    ids: [int] or None
    types: [INSTRUMENT_TYPES] or None
    values: [string] or None
    is_monitoring_enabled: bool or None

    returns: {instrument_id (int): instrument}
        instrument: {'name', 'id', 'type_id', 'is_monitoring_enabled', 'symbol', 'isin_code', 'sedol_code',
                     'bloomberg_pricing_source', 'bloomberg_ticker', 'issuer_id', 'market_id', 'currency_id',
                     'price_divisor', 'round_lot', 'settlement_days', 'bloomberg_formula', 'auto_accept_type',
                     'auto_accept_price_variation_percent', 'default_strategy_id', 'type__identifier',
                     'is_active', 'display_name', 'issuance_fee', 'morningstar_price_field', 'yahoo_ticker', 'bloomberg_unique_id'} or *values
get_active_instruments_groups(date, get_instruments=False)
    Retrieves the instruments groups which date are equal or greater the provided date.

    if get_instruments is True, returns all instruments in the group.

    date: date

    returns: {group_id (int): group_info}
        issuer: {'id': int, 'name': string, 'show_instruments_as_group': boolean, 'instrument_ids': [int] or missing}
get_issuer_show_issuer_price(ids)
    Retrieves the show_issuer_price of matching issuers.

    ids: [int]

    returns: {issuer_id (int): show_issuer_price (bool) }
set_book_value(instrument_id, date, value)
    Adds or updates the instrument's book value at the given date.

    instrument_id: int
    date: date
    value: Decimal

    returns: {'entry_id': int}
get_prices_for_comparison(instrument_ids, date)
set_instrument_symbols(symbols)
    Sets the symbols of a group of instruments

    symbols: {id(int): symbol(str)}

    returns: {'success': bool, 'error_msg': str or None}
get_instrument_group_info(ids=None, get_instruments=False, names=None)
    Retrieves the names of matching instrument groups. Optional filters are available.

    ids: [int] or None
    get_instruments: bool or None  # default: False
    names: [str] or None

    returns: {issuer_group_id (int): issuer_group}
        issuer: {'id': int, 'name': string, 'differentiate_in_email': boolean, 'instrument_ids': [int] or missing}
get_instruments_first_price_date(instrument_ids)
    Gets the first price date for each instrument

    returns: {instrument_id (int): 'id': int, 'instrument_id': int, 'date': date}
get_instruments_groups(date, instruments_ids=None, show_instruments_as_group=None, use_together_for_allocation=None)
    Returns group information for Intrument Groups which reference date is equal or greater a given date.

    date: date
    instruments_ids: [int]

    returns: { group_id (int) : group }
        group: {'id': int, 'name': string, 'show_instruments_as_group': boolean, 'instrument_ids': [int]}
get_instrument_details(ids, include_instrument_base_info=None, issuer_ids=None)
    Retrieves specific details of the instrument according to it's type, calling the appropriated get_{module}_info
    method of the instrument module. If no get_{module}_info method is found for a specific module, return an empty
    dict for each instrument of this module type.
    If include_instrument_base_info is set to True, it returns also all base information of the Instrument model itself.
    IMPORTANT: Take care with the returning dicts. They VARY according to the instrument type module, so it's easy to
    get a KeyError for example.
    Common Instrument optional filters are available.

    ids: [instrument_id (int)]
    include_instrument_base_info: bool or None  # default: False
    issuer_ids: [int] or None

    returns: {instrument_id (int): details or {}}
        details: *{module}.get_{module}_info() output + instrument_base_info or {}
            # the instrument_base_info dict only applies if include_instrument_base_info is True.
            instrument_base_info: {'name', 'id', 'type_id', 'is_monitoring_enabled', 'symbol', 'isin_code',
                                   'bloomberg_pricing_source', 'bloomberg_ticker', 'morningstar_ticker', 'issuer_id', 'market_id',
                                   'currency_id', 'price_divisor', 'round_lot', 'settlement_days', 'bloomberg_formula',
                                   'auto_accept_type', 'auto_accept_price_variation_percent',
                                   'bloomberg_unique_id':str, 'cusip_code': str, 'sedol_code': str,
                                   'default_strategy_id': int or None}
add_instrument_groups(instrument_groups)
    Inserts new instrument group.

    instrument_groups: [instrument_group]
        instrument_group: {'name': str,
                           'instruments': [],
                           'differentiate_in_email': bool,
                           'date': date,
                           'old_versions': {},
                           'show_instruments_as_group': bool }
    returns: default success dictionary
Module accounting (Caixa)
set_adjustment_provisions(provisions, date, nav_by_fund=None, total_quantities=None, dont_set_dirty_snapshot=False)
    Sets adjustment provisions in batch. If an ongoing adjustment provision exists in the given fund at the given date,
    and it was created in the same month, its quantity is updated from that date onwards;
    otherwise, a new provision is created.
    If is_d0_adjustment is True a new provision is always created, so it won't affect the ongoing adjustment provision.

    The quantities should be informed in the fund's currency. It is created/updated in the provided account_id or in the
    appropriate default account, and is automatically converted to the account's currency if necessary.
    The default strategy is used.

    If is_d0_adjustment is True, the adjustment provision will end in the following day
    (therefore, it will only impact the NAV in D0), otherwise it will not have a determined end date.

    'provisions': [provision]
        provision: {'fund_id': int, 'strategy_id': int, 'category_id': int, 'quantity': decimal,
                    'origin_content_type_id': int, 'origin_id': int, 'is_d0_adjustment': boolean or None
                    'account_id': int or None, 'settlement_date': date or None,
                    'limit_absolute': Decimal or None, 'limit_relative': Decimal or None, 'limit_nav': Decimal or None}
    'date': date
    'total_quantities': bool or None  # default: False
    'dont_set_dirty_snapshot': bool

    If 'total_quantities' is False (the default), quantities are added to the provisions' current value for the day.

    If 'total_quantities' is True, it is understood that these are the target quantities for the categories,
    and the necessary changes are calculated and applied. If multiple entries are supplied for the same
    fund-category pair, they are consolidated first, by adding the quantities to form the pair's target quantity.

    When 'total_quantities' is True, limits may be informed optionally; the adjustment will be applied only if
    the discrepancy is below all informed limits. In such case, funds' NAVs may be informed in the 'nav_by_fund'
    parameter, or will be retrieved from the Portfolio module if not informed.

    returns: {'success': bool}
get_collateral_accounts(ids=None, fund_ids=None, custodian_ids=None, broker_ids=None, broker_account_ids=None)
    Retrieves collateral accounts.

    ids: [int] or None
    fund_ids: [int] or None
    custodian_ids: [int] or None
    broker_ids: [int] or None
    broker_account_ids: [int] or None

    returns: {account_id (int): account}
        account: {'id': int, 'name': string, 'fund_id': int, 'custodian_id': int, 'broker_id': int or None,
                  'currency_id': int}

    Broker IDs are returned in the response only if the parameters broker_ids or broker_account_ids were supplied.
settle_provisions(provisions, reference_date, ignore_already_settled=None, dont_set_dirty_snapshot=False, is_user_action=None)
    Settles, i.e., updates the balance of the fund's account by creating a Posting with the given quantity.
    The quantity should be left blank for a full settlement.

    Clears all provision installments from the date onwards if 'clear' is True.
    Otherwise, substracts the quantity from all installments from the date onwards.
    Use 'force_full_settlement' = True to mark the provision as being fully settled even if a quantity is specified.

    'provisions': [provision]
        provision: {'provision_id': int, 'quantity': decimal or None, 'clear': bool or None, 'account_id': int or None,
                    'force_full_settlement': bool or None, 'exchange_rate': decimal or None,
                    'exchange_quantity': decimal or None}
    'reference_date': date
    'ignore_already_settled': bool or None  # default: False
    'dont_set_dirty_snapshot': bool
    'is_user_action': bool or None # default: False

    returns: {'posting_ids': [int or None]}

    If any of the provisions has a settlement_date earlier or equal to the given date,
    an error message is returned and no changes are made to the database, unless ignore_already_settled=True.
    In this case, such provisions will not be modified, and its corresponding returned posting ID will be None.

    If a provision is a cash provision, and the dictionary specifies a settlement account in a different currency
    from the provision's account, the provision will instead be settled in the provision's original account
    # and a currency exchange operation will be performed to the indicated account.
    The quantity in the settlement account's currency may be informed through 'exchange_quantity' or
    an exchange rate may be informed through 'exchange_rate'. If both are informed, preference is given to the
    exchange quantity. If neither is supplied, the exchange rate for the date will be used.
fix_balances_with_discrepancies(date, deltas, dont_set_dirty_snapshot=False)
    Fixes incorrect account balances in the given date.

    The deltas must have been calculated beforehand to make the date's balance
    correspond to the previous date's balance plus all postings in the date.

    date: date
    deltas: {(account_id (int), strategy_id (int), instrument_id (int)): delta (decimal)}
    dont_set_dirty_snapshot: boolean

    returns {'balances_update': [int], 'success': boolean}
create_initial_accounts(fund_ids)
    Creates a default account for the given funds, as long as they don't have any active accounts yet.
    The created account will use the funds' currencies and the default custodian.

    fund_ids: [int]

    returns: {'account_id_by_fund': {fund_id (int): account_id (int) or None}}
__remove_assets_with_zero_quantity(balances_by_fund_ids)
delete_provisions(provision_ids, dont_set_dirty_snapshot=False)
    Deletes simple provisions in batch.

    provision_ids: [int]
    dont_set_dirty_snapshot: bool

    returns: {}
get_provisions_strategy(provision_ids)
    Returns provision strategy.

    provision_ids: [int]

    returns: {provision_id (int): provision}
        provision: {'attribution_strategy_id': int, 'strategy_id': int}
update_nominal_attribution_exchange_rate(changes)
    Updates the nominal attribution exchange rate field of one or more provisions.

    changes: {provision_id (int): rate (decimal or None}

    returns: {'success': bool}
update_provision_settlement_date(ids_by_date, dont_set_dirty_snapshot=False)
    Updates the settlement date of existing provisions.

    WARNING: this method currently is NOT compatible with provisions that don't settle in the clearing date,
    such as normal (pre-paid) subscriptions, and will raise an exception if used on those provisions.
    An exception will also be raised if used on non-cleared or non-settled provisions.

    ids_by_date: {new date: [provision_id (int)] }
    dont_set_dirty_snapshot: bool  # default: False

    returns: {'success': boolean}
get_provisions_by_origin(origins, values=None, get_quantities=False)
    Retrieves provisions that match the given origins. Each origin accepts optional provision filters.
    If a list of values to be retrieved is given, only those will be returned.

    origins: [origin]
        origin: {'origin_id': int, 'origin_content_type_id': int,
                 'category_id': int or None, 'instrument_id': int or None}
    values: [string]

    returns: {provision_id (int): provision}
        provision: {'id': int, 'description': string, 'origin_id': int, 'origin_content_type_id': int,
                    'category_id': int, 'instrument_id': int}
get_custody_flow_data(date_from, date_to=None, fund_ids=None, account_ids=None, currency_ids=None, only_active_accounts=True, purpose=None, instrument_ids=None, merge_balances_and_postings=False, strategy_ids=None, consolidate_strategies=True)
    Returns the current balances and expected cash flow / custody flow entries for the next days.
    For non-currency instruments, the expected financial values are also informed.
    Accepts optional filters. If the end date is not expected, all future entries are returned.

    The way results are presented depend on the flag
    consolidate_strategies; if True (the default), one entry will be returned per asset;
    if False, one entry will be returned per asset-strategy pair.

    date_from: date
    date_to: date or None
    fund_ids: [int] or None
    account_ids: [int] or None
    currency_ids: [int] or None
    only_active_accounts: bool  # default: True
    instrument_ids: [int] or None
    purpose: CASH_FLOW_PURPOSES (int) or None
    merge_balances_and_postings: bool  # default: False
    strategy_ids: [int] or None
    consolidate_strategies: bool #default: True

    returns: {'balances': [item] or None, 'postings': [item] or None: 'entries': [item] or None}
        item: {'date': date, 'fund_id': int, 'fund_name': string,
               'account_id': int, 'account_name': string, 'instrument_id': int, 'instrument_name': string,
               'instrument_type_id': int, 'instrument_type_name': string, 'category_id': PROVISION_CATEGORIES (int),
               'category_name': string,'currency_id': int, 'currency_prefix': string, 'description': string,
               'quantity': Decimal, 'value': Decimal, 'strategy_id': int or None, 'strategy_name': str or None}

    If 'merge_balances_and_postings' is False (default), current balances are returned in the 'balances' entry
    and future postings are returned in the 'postings' entry. Otherwise, both are combined into the 'entries' entry.
    All financial values are informed in the accounts' currencies.
__group_assets(data, balances_by_accounts, all_instruments_info, all_instruments_prices, all_funds_currency_info, fund_ids_by_account_ids, date, accounts, bonds_instrument_info, include_custodian_info)
unclear_provisions(provision_ids, dont_set_dirty_snapshot=False)
    Removes the clearing date from the specified provisions.

    'provision_ids': [int]
    'dont_set_dirty_snapshot': bool

    returns: {}
update_provisioned_quantities_from_date_onwards(provisions, dont_set_dirty_snapshot=False)
    Updates provisions' provisioned quantities in batch.
    Installments will be increased/decreased by the quantity delta, from the specified date onwards.
    An installment will be created in the given date if it doesn't exist yet.

    An exception will be raised if the indicated date does not fall within a provision's start date/end date boundary.

    provisions: [provision]
        provision: {'id': int, 'delta_quantity': decimal, 'date': date}
    dont_set_dirty_snapshot: bool

    returns: {}
delete_transfers(transfer_ids, dont_set_dirty_snapshot=False)
    Deletes custody transfers and related postings.

    transfer_ids: [int]
    dont_set_dirty_snapshot: bool


    returns: default success dictionary
get_postings(date_from, date_to=None, account_ids=None, fund_ids=None, strategy_ids=None, instrument_ids=None, origin_instrument_ids=None, partial_descriptions=None, get_names=False, combine_entries=False, is_collateral=None, custodian_templates=None)
    Returns all posting in the given period. If no 'date_to' is given, returns all postings made after the start date.
    Results are aggregated by account (unless combine_entries=True). Accepts optional filters.

    date_from: date
    date_to: date or None
    account_ids: [int] or None
    fund_ids: [int] or None
    strategy_ids: [int] or None
    instrument_ids: [int] or None
    origin_instrument_ids: [int] or None
    partial_descriptions: [str] or None
    get_names: bool  # default: False
    combine_entries: bool  # default: False

    returns: [account]
        account: {'account_id': int, 'account_name': str*, 'fund_id': int, 'fund_name': str*, 'postings': [posting]}
            posting: {'id': int, 'date': date, 'strategy_id': int, 'strategy_name': str*, 'instrument_id': int,
                      'instrument_name': str*, 'description': string, 'quantity': Decimal, 'day_latest_entry': bool,
                      # Next fields depend on the origin of the posting: provision or transfer.
                      'provision_id': int or None, 'transfer_id': int or None, 'provision_category_id': int or None,
                      'provision_category_name': str or None, 'origin_instrument_id': int or missing,
                      'origin_instrument_name': str* or missing}

    Values with * are present only when get_names=True.

    If combine_entries is True,
    returns: {'entries': [entry]}
        entry: account + posting
update_provision_basic_info(provision_id, category_id, new_description, new_supplier_id, new_origin_instrument_id, new_attribution_strategy_id, new_account_id, allocate_fx_attribution_separately, nominal_attribution_exchange_rate, dont_set_dirty_snapshot=False)
    Updates basic information of an existing provision.

    'provision_id': int
    'category_id': int or None
    'new_description': str
    'new_supplier_id': int or None
    'new_origin_instrument_id': int or None
    'new_attribution_strategy_id': int or None
    'new_account_id': int,
    'allocate_fx_attribution_separately': bool
    'nominal_attribution_exchange_rate': Decimal or None
    'dont_set_dirty_snapshot': boolean

    returns: {'success': boolean}
settle_partially_appropriated_provisions(provision_ids, date)
    It is used in case a provision is fully settled before the end of its period, when the system
    recalculates the taxes for the remaining period.

    provision_ids: [int]
    date: date
negative_balance_forecast(start_date=None, days=None, fund_ids=None, threshold=None, maximum_threshold=None, minimum_nav_percentage_threshold=None, maximum_nav_percentage_threshold=None, is_taxable=None, currency_ids=None)
    Looks for accounts whose balance is or will become negative, below a threshold or above a maximum threshold,
    taking into account future settlements within the next days.
    If start_date is not informed, it is considered as today. If the account balance will become negative
    in more than one date, only the first date is returned.

    Money market funds (sweep accounts), e.g. Mellon Cash, are also considered for cash purposes.

    An optional fund filter can be applied.

    start_date: date or None  # default: today
    days: int or None  # default: 3
    fund_ids: [int] or None
    is_taxable: bool or None
    currency_ids: [int] or None

    returns: {account_id (int): account}
        account: {'account_id': int, 'account_name': string, 'fund_id': int, 'fund_name': string,
                  'date': date, 'balance': decimal, 'currency_id': int}
get_provision_names(ids)
delete_postings(posting_ids, dont_set_dirty_snapshot=False)
    Deletes postings.

    'posting_ids': [int]
    'dont_set_dirty_snapshot': bool

    returns: {'success': boolean}
balance_or_provision_exists_by_instrument(instrument_id)
    Checks if a instrument is associated to any balance or provision.

    instrument_id: int

    returns: {'result': bool}
get_provisions_by_settlement_date(start_date, end_date, fund_ids=None, instrument_ids=None)
    Get the provision basic details by the settlement date in the range of start_date and end_date.
    Optional filters are available.

    start_date: date
    end_date: date
    fund_ids: [int] or None
    instrument_ids: [int] or None

    returns: [provision]
        provision: {'account_id': int, 'strategy_id': int, 'instrument_id': int, 'quantity': Decimal, 'fund_id': int,
                    'origin_id': int or None, 'origin_content_type_id': int or None}
update_provisions_origin(content_type_id, origin_mapping)
    Changes the 'origin_id' of provisions of a given 'content_type_id' according to 'origin_mapping'

    content_type_id: int
    origin_mapping: {old_origin_id(int): new_origin_id(int)}

    returns: {'success': bool, 'messages': []}
add_postings(postings, dont_set_dirty_snapshot=False)
    Adds postings and updates balances accordingly.
    For each posting, either the originating provision or transfer must be specified (but not both).

    'postings': [posting]
        posting: {'account_id': int, 'strategy_id': int, 'date': date, 'description': string, 'quantity': decimal,
                  'provision_id': int or None, 'transfer_id': int or None, 'is_provision_settlement': bool or None,
                  'instrument_id': int or None  # default: the account's instrument
                 }
    'dont_set_dirty_snapshot': bool

    returns: {'posting_ids': [int]}
get_custody_transfer_info(start_date=None, end_date=None, fund_ids=None, instrument_ids=None)
    Retrieves custody transfer information. Accepts optional filters.

    'start_date': date or None
    'end_date': date or None
    'fund_ids': [int] or None
    'instrument_ids': [int] or None

    returns: {'transfers': [transfer] or None, 'errors': [Django form error] or None}
        transfer: {'transfer_id': int, 'fund_id': int, 'fund_name': str, 'strategy_id': int, 'strategy_name': str,
                   'instrument_id': int, 'instrument_name': str, 'date': date,
                   'account_from_id': int, 'account_to_id': int, 'account_from_name': str, 'account_to_name': str}
get_provisions(date, min_date=None, ids=None, exclude_ids=None, fund_ids=None, account_ids=None, supplier_ids=None, strategy_ids=None, instrument_ids=None, description=None, is_settled=None, category_ids=None, origin_ids=None, origin_content_type_id=None, origin_instrument_ids=None, use_account_currency=False, convert_to_fund_currency=False, include_cleared=False, get_final_quantity=False, get_installments=False, force_business_days_only_for_installments=False, total_currency_id=None, get_totals=False)
    Gets information on all provisions valid or cleared in the given date, i.e. the provisions satisfying
    start_date <= date <= clearing_date. Accepts various optional filters.

    date: date
    min_date: date or None
    ids: [int] or None
    exclude_ids: [int] or None
    fund_ids: [int] or None
    account_ids: [int] or None
    supplier_ids: [int] or None
    strategy_ids: [int] or None
    instrument_ids: [int] or None
    description: str or None
    is_settled: bool or None
    category_ids: [PROVISION_CATEGORIES (int)] or None
    origin_ids: [int] or None
    origin_content_type_id: int or none
    origin_instrument_ids: [int] or None
    use_account_currency: bool  # default: False
    convert_to_fund_currency: bool  # default: False
    include_cleared: bool  # default: False
    get_final_quantity: bool  # default: False
    get_installments: bool  # default: False
    force_business_days_only_for_installments: bool  # default: False
    total_currency_id: int or None
    get_totals: bool  # default: False

    If 'min_date' is also supplied, the date filter changes to: start_date <= date, min_date <= clearing_date.
    However, the informed quantities are still those valid for 'date'.

    If get_installments is True, all installments are returned, unless min_date is supplied; in that case,
    only the installments between min_date and date will be returned.

    If use_account_currency is True, the instrument_ids argument will be ignored,
    and the accounts' currencies will be used as the instruments for filtering.

    If convert_to_fund_currency is True, the instrument_ids argument will be ignored, all currency instruments will
    be selected, and a financial value will be calculated (based on installment_quantity + settled_quantity),
    converted to the fund's currency (if necessary) and informed in the 'fund_currency_value' result key.

    returns: {'provisions':[provision], 'total_by_category': total_by_category or None}
    provisions:  {'provision_id': int, 'instrument_id': int, 'fund_id': int, 'account_id': int, 'strategy_id': int,
                 'attribution_strategy_id': int or None, 'category_id': int, 'category_name': string,
                 'start_date': date, 'amortization_end_date': date or None,
                 'clearing_date': date or None, 'settlement_date': date or None,
                 'total_quantity': decimal, 'installment_quantity': decimal, 'settled_quantity': decimal,
                 'description': string, 'type': PROVISIONING_TYPES (int),
                 'type_display': string, 'origin_id': int or None, 'origin_content_type_id': int or None,
                 'can_be_settled': boolean, 'can_be_unsettled': boolean, 'can_be_cleared': boolean, 'can_be_deleted': bool,
                 'is_system_provision': bool, 'is_blocked_system_provision': bool, 'origin_instrument_id': int,
                 'supplier_id': int or None, 'supplier': string, 'nominal_attribution_exchange_rate': decimal or None,
                 'allocate_fx_attribution_separately': bool, 'is_adjustment': bool}
                # next entries present only if convert_to_fund_currency is True:
              + {'original_currency_value': decimal, 'fund_currency_value': decimal, 'exchange_rate': decimal or None}
                # next entries present only if get_final_quantity is True:
              + {'final_quantity': decimal or missing}
                # next entries present only if get_installments is True:
              + {'installments': [installment]}
    installment: {'id': int or None, 'date': date, 'value': decimal, 'settled_value': decimal, 'total_value': decimal}
                 # next entries present only if convert_to_fund_currency is True:
               + {'exchange_rate': decimal or missing}
    total_by_category: {category_id (int): {'settled': Decimal,'provisioned': Decimal}
add_simple_provisions(provisions, dont_set_dirty_snapshot=False)
    Adds simple provisions in batch.

    provisions: [provision]
        provision: {'account_id': int, 'instrument_id': int or None, 'strategy_id': int,
                    'attribution_strategy_id': int or None, 'quantity': decimal, 'is_adjustment': bool or None,
                    'start_date': date, 'settlement_date': date or None, 'clearing_date': date or None,
                    'description': string or None, 'category_id': int, 'origin_content_type_id': int or None, 'origin_id': int or None,
                    'installments': [installment] or None, 'origin_instrument_id': int or None,
                    'nominal_attribution_exchange_rate': decimal or None,
                    'provisioning_business_days_only'
                    # Next fields for cash provisions and allocated funds only.
                    'pnl_allocation_strategy_id': int or None,
                    'pnl_allocation_criterion': PNL_ALLOCATION_CRITERIA (int) or None,
                    'pnl_allocation_participation_strategy_id': int or None,
                    'pnl_allocation_investor_accounts': {ia_id (int): participation (Decimal)} or None,
                    'allocate_fx_attribution_separately': bool or None,
                    }
        installment: {'date': datetime, 'quantity': decimal}
    dont_set_dirty_snapshot: bool

    If the instrument_id is omitted, the account's currency's instrument is used.

    If installments are informed, there must be at least one in each date, otherwise an error will be raised:
    start_date and clearing_date (if supplied).

    Installments should contain

    returns: {'provision_ids': [int]}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_provisions_origin_info(provision_ids)
    Retrieves provisions origin information.

    provision_ids: [int]

    returns: {provision_id (int): provision}
        provision: {'origin_id': int, 'origin_content_type_id': int}
get_custodians_grouped_by_fund(funds, currency_id=None)
    funds: [fund_id (int)]
    currency_id: int

    returns: {fund_id (int): [account]}
        account: {'account_id': int, 'account_name': string, 'custodian_id': int,
                  'custodian_name': string, 'is_default_for_executions': bool,
                  'is_collateral': bool}
get_balances_per_account_and_strategy(date, end_date=None, account_ids=None, fund_ids=None, strategy_ids=None, instrument_ids=None, instrument_types=None)
    Gets accounts' balances at a specific date or in a date range, splitting quantities by strategy.

    date: date
    end_date: date or None
    account_ids: [int] or None
    fund_ids: [int] or None
    strategy_ids: [int] or None
    instrument_ids: [int] or None

    If end_date is None:
    returns: accounts
        accounts: {account_id (int): account}
            account: {strategy_id (int): strategy}
                strategy: {instrument_id (int): quantity (Decimal)}

    If end_date is not None:
    returns: {date: accounts}
import_currency_exchange_xls_file(files, legacy_mode=False)
    Imports and processes a file containing currency exchange operations.

    files: [file]
        file: {'filename': string, 'contents': string}

    returns: default multifile dictionary + {'item_count': int}
get_provision_installments(provision_ids, from_date=None, until_date=None, min_until_date=None, get_postings=False, force_business_days_only=None)
    Gets details of the installments of a provision.

    'provision_id': int
    'from_date': date
    'until_date': date
    'min_until_date': date
    'force_business_days_only': bool or None

    returns: {provision_id: [installment]}
    installment: {'id': int or None, 'date': date, 'value': decimal, 'settled_value': decimal, 'total_value': decimal,
                  'postings': [posting] or missing}
        posting: {'id': int, 'value': decimal}

    When get_postings=True, the return key 'postings' is present only in dates with postings,
    to reduce the returned dictionary's size.

    The parameter 'min_until_date' can be used to ensure that in-memory installments are calculated
    (for non-cleared provisions) at least until a specific date. This argument is ignored if 'until_date' is supplied.
get_default_accounts_for_liability_transactions(fund_ids=None)
    Retrieves the default accounts for liability transactions. Accepts optional filters.

    fund_ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'subscription': account_id (int), 'redemption': account_id (int), 'other': account_id (int)}
update_provision_instrument(changes, dont_set_dirty_snapshot=False)
    Updates the instrument of existing provisions.

    changes: {provision_id (int): new_instrument_id (int)}
    dont_set_dirty_snapshot: bool  # default: False

    returns: {'success': boolean}
update_provision_strategy(ids_by_strategy, dont_set_dirty_snapshot=False)
    Updates the strategy of existing provisions.

    ids_by_strategy: {new strategy (int): [provision_id (int)] }
    dont_set_dirty_snapshot: bool  # default: False

    returns: {'success': boolean}
update_provision_postings(provisions, dont_set_dirty_snapshot=False)
    Updates the postings related to the provisions and dates given.

    provisions: {provision_id: [posting]}
        posting: {'date': date, 'quantity': qty, 'is_full_settlement': bool}
get_account_balances(date, end_date=None, account_ids=None, fund_ids=None, strategy_ids=None, instrument_ids=None, instrument_types=None)
    Gets accounts' balances at a specific date; all strategies' quantities are consolidated. Accepts optional filters.

    date: date
    end_date: date or None
    account_ids: [int] or None
    fund_ids: [int] or None
    strategy_ids: [int] or None
    instrument_ids: [int] or None

    If end_date is None:
    returns: accounts
        accounts: {account_id (int): account}
            account: {instrument_id (int): quantity (Decimal)}

    If end_date is not None:
    returns: {date: accounts}
check_simulated_orders_feasibility(orders)
    orders: [order]
    order - {'fund_id': int, 'inst_currency_id': int, 'financial': Decimal, 'date': date, 'accounting_days': int,
     'inst_market_id': int (Only if fund_id is None), 'instrument_id': int}
__calculate_nav_value_balance(balances_by_fund_ids, all_instruments_info, bonds_agreement_price, include_custodian_info)
get_account_administrator_names(account_ids=None, administrator_ids=None, fund_ids=None)
    Retrieves the names of the instruments in the given administrator.

    returns: { (account_id (int), administrator_id (int): [name (string)] }
get_provision_settlement_dates(provision_id, start_date=None)
    Retrives the dates in which this provision has been settled
    provision_id: int
    start_date: date or None

    return: [date]
get_currency_exchanges_info(start_date=None, end_date=None, settlement_start_date=None, settlement_end_date=None, fund_ids=None, strategy_ids=None, currency_from_ids=None, currency_to_ids=None, always_positive=False, is_automatic=None)
    Retrieves currency exchange information. Accepts optional filters.

    'start_date': date or None
    'end_date': date or None
    'settlement_start_date': date or None
    'settlement_end_date': date or None
    'fund_ids': [int] or None
    'strategy_ids': [int] or None
    'currency_from_ids': [int] or None
    'currency_to_ids': [int] or None
    'always_positive': bool  # default: False
    'is_automatic': bool or None

    If 'always_positive' is True, operations with negative quantity will be reversed in-place (from/to return fields),
    and a new return field 'is_reversed' will be added.


    returns: {'currency_exchanges': [exchange] or None, 'errors': [Django form error] or None}
        exchange: {'id': int, 'fund_name': str, 'fund_id': int, 'strategy_id': int, 'strategy_name': str,
                   'account_from_name': str, 'account_to_name': str, 'account_from_id': int, 'account_to_id': int,
                   'date': date, 'settlement_date_from': date, 'settlement_date_to': date,
                   'instrument_from_id': int, 'instrument_from_name': str,
                   'instrument_to_id': int, 'instrument_to_name': str, 'quantity_from': Decimal, 'quantity_to': Decimal,
                   'is_reversed': bool or missing, 'broker_id': int or None, 'broker_name': str or None,
                   'basket_id': int or None, 'basket_name': str or None, 'is_automatic': bool}
get_accounts_by_fund_for_display(fund_ids=None, include_fund=False, include_custodian=True, include_currency=True, currency_ids=None)
    Retrieve all accounts for display in frontend for the given fund_ids, grouped by fund.

    fund_ids: [int] or None
    include_fund: bool  # default: False
    include_custodian: bool  # default: True
    include_currency: bool  # default: True

    returns: {'funds': {fund_id (int): accounts}, 'account_info': {account_id (int): info}}
        account: {account_id (int): account_name (string)}
        info: {'id': int, 'currency_id': int}
add_collateral_transfers(transfers, date)
    Register collateral transfers of one instrument in a fund if collateral account exists.

    transfers: [transfer]
        transfer: {'instrument_id': int, 'fund_id': int, 'quantity': Decimal}

    returns: {'success': bool, 'transfers': [transfer]}
        transfer: {'id': int, 'posting_from_id': int, 'posting_to_id': int}
get_account_currency_instruments(ids=None)
    Gets accounts' currency and currency instrument. Accepts optional filters.

    ids: [int] or None

    returns: {account_id (int): account}
        account: {'id': int, 'currency_id': int, 'instrument_id': int}
delete_currency_exchanges(exchange_ids, dont_set_dirty_snapshot=False)
    Deletes currency exchanges and related provisions.

    ids: [int]
    returns: default success dictionary
get_assets(date=None, fund_ids=None, custodian_ids=None, include_lending_quantities=False, include_custodian_info=False)
    date: date
    fund_ids: [int]
    custodian_ids: [int]
    include_lending_quantities: bool
    group_by_custodian_info: bool
    group_by_fund: bool

    if include_custodian_info = True
        returns {assets: {fund_id: (custodian_id,instrument_id): {'quantity': Decimal, 'nav_unit_value': Decimal, 'nav_value': Decimal, 'type_id': int,
                                                    'instrument_id': int, 'settlement_price': Decimal,  : Decimal}}}}
    else
        returns {assets: {fund_id: instrument_id: {'quantity': Decimal, 'nav_unit_value': Decimal, 'nav_value': Decimal, 'type_id': int,
                                                'instrument_id': int, 'settlement_price': Decimal,  : Decimal}}}}
update_simple_provision_dates(provisions, dont_set_dirty_snapshot=False)
    Updates the start and settlement date of provisions in batch

    provisions: {provision_id (int): provision}
        provision: {'start_date'; date or None, 'settlement_date': date or None,
        'clearing_date': date or None}
update_installments(installments_by_id=None, installments_by_date=None, dont_set_dirty_snapshot=False, values_are_nav_effect=False)
    Updates the installment quantities on specified provision installments.
    Installments can be specified by ID or by (provision ID, date) pair.

    If 'values_are_nav_effect' is True, the informed values will be understood as the expected NAV effects
    (considering settled + provisioned quantity). Otherwise, they will be understood as the provisioney quantity only.

    installments_by_id: {installment_id (int): quantity (Decimal)} or None
    installments_by_date: {'provision_id': int, 'installments': {date: quantity (Decimal)}}
    dont_set_dirty_snapshot: boolean
    values_are_total_quantity: boolean

    returns: {'error_message': string or None}
get_account_codes(ids=None, fund_ids=None, is_active=None, codes=None, safekeeping_codes=None, tordist_codes=None, custodian_templates=None, custodian_ids=None, include_custodian_info=False, include_bank_info=False, fund_names_in_custodian=None)
    Retrieves codes for accounts and their custodians. Accepts optional filters.

    ids: [int] or None
    fund_ids: [int] or None
    is_active: bool or None
    codes: [string] or None
    tordist_codes: [string] or None
    safekeeping_codes: [string] or None
    custodian_templates: [CUSTODIAN_TEMPLATES (int)] or None
    include_bank_info: bool  # default: False  # adds custodian info to the response
    include_bank_info: bool  # default: False  # adds bank info to the response

    returns: {account_id (int): account}
        account: {'id': int, 'fund_id': int, 'name': string, 'code': string, 'tordist_code': int, 'tordist_digit': int,
                  'safekeeping_code': string, 'fund_name_in_custodian': string, 'is_collateral': bool, 'currency_id': int,
                  'xml_anbima_code': string}
                 # if include_custodian_info:
                 + {'custodian_id': int, 'custodian_name': string, 'custodian_tordist_code': int,
                    'custodian_tordist_digit': int}
                 # if include_bank_info:
                 + {'bank_id': int or None, 'bank_name': string or None,
                    'bank_branch_number': string, 'bank_account_number': string}
update_posting(posting_id, quantity, sum_quantity=False, dont_set_dirty_snapshot=False)
    Updates a posting's quantity.

    'posting_id': int
    'quantity': decimal
    'sum_quantity': boolean  # If True, the former quantity will be increased rather than replaced.
    'dont_set_dirty_snapshot': boolean

    returns: {'success': boolean}
get_default_accounts_by_currency(fund_ids=None, currency_ids=None)
    Retrieves the default accounts for settlements in each currency.

    fund_ids: [int]
    currency_ids: [int] or None

    returns: {fund_id (int): fund_accounts}
        fund_accounts: {currency_id (int): account}
        account: {'id': int, 'name': string}

    If a fund/currency pair doesn't exist, its entry will be missing (it will not be filled with Nones).
get_provision_period_and_values(start_date, end_date=None, fund_id=None, period_value=None, period_type=None, quantity=None, installments_count=None, installments_quantity=None, is_business_days_only=True, priority='start_date')
    Calculates the period and values of the provision, depending on what parameters are passed.

    returns: {
        'start_date': date, 'end_date': date, 'period_value': Decimal,
        'period_type': string, # 'days', 'months' or 'years'
        'quantity': Decimal, 'installments_count': int, 'installments_quantity': Decimal}

    Returns an empty dictionary if insufficient data is passed.
get_default_accounts_for_custody_fee(fund_ids=None, custodian_ids=None, is_active=True, is_collateral=False)
    Returns all accounts organized by fund, by custodian and by currency.
    Default-for-custody-fee accounts are placed first, and collateral accounts (if not filtered out) are placed last.

    By default, only active, non-collateral accounts are considered.

    fund_ids: [int]
    custodian_ids: [int]
    is_active: bool  # default: True
    is_collateral: bool  # default: False

    returns: {fund_id (int): {accounts_by_custodian}}
        accounts_by_custodian: {custodian_id (int): {accounts_by_currency}}
            account_by_currency: {currency_id (int): [account_id (int)]}
add_posting(account_id, strategy_id, date, description, quantity, provision_id=None, transfer_id=None, instrument_id=None, is_provision_settlement=None, dont_set_dirty_snapshot=False)
    THIS API IS DEPRECATED. New code should use add_postings() instead.

    Adds a posting to an account.
    Either the originating provision or transfer must be specified (but not both).

    'account_id': int
    'strategy_id': int,
    'date': date
    'description': string
    'quantity': decimal
    'instrument_id': int or None  # default: the account's instrument
    'is_provision_settlement': bool or None  # default: False
    'dont_set_dirty_snapshot': bool

    returns: {'posting_id': int}
get_provisions_by_origin_and_content_type(items, values=None)
    Gets provisions by their content origin_content_type_id and origin_id
    and returns the provisions grouped by those.

    items: [(origin_content_type(int), origin(int))]
    values: [str]

    returns: {(origin_content_type(int), origin(int)): [values]}
get_statement_details(fund_id, date_from, date_to=None, account_ids=None, strategy_ids=None, consolidate_strategies=True)
    Get the bank statement of the given fund. The results are aggregated by the fund's accounts and then by category.
    The category is the respective provision category of the Posting if it's origin is from a provision OR an unique
    'transfer' category, in case it's origin is from a transfer. If the posting has no provision and transfer assigned
    to it the category is 'inconsistent_data'.
    Only currency instruments are considered in this method.

    The default behavior ir to consolidate the balances of all strategies, but this may be switched off through
    the 'consolidate_strategies' parameter. In this case, the same account may show up multiple times,
    once for each strategy. When not consolidating strategies, empty account-strategy pairs will not be returned.

    fund_id: int
    date_from: date
    date_to: date or None
    account_ids: [int] or None
    strategy_ids: [int] or None
    consolidate_strategies: bool  # default: True

    returns: {'currency_id': int, 'currency_prefix': string, 'previous_balance': {'date': Date, 'quantity': Decimal},
              'final_balance': {'date': Date, 'quantity': Decimal}, 'accounts': [account]}
        account: {'account_id': int, 'account_name': string, 'is_default_for_executions': boolean,
                  'strategy_id': int or None, 'strategy_name': string or None,
                  'currency_id': int, 'currency_prefix': string,
                  'previous_balance': {'date': Date, 'quantity': Decimal},
                  'final_balance': {'date': Date, 'quantity': Decimal}, 'categories': [category]}
        category: {'category_name': string, 'category_key': string, 'quantity': Decimal, 'partial_balance': Decimal,
                   'day_first_entry': bool, 'day_latest_entry': bool, 'is_end_date': bool, 'postings': [posting]}
        posting: {'date': Date, 'account_id': int, 'strategy_id': int, 'instrument_id': int,
                  'description': string, 'quantity': Decimal, 'partial_balance': Decimal,
                  'provision_id': int or None, 'transfer_id': int or None}
add_currency_exchange_operations(operations, dont_set_dirty_snapshot=False)
    Registers multiple currency exchange operations.

    Restrictions:
    - In each operation, both accounts must belong to the same fund.
    - Either quantity_to or exchange_rate must be informed for each oepration, but not both.
    - The settlement dates must be equal or later than the operation date.

    operations: [operation]
        operation: {'strategy_id': int 'account_from_id': int, 'account_to_id': int,
                    'date': date, 'settlement_date_to': date, 'settlement_date_from': date,
                    'instrument_from_id': int, 'instrument_to_id': int,
                    'quantity_from': Decimal, 'quantity_to': Decimal, 'description': str or None,
                    'broker_id': int or None, 'basket_id': int or None, 'is_automatic': bool or None}
    dont_set_dirty_snapshot: bool

    returns: {'success': bool, 'currency_exchange_ids': [int]}
clear_provisions(provision_ids, reference_date, is_full_settlement=False, dont_set_dirty_snapshot=False, is_user_action=None)
    Clears provisions by setting the present installments' quantity to 0
    and deleting all future installments and postings.

    If performing a full settlement, the present installments are also deleted to ensure that the full
    provision quantity is used as the settled quantity when the provision is queried at the settlement date.

    'provision_ids': [int]
    'reference_date': date
    'dont_set_dirty_snapshot': bool
    'is_user_action': bool or None # default: False

    returns: {'provision_ids': [int], 'error_message': string}
get_provision_details(provision_id)
    Gets detailed information on a provision, including a 'history' of past and future installments
    of each input provision.

    returns: {'provision_id': int, 'instrument_id': int, 'fund_id': int, 'fund_name': string, 'account_name': string,
              'strategy_id': int, 'strategy_name': string, 'description': string, 'category': int,
              'category_name': string, 'type': int, 'type_display': string, 'is_system': bool,
              'start_date': date, 'clearing_date': date or None, 'settlement_date': date or None,
              'amortization_end_date': date or None, 'is_business_days_only': bool, 'is_automatic_settlement': bool,
              'quantity': Decimal, 'installments': [installment], 'account_id': int, 'last_valid_date': date or None,
              'origin_id': int or None, 'origin_content_type_id': int or None, 'origin_content_type_name': str or None,
              'origin_instrument_id': int or None, 'attribution_strategy_id': int or None,
              'nominal_attribution_exchange_rate': Decimal or None, 'allocate_fx_attribution_separately': bool}
             # For allocated funds, and only if a corresponding allocation exists:
             + {'allocation_id': int or None,
                'pnl_allocation_criterion': PNL_ALLOCATION_CRITERIA or None,
                'pnl_allocation_participation_strategy_id': int or None,
                'pnl_allocation_investor_accounts': {investor_account_id (int): factor (Decimal)}}
        installment: {'id': int or None, 'date': date, 'value': decimal, 'settled_value': decimal,
                      'total_value': decimal}

    Return item 'last_valid_date' is the date of the last non-cleared installment, but only if the the provision is
    a simple provision and the settlement date is the same as the clearing date.
get_account_names(ids=None, fund_ids=None, custodian_ids=None, is_active=None, currency_ids=None, custodian_templates=None, names_in_custodian=None)
    Gets basic information on accounts. Accepts optional filters.

    ids: [int] or None
    fund_ids: [int] or None
    custodian_ids: [int] or None
    is_active: bool or None
    currency_id: [int] or None

    returns: {account_id (int): account}
        account: {'id': int, 'name': str, 'full_name': str, 'name_with_custodian': str, 'code': str,
                  'is_collateral': bool, 'is_default_for_executions': bool,
                  'currency_id': int, 'fund_id': int, 'custodian_id': int, 'custodian_name': str,
                  'is_taxable': bool}

    Name: Account Name
    Full name: Custodian Name - Account Name
    Name with custodian: Account Name (Custodian Name)
negative_balance_lookup(start_date=None, fund_ids=None)
    Looks for accounts whose balance is or will become negative, taking into account future settlements within the
    next 3 days. If start_date is not informed, it is considered as today. If the account balance will become negative
    in more than one date, only the first date is returned.

    Money market funds (sweep accounts), e.g. Mellon Cash, are also considered for cash purposes.

    An optional fund filter can be applied.

    fund_ids: [int]
    start_date: Date

    returns: [account_and_date]
    account_and_date: {'account_id': int, 'date': Date, 'balance': Decimal, 'currency_id': int} or None
get_accounts_by_fund(fund_ids=None, is_active=None, is_collateral=None)
    Retrieve all accounts for the given fund_ids. Accepts optional filters.

    fund_ids: [int]
    is_active: bool or None
    is_collateral: bool or None

    returns: {fund_id (int): [account_id (int)]}
add_custody_transfers(transfers, dont_set_dirty_snapshot=True)
    Register custody transfers of one instrument from one account to another.

    transfers: [transfer]
        transfer: {'instrument_id': int, 'strategy_id': int, 'date': date, 'quantity': Decimal,
                   'account_from_id': int, 'account_to_id': int, 'description': str or None}
    dont_set_dirty_snapshot: bool # default True (custody transfers do not cause portfolio changes with total nav impact)

    returns: {'success': bool, 'transfers': [transfer]}
        transfer: {'id': int, 'posting_from_id': int, 'posting_to_id': int}
get_default_accounts_for_executions(fund_ids=None)
    Retrieves the default accounts for executions. Accepts optional filters.

    If multiple accounts are marked with 'is_default_for_executions',
    preference is given to the account with the same currency as the fund.

    fund_ids: [int] or None

    returns: {fund_id (int): account_id (int)}
add_cash_provision(account_ids, description, category_id, _type, start_date, is_automatic_settlement, is_business_days_only, quantity, installments_quantity=None, installments_count=None, end_date=None, instrument_id=None, strategy_id=None, attribution_strategy_id=None, origin_content_type_id=None, origin_id=None, origin_instrument_id=None, supplier_id=None, settlement_account_ids=None, settlement_exchange_rate=None, settlement_exchange_quantity=None, nominal_attribution_exchange_rate=None, allocate_fx_attribution_separately=None, pnl_allocation_criterion=None, pnl_allocation_strategy_id=None, pnl_allocation_participation_strategy_id=None, pnl_allocation_investor_accounts=None, dont_set_dirty_snapshot=False)
    Adds a new detailed cash provision.

    account_ids: [int]
    instrument_id: int or None  # if None, the account's currency's instrument is used
    description: string
    category_id: int
    strategy_id: int
    attribution_strategy_id: int or None
    _type: PROVISIONING_TYPES (int)
    start_date: date
    end_date: date or None
    is_automatic_settlement: boolean  # always true for amortized provisions
    is_business_days_only: boolean
    quantity: decimal
    installments_quantity: decimal or None  # required for non-single provisions
    installments_count: int or None  # required for non-single provisions
    origin_content_type_id: int or None
    origin_id: int or None
    origin_instrument_id: int or None
    supplier_id: int or None
    settlement_account_ids: [int or None] or None  # If informed, must have the same length as account_ids
    settlement_exchange_rate: Decimal or None  # used for settling in an account with a different currency
    settlement_exchange_quantity: Decimal or None  # used for settling in an account with a different currency
    nominal_attribution_exchange_rate: Decimal or None
    dont_set_dirty_snapshot: bool
    # Next fields for allocated funds only.
    allocate_fx_attribution_separately: bool or None  # default: False
    pnl_allocation_criterion: PNL_ALLOCATION_CRITERIA (int) or None
    pnl_allocation_strategy_id: int or None
    pnl_allocation_participation_strategy_id: int or None
    pnl_allocation_investor_accounts: {investor_account_id (int): participation (Decimal)} or None

    Origin information shouldn't be omitted except for manual user-created provisions.

    For more information on settling on a different account, see the documentation of settle_provisions()

    returns: {'provision_id': int, 'error_message': string}
get_default_accounts_for_fees(fund_ids=None)
    Retrieves the default accounts for management and performance fees. Accepts optional filters.

    fund_ids: [int] or None

    returns: {fund_id(int): account_id (int)}
get_accounts_by_fund_custodian_and_currency(fund_ids=None, custodian_ids=None, currency_ids=None, is_active=True, is_collateral=False)
    Returns all accounts organized by fund, by custodian and by currency.
    Default-for-execution accounts are placed first, and collateral accounts (if not filtered out) are placed last.

    By default, only active, non-collateral accounts are considered.

    fund_ids: [int]
    custodian_ids: [int]
    is_active: bool  # default: True
    is_collateral: bool  # default: False

    returns(if currency_ids is None): {fund_id (int): {accounts_by_custodian}}
        accounts_by_custodian: {custodian_id (int): {accounts_by_currency}}
            account_by_currency: {currency_id (int): [account_id (int)]}
    returns(else):{fund_id (int): {accounts_by_currency}}
                  account_by_currency: {currency_id (int): [account_id (int)]}
get_custodians(ids=None, templates=None, names=None)
    Retrieves custodian information. Allows optional filters.

    ids: [int] or None
    templates: [CUSTODIAN_TEMPLATES (int)] or None
    names: [str] or None

    returns: {custodian_id (int): custodian}
        custodian: {'id': int, 'name': str, 'template': CUSTODIAN_TEMPLATES (int),
                        'integration_module': string or None}
import_provisions_xls_file(files)
    Imports and processes a file containing provisions.

    files: [file]
        file: {'filename': string, 'contents': string}

    returns: default multifile dictionary + {'provision_count': int}
get_custodians_administrator_codes(custodian_ids=None, administrator_ids=None)
    Retrieves CustodianAdministrator information. May be filteres by custodian_ids or administrator_ids.

    custodian_ids: [int] or None
    administrator_ids: [int] or None

    returns: {(custodian_id, administrator_id): code}
        custodian_id: int
        administrator_id: int
        code: str
get_custody_transfer_for_wire_instructions(date, file_type_identifier)
get_posting_details(date_from, date_to=None, account_ids=None, strategy_ids=None, instrument_ids=None)
    This method has been deprecated and now points to get_postings().

    See get_postings() for details.
get_provisions_by_id(ids, values=None)
    Gets a group of provisions by id

    ids: [int]
    values: [str]

    returns: {id (int): values}
set_positions_from_snapshot(date, fund_ids, snapshot_ids=None, create_operations=False, dont_set_dirty_snapshot=False)
    Updates funds' balances and provisions at the given date so that they match their snapshots' contents.
    Mostly useful for migrating/setting up funds after importing a XML in replacement mode.
    Should be used with care as this action is not easily reversed.

    date: date
    fund_ids: [int]
    snapshot_ids: [int] or None
    create_operations: bool  # default: False
    dont_set_dirty_snapshot: bool  # default: False

    returns: default success dictionary
verify_account_currency(date, account_ids=None, fund_ids=None, strategy_ids=None, balances=None, instruments_info=None, accounts_info=None, fix=None)
unsettle_provisions_at_dates(provisions, dont_set_dirty_snapshot=False)
    Undoes provision settlements at the given dates.

    provisions: [provision]
        provision: {'id': int, 'date': date}
    dont_set_dirty_snapshot: boolean

    returns: {'success': boolean}
change_provision_account(updates, check_currency=True, check_fund=True, dont_set_dirty_snapshot=False)
    Changes the account of the given provisions.
    By default, the new account must have the same currency and fund as the old account.

    updates: [update]
        update: {'provision_id': int, 'account_id': int}
    check_currency: bool  # default: True
    check_fund: bool  # default: True
    dont_set_dirty_snapshot: boolean

    returns: {'success': boolean}
update_simple_provisions_quantities(provisions, date=None, dont_set_dirty_snapshot=False)
    Updates simple provisions' quantities in batch.
    Installments and final settlement postings will be increased/decreased by the quantity delta.

    provisions: [provision]
        provision: {'id': int, 'quantity': decimal, 'sum_quantity': boolean or None}
    date: date or None
    only_specified_date: bool
    dont_set_dirty_snapshot: bool

    If 'sum_quantity' is True, the former quantity will be increased rather than replaced.
    if 'date' is not None, the provisions' installments will only be update from the 'date' onwards.

    returns: {}
update_installment_at_date(provisions, date, dont_set_dirty_snapshot=False)
    Updates the selected provisions' installments at the given date.

    In the provision dictionary, 'settled_quantity' is the quantity of any settlements on that day.
    Posting MUST exist for this value to be updated correcly.

    provisions: {provision_id (int): provision}
        provision: {'quantity': Decimal, 'settled_quantity': Decimal or None}
    date: date
    dont_set_dirty_snapshot: bool

    returns: {}
get_supplier_names(supplier_ids=None)
import_custody_transfers_xls_file(files)
    Imports and processes a file containing custody transfers.

    files: [file]
        file: {'filename': string, 'contents': string}

    returns: default multifile dictionary + {'item_count': int}
Module bonds (Renda Fixa)
get_agreement_by_code(codes=None, internal_asset_ids=None, fund_ids=None, instrument_ids=None)
import_bond_agreement_unvs_from_xls(files)
    Imports a XLS file with bond agreement UNV's.
import_bond_agreement_prices_from_xls(files)
    Imports a XLS file with bond agreement prices.
get_updated_nominal_value(bond_type_ids=None, date=None)
export_bond_agreements_xls(date, fund_ids=None)
    Exports a XLS file with bond agreements.
get_bonds_agreement_info(bond_ids=None, instrument_ids=None)
    Gets simple BondAgreement's info

    bond_ids: [int]
update_internal_asset_ids(code_by_agreement_id)
    Updates BondAgreement's internalassetid's
    code_by_agreement_id: {id: code (string)}
    returns: {success: bool}
add_bond_instruments(bond_instruments)
    Inserts new bond instruments.

    'bond_instruments': [bond_instrument]
    returns: default success dictionary
get_prices_multiple_dates(instrument_ids=None, market_id=None, instrument_type=None, start_date=None, end_date=None, price_source=None)
add_instrument_payments(payments)
get_agreement_index_variation_behaviour(agreement_ids)
    agreement_ids: [int]

    return: {agreement_id: INDEX_VARIATION_BEHAVIORS}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
delete_agreements(bond_ids)
    Deletes BondAgreement's

    bond_ids: [int]

    returns: {success: bool}
get_vna_variation(bond_type_id, start_date, end_date, face_value=Decimal('0'))
calculate_agreement_prices(date, fund_ids, recalculate_internal=False)
get_bond_quantities(agreement_ids, date=None, get_opening_quantity=False)
    Retrieves agreements date quantity
    ids: [int]
    date: date
    get_opening_quantity: bool (Gets agreements date quantity disregarding operations made in this very day)

    returns: {id(int): quantity (Decimal)}
add_updated_nominal_values(unvs)
    Adds BondType's unvs
    unvs: [unv]
        ap: {'date': date, 'value': Decimal, 'bond_type_id': int}
    returns: {success: boool}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_bond_agreements_data(bond_ids=None, bond_type_ids=None, fund_ids=None, broker_ids=None, issuer_ids=None, instrument_ids=None, start_date=None, end_date=None, date_type=None, show_settled_agreements=None, get_details=False, index_variation_behavior=None, index_ids=None, only_calculated=None, account_ids=None)
    Retrieve fixed income agreement's data.
    bond_ids: [int] or None
    fund_ids: [int] or None
    broker_ids: [int] or None
    issuer_ids: [int] or None
    instrument_ids: [int] or None
    start_date: date or None
    end_date: date or None
    date_type: FILTER_DATE_TYPES (int) or None
    show_settled_agreements: bool or None # default False
    get_details: bool or None # default False
    account_ids: [int] or None

    returns:    {'provisions': [provision], 'quantities': [quantity], 'values': [prices], 'start_date': date,
              'settlement_date': date, 'issue_date': date, 'face_value': decimal, 'index_id': int,
              'index_name': string, 'issuer_id': int, 'issuer_name': string, 'fund_id': int,
              'fund_name': string, 'index_relative_return_rate': decimal, 'fixed_return_rate': decimal,
              'id': int, 'strategy_id': int, 'strategy_name': string, 'market_id': int,
              'market_name': string, 'account_id': int, 'payment_account_id': int,
              'account_name': string, 'payment_account_name': string, 'broker_id': int,
              'broker_name': string, 'penalty_fee': decimal, 'other_fees_financial': decimal,
              'other_fees_percent': decimal, 'principal_lockup_months': int,
              'rate_lockup_months': int, 'compound_only_after_lockup': boolean,
              'only_business_days': boolean, 'payment_frequency': int (CHOICES),
              'payment_frequency_display': string, 'risk_rating': int (CHOICES),
              'risk_rating_display': string, 'auto_pricing': bool,
              'bond_instrument_id': int, 'bond_instrument_name': string,
              'agreement_code': string, 'bond_type_id': int, 'bond_type_name': string,
              'price_divisor': decimal}
get_bond_prices(bond_ids=None, date=None)
add_agreement_quantities(agreement_qtys)
import_bond_agreement_payments_from_xls(files)
    Imports a XLS file with bond agreement payments.
calc_date_price(bonds_dict, date)
unsettle_bond_agreements(bond_settlements)
    Unsettles BondAgreement's

    bond_settlements: {agreement_id: int, date: date}
    returns {success: bool}
add_bond_agreement_provision(provision_by_id)
get_content_type_for_bond()
    Returns the content type ID for the Bond model.

    returns: {'id': int}
add_bonds(bonds_dict)
get_bond_type_by_pricing_type()
    Returns bond type id (int) by its pricing type.
settle_bond_agreements(settlements_by_id)
    Settles BondAgreements given a settlement date and a settlement value
    settlements_by_id: {bond_id: {'date': date, 'price': decimal, 'quantity': decimal or None, 'accrued_interest': decimal (optional)}}
    returns {'success': bool}
before_snapshot_generation(date, fund_ids, **kwargs)
add_agreement_prices(agreement_prices)
    Adds BondAgreement's prices
    agreement_prices: [ap]
        ap: {'date': date, 'value': Decimal, 'agreement_id': int, 'price_source': int, 'accrued_interest': Decimal,
        'yield_value': Decimal or None}
    returns: {success: bool}
get_details_for_portfolio(date, instrument_ids)
    Returns the portfolio column names and values that are specific to this module. The group
    name is hard-coded and is returned on the first level of the output.

    'date': date
    'instrument_id_list': [int]

    returns: {'group_display_name': string, 'columns': [columns], 'extra_data': {extra_data},
              'tooltips': {tooltips}, 'buttons': {buttons}}
    column: {'display_name': string, 'format': formats, 'column_identifier': string}
    extra_data: {'column_identifier': any, ...} # 'any' means it depends on the column
    tooltips: {'column_identifier': string, ...}
    buttons: {'column_identifier': URL, ...}
add_bond_type(bond_type_dict)
get_bond_types(ids=None, names=None)
    Returns data on BondType's

    ids: [int]

    returns: {id : {id: int, name: string, auto_pricing: bool, is_governmental: Boolean}}
get_bonds_by_index(index_ids, date, only_calculated=False)
delete_bond_values(ids)
    Deletes bond values
    ids: [int]

    returns {'success': bool}
get_bond_type_by_selic_code()
    Returns bond type id (int) by its selic code, when present.
import_bond_agreements_from_xls(files)
    Imports a XLS file with bond agreements.
get_all_bond_prices(bond_ids, dates=None)
generate_bonds_curve(bonds_dict, is_simulation=False, calculate_operation_values=True)
get_all_bond_quantities(bond_ids=None)
recalculate_bond_prices(bond_ids, date, simulation_data=None, calculate_operation_values=True)
    Recalculates bond curves starting from the specified date, could be used as simulation or not

    bond_ids: [int]
    date: date
    is_simulation: bool
    simulation_data: {bond_id: {'value': decimal, 'type': BOND_AGREEMENT_SIMULATION_TYPES}}
get_or_calc_prices(bond_ids, date, agreements_data=None, no_calculate=False, recalculate_internal=False)
    Gets bond agreement prices on given date or calculate them if they doesnt exist

    bond_ids: [int]
    date: date
    agreements_data: check get_bond_agreements_data return
    no_calculate: bool
get_bonds_info(ids=None, maturity_date_from=None, maturity_date_to=None, partial_symbols=None, type_ids=None, only_active=True, uses_agreement=None, include_payment_events=False)
    Obtains basic bond information filtered by ID.
    Returns only active instruments, except if ids are provided.
    partial_symbols allows to filter by symbol like '%partial_symbol%'

    ids: [int] or None
    maturity_date_from: date or None
    maturity_date_to: date or None
    type_ids: [int] or None
    only_active: bool  # default: True

    Returns: {instrument_id (int): bond}
        bond: {'id': int, 'symbol': str, 'maturity_date': datetime, 'type_name': string, 'type_id': int,
                'is_governmental': bool, 'liquidity_days': int or None, 'cetip_code': str or None}
update_agreement_codes(code_by_agreement_id)
    Updates BondAgreement's codes
    code_by_agreement_id: {id: code (string)}
    returns: {success: bool}
Module compliance (Compliance)
get_rules(is_active=None, ids=None)
    Returns all existing rules.

    is_active: bool or None

    returns: {rule_id (int): rule}
        rule: {'id': int, 'name': str}
get_compliance_status(fund_ids=None, is_solved=None, is_open=None, rule_templates=None, rule_sources=None, date=None)
    Returns compliance status grouped by funds.
    Optinal filters are available

    fund_ids: [int] or None
    is_solved: bool or None
    is_open: bool or None
    rule_templates: [COMPLIANCE_RULE_TEMPLATES (int)]
    rule_sources: [COMPLIANCE_RULE_SOURCES (int)]

    returns: [fund_noncompliance_event]
        fund_noncompliance_event: {'fund_id': int, 'fund_name': string, 'events': [noncompliance_event]}
            noncompliance_event: {'rule_id': int, 'rule_name': string, 'started_on': datetime, 'ended_on': datetime,
                'status': int, 'status_name': string, 'description': string, 'is_warning': bool}
get_compliance_suggestion_limits(template, funds, params, instrument_id, side, average_price)
    Proxy method that calls the apropriated suggestion rule method according to the 'template' param.
    Suggestion rules are on compliance.rule_validations module.
before_snapshot_generation(date, fund_ids, **kwargs)
get_compliance_errors(template, funds, params, skip_non_forced_errors)
    Proxy method that calls the apropriated validation rule method according to the 'template' param.
    Validation rules are on compliance.rule_validations module.
get_compliance_attributes(template)
    Get specific template rule params
get_compliance_status_for_display(fund_compliance_status, status_for_display=None, ignore_funds_with_no_events=False, email_display=False)
    Returns the compliance events grouped by 'fund' first, then aggregating errors, warnings and solved events in
    different arrays. It also includes a 'display_class' key foreach fund. The value of display_class is a choice from
    EVENT_DISPLAY_CLASSES to display in frontend.
    It's possible to return only funds with display_class of the status_for_display argument.
    The 'ignore_funds_with_no_events' arg tells if funds with no compliance events at all should be returned or not.

    fund_compliance_status: [compliance_status]
        compliance_status: {'fund_id': int, 'fund_name': string, 'events': [compliance_event]}
            compliance_event: {'status': int, 'is_warning': bool,
                'rule_id': int, 'rule_name': string, 'started_on': datetime, 'ended_on': datetime,
                'status_name': string, 'description': string}
            #NOTE: Only 'status' and 'is_warning' key are mandatory for compliance_event. The method will return only
                    the keys present in the compliance_event dict.
    status_for_display: EVENT_DISPLAY_CLASSES (string) or None
    include_funds_with_no_events: bool  # default: False

    returns: [fund_compliance_status]
        fund_compliance_status: {'fund_id': int', 'fund_name': string, 'warnings': [event], 'errors': [event],
                                 'solved': [event], 'display_class': EVENT_DISPLAY_CLASSES (string)}
            event: {'rule_id': int, 'rule_name': string, 'started_on': datetime, 'ended_on': datetime,
                    'status': int, 'status_name': string, 'description': string, 'is_warning': bool,
                    'modified_on': datetime}
filter_compliance_rules_by_moment(compliance_rules, moment=None)
get_compliance_rules_by_fund(fund_ids=None, date=None, moment=None, rule_ids=None, templates=None, sources=None, skip_templates=None, include_funds_to_get_portfolio=False, order_pre_allocation_test=None, rule_types=None, sensitive_only=False, only_get_suggestion_limits=False)
    Returns all applicable compliance rules for the given funds except for the skip_templates rules.
    Optionally, only rules from the template param can be returned if the param is passed.

    fund_ids: [int] or None
    funds_administrator_info: calls.sync.funds.get_fund_administrator_data() return
    simulated_fund_orders: [fund_order] or None
        fund_order: {'fund_id': int, 'instrument_id': int, 'strategy_id': int, 'side': ORDER_SIDES,
                     'quantity': Decimal,  'price': Decimal}
    date: date or None
    moment: COMPLIANCE_RULE_MOMENTS (int) or None
    rule_ids: [int] or None
    templates: [COMPLIANCE_RULE_TEMPLATES (int)] or None
    sources: [COMPLIANCE_RULE_SOURCES (int)] or None
    skip_templates: [COMPLIANCE_RULE_TEMPLATES (int)] or None
    get_portfolio: bool or None # default Fasle
    order_pre_allocation_test: bool
    rule_types: [COMPLIANCE_RULE_TYPES (int)] or None
    sensitive_only: bool

    returns: if get_portfolio: {'compliance_rules': [compliance_rule], 'portfolios': portfolio}
            else [compliance_rule]
        compliance_rule: {'compliance_rule_id': int, 'rule_name': string, 'template': string, 'type': int, 'params': JSON,
                          'applicable_funds': [cr_fund],'periods': [object]}
            cr_fund: {'fund_id': int, 'fund_name': string, 'is_warning': bool}
        portfolios: see calls.sync.portfolio.get_portfolio_assets()
add_or_update_compliance_status_update(snapshot_date, event_id, status, _type, description, reasoning=None)
    Adds a new ComplianceStatusUpdate.

    snapshot_date: date
    event_id: int
    status: EVENT_STATUS (int)
    _type: UPDATE_TYPES (int)
    description: string
    reason: string or None

    returns: {'success': bool}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_compliance_status_update(date, fund_ids=None, rule_ids=None, templates=None, sources=None)
    Returns ComplianceStatusUpdate matching the provided filters.

    returns: fund_compliance_status: [compliance_status]
        compliance_status: {'fund_id': int, 'fund_name': string, 'events': [compliance_event]}
            compliance_event: {'status': int, 'is_warning': bool,
                'rule_id': int, 'rule_name': string, 'started_on': datetime, 'ended_on': datetime, 'modified_on': datetime,
                'status_name': string, 'description': string}
update_compliance_rules_limit_value(rules)
    rules: [rule]
        rule: {'id': int, 'limit_value': Decimal})
sensitive_rule_exists()
    Informs whether there are any compliance rules marked as 'sensitive' and active.

    returns: {'exists': bool}
add_compliance_rules(rules)
    rules: [rule]
        rule: {'rule_name': str, 'template': COMPLIANCE_RULE_TEMPLATES (int),
                'params': {}, # attributes depending on rule template
                'source': COMPLIANCE_RULE_SOURCES (int),
                'always_show_in_portfolio': bool,
                'check_all_active_funds_together': bool or None 'is_blocking': bool or None
                'applicable_funds': [{'fund_id': int, 'is_warning': bool}]}

    returns: default success dict + {'ids': [int]}
check_compliance(fund_ids, fund_orders=None, skip_non_forced_errors=None, skip_templates=[], date=None, moment=None, order_pre_allocation_test=None, rules=None, sensitive_only=False, open_orders_not_get=[], rule_ids=None)
    Performs a compliance check for the listed funds.

    fund_ids: [fund_id (int)]
    fund_orders: [fund_order] or None
        fund_order: {'instrument_id': int, 'quantity': Decimal, 'side': ORDER_SIDES, 'price': Decimal,
                    'fund_id': int or None, 'strategy_id': int or None, 'execution_date': date,
                    'existing_order': bool, 'account_id': int or None, 'operation_type': OPERATION_TYPES or None}
    skip_non_forced_errors: bool or None  # default: False
    skip_templates: [COMPLIANCE_RULE_TEMPLATES (int)] or None
    date: date or None  # default: today
    moment: COMPLIANCE_RULE_MOMENTS (int) or None
    order_pre_allocation_test: bool or None  # default: False
    sensitive_only: bool  # default: False

    If a 'fund_orders' list is passed, the checks are performed using a simulated portfolio with the effects
    of the given orders. Optionally, the check can skip compliance errors that were not caused by the orders
    (e.g. skip pre-existing errors related to non-traded instruments).
    If the moment is not specified, rules will be checked disregarding their "moment" parameters.
    Optionally, the check can skip certain rule templates if 'skip_templates' is passed.

    returns: {'is_valid': boolean, 'funds': [fund], 'is_blocking': boolean}
        fund: {'fund_id': int, 'fund_name': string, 'snapshot_date': date, 'snapshot_status': SNAPSHOT_STATUS (int),
               'rules': [compliance_rule]}
            compliance_rule: {'is_compliant': bool, 'rule_id': int, 'rule_name': string, 'instruments': [id (int)],
                              'orders_affecting': [id (int)], 'messages': [string], 'is_warning': boolean}
get_compliance_errors_for_display(compliance_errors)
    Returns the compliance errors grouped by 'is_warning' (warning or error), then grouped by funds.

    # OLD
    compliance_errors: {'is_valid': boolean, 'funds': {fund_id (int): {'fund_name': string, 'errors': [compliance_error]} }}
        compliance_error: {'instruments': [id (int)], 'rule_name': string, 'messages': [string], 'is_warning': boolean}

    # NEW
    compliance_errors: {'is_valid': boolean, 'funds': [fund]}
        fund: {'fund_id': int, 'fund_name': string, 'snapshot_date': date, 'rules': [compliance_rule]}
            compliance_rule: {'is_compliant': bool, 'rule_id': int, 'rule_name': string, 'instruments': [id (int)],
                              'messages': [string], 'is_warning': boolean}

    returns: {'warnings': [compliance_error_display], 'errors': [compliance_error_display], 'is_valid': bool, 'is_blocking': bool}
        compliance_error_display: {'fund_name': string, 'rule_messages': [rule_message]}
            rule_message: {'rule_name': string, 'messages': [string]}
get_rules_valid_at_date(fund_id, date, template)
    Returns the IDs of rules of a specific template which are valid for a specific fund at a specific date.

    fund_id: int
    date: date
    template: COMPLIANCE_RULE_TEMPLATES (int)

    returns: {'rule_ids': [int]}
get_compliance_rules_info(fund_ids, ids=None)
    Returns all applicable compliance rules for the given funds.
    Optionally, rule ids may be provided as a filter.

    fund_ids: [int]
    ids: [int] or None

    returns: {'compliance_rule_id': compliance_rule}
        compliance_rule: {'compliance_rule_id': int, 'rule_name': string, 'template': string, 'params': JSON,
                          'applicable_funds': [cr_fund]}
            cr_fund: {'fund_id': int, 'fund_name': string, 'is_warning': bool}
get_suggestion_limits(fund_ids, date, instrument_id, side, average_price, simulated_orders=None, portfolio_assets_by_fund=None)
    Proxy method that calls the apropriated validation rule method according to the 'template' param, and calls its
    get_suggestion_limits method to obtain maximum and minimum allocation values for each fund.
    Validation rules are on compliance.rule_validations module.

    Only rules marked with 'use_for_allocation_suggestion' are used.

    The parameter portfolio_assets_by_fund was added for performance improvements. It contains the portfolio assets indexed by fund_id.

    fund_ids:[int]
    date: date
    instrument_id: int
    side: EXECUTION_SIDES (int)
    average_price: decimal

    returns: {fund_id (int): fund_result}
            fund_result: {'min_allocation_quantity': decimal or None, 'max_allocation_quantity': decimal or None,
                          'min_allocation_rule_id': int or None, 'max_allocation_rule_id': int or None,
                          'min_allocation_rule_name': string or None, 'max_allocation_rule_name': string or None}
update_rule_set(fund_id, data, rule, param_name)
    Add, update or remove rule sets
    Add: if there is not a rule set about that fund
    Update: if there is a rule set about that fund
    Delete: if there is a rule set about that fund and it's not in the form

    fund_id: int # original fund id
    data: { id (int) : { 'params': dict, 'rule_name': str}}
    rule: int
    param_name: str # key used to get the rule id

    No return
Module corporate_actions (Proventos)
get_corporate_action_info(ids=None, instrument_ids=None, start_date=None, end_date=None, corporate_action_type=None, is_active=None, origin_ids=None, origin_content_type_id=None)
    Retrieves corporate action information. Accepts optional filters.

    'instrument_ids': [int] or None
    'start_date': date or None
    'end_date': date or None
    'corporate_action_type': CORPORATE_ACTION_TYPES
    'is_active': bool or None  # None does not filter; True skips excluded items; False returns only excluded ones
    'origin_ids': [int]
    'origin_content_type_id': [int] or None


    returns: {'corporate_actions': [corporate_action]}
        corporate_action:{'corporate_action_id': int, 'corporate_action_type': CORPORATE_ACTION_TYPES,
                          'instrument':instrument, 'value': decimal, 'ex_date': date, 'impact_date': date,
                          'is_processed': boolean, 'is_excluded': boolean, 'settlement_date': date, 'payment_type': CORPORATE_PAYMENT_TYPES or None,
                          'received_instrument': instrument, 'gross_value_per_unit': decimal or None, 'is_automatic_payment': boolean or None,
                          'issued_instrument': int or None, 'rights_instrument': int or None, 'conversion_factor': Decimal or None,
                          'strike_price': Decimal or None, 'strike_limit_date': date or None, 'taxes': {fund_country_id : tax} or None}
                          fund_country_id: int
                          tax: { 'country_id': int, 'country_name': string, 'tax_percent': decimal},
                          origin_id: Int,
                          origin_content_type: Int
                }
        Note that the value depends on action type. Returns the gross_value_per_unit for corp. payments, or the conversion_factor for other types.
add_corporate_payments(corporate_payments, dont_set_dirty_snapshot=False)
    Inserts new corporate payments.
    If taxes are not provided (taxes=None) apply taxes according to parametrized rules by payment type.

    'corporate_payments': [item]
        item: {'instrument_id': int, 'ex_date': date, 'impact_date': date or None, 'is_update': bool or None,
               'settlement_date': date or None, 'gross_value_per_unit': decimal, 'factor': decimal or None,
               'payment_type': CORPORATE_PAYMENT_TYPES (int), 'currency_id': int or None,
               'is_automatic_payment': boolean, 'taxes': {country_id (int): tax(decimal)} or None,
               'prod_seq_num': int or None, 'legacy_identifier': str or None, 'is_processed': bool or None,
               'dont_update_historical_prices': bool or None, 'origin_id': int or None,
               'origin_content_type_id': int or None}

    returns: default success dictionary
get_fund_corporate_actions(ca_ids=None, fund_ids=None)
    ca_ids: [int] or None
    fund_ids: [int] or None

    return:
        {fca_id(int): 'fund_id': int, 'corporate_action_id': int, 'quantity': decimal}
update_splits(splits, dont_set_dirty_snapshot=False)
    Updates existing splits.
    Any impact is only valid after snapshot generation.

    'splits': [split]
        split: {'instrument_id': int, 'ex_date': date, 'impact_date': date, 'factor': decimal or None,
                    'conversion_factor': decimal, 'prod_seq_num': int or None}

    returns: default success dictionary
get_corporate_actions_for_attribution(ex_date, instrument_ids=None, is_legacy=None)
    Retrieves all corporate actions in the selected ex-date than can influence attribution: corporate payments
    and bonus issues. In the case of corporate actions, no factor is returned; instead, a total value (per unit) is
    returned for each country.

    The optional parameter "is_legacy" must be true if migrated portfolios are having attribution calculated.

    instrument_ids: [int] or None
    fund_country_id: int
    ex_date: date

    returns: {instrument_id(int): 'factor': Decimal, 'values_by_country': values_by_country or {}} or {}
        values_by_country: {country_id (int): value_per_unit (int)}
update_prices_historical_series(date, instrument_ids=None, corp_action_ids=None, deleted_corp_action_ids=None, skip_corp_action_ids=None)
    Updates the historical series of prices of instruments which become 'EX' by the given date.

    The parameter 'deleted_corp_action_ids' holds a list of ids to exclude from processing, resulting
    in a factor which does not take these corporate actions into account, reverting its effect in case
    it was processed earlier.

    'date': date
    'instrument_ids': [int] or None
    'corp_action_ids': [int] or None
    'deleted_corp_action_ids': [int] or None
    'skip_corp_action_ids': [int] or None

    returns: default success dictionary + {'log': string}
before_snapshot_generation(date, fund_ids, payments_only=False, **kwargs)
    Calculates provisions related to corporate actions whose impact dates are the same as 'date', for the given funds.

    'date': date
    'fund_ids': [int]
    'payments_only': bool
update_bonus_issues(bonus_issues, dont_set_dirty_snapshot=False)
    Updates existing bonus issues.
    Any impact is only valid after snapshot generation.

    'bonus_issues': [bonus_issue]
        bonus_issue: {'corporate_action_id': int or None, 'instrument_id': int, 'ex_date': date, 'impact_date': date,
                      'factor': decimal or None, 'issued_instrument_id': int,
                      'conversion_factor': decimal, 'prod_seq_num': int or None}

    returns: default success dictionary
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
update_subscription_rights(subscription_rights, dont_set_dirty_snapshot=False)
    Updates existing subscription rights.
    Any impact is only valid after snapshot generation.

    'subscription_rights': [subscription_right]
        subscription_right: {'instrument_id': int, 'ex_date': date, 'impact_date': date,
                             'factor': decimal or None, 'rights_instrument_id': int,
                             'strike_price': decimal, 'strike_limit_date': date, 'conversion_factor': decimal,
                             'prod_seq_num': int or None}

    returns: default success dictionary
check_duplicates(corporate_actions)
    Checks whether a group of corporate_actions already exist and returns those that don't

    corporate_actions: [corporate_action]
        corporate_action: {instrument_id: int, action_type: int, factor: float, ex_date: Date, impact_date: Date,
                            morningstar_event_id: int or None}

    returns: {'success': bool, 'messages': [str], 'non_duplicates': [corporate_action]
        corporate_action: {instrument_id: int, action_type: int, factor: float, ex_date: Date, impact_date: Date,
                            morningstar_event_id: int or None}
get_corporate_payment_tax_rules(payment_type=None, instrument_country_id=None, fund_country_id=None, tax_type=None)
    payment_type: CORPORATE_PAYMENT_TYPES or None
    instrument_country_id: int or None
    fund_country_id: int or None
    tax_type = CORPORATE_PAYMENT_TAX_TYPES or None

    returns: {rule_id (int): corporate_payment_rule}
    corporate_payment_rule = {'id': int, 'type': CORPORATE_PAYMENT_TYPES, 'instrument_country_id': int,
                              'fund_country_id': int, 'tax_type' = CORPORATE_PAYMENT_TAX_TYPES, 'tax_percent': decimal}
get_content_type_for_corporate_actions()
    Returns the content type ID for provisions associated with a CA.

    returns: {'id': int}
update_corporate_payments(corporate_payments, update_settlement_date_only=False, dont_set_dirty_snapshot=False)
    Updates existing corporate payments.
    Any impact is only valid after snapshot generation.

    'corporate_payments': [corporate_payment]
        corporate_payment: {'corporate_action_id': int, 'instrument_id': int, 'ex_date': date, 'impact_date': date,
                            'factor': decimal or None, 'gross_value_per_unit': decimal,
                            'payment_type': CORPORATE_PAYMENT_TYPES (int), 'settlement_date': date,
                            'is_automatic_payment': boolean, 'prod_seq_num': int or None, 'taxes': [country_tax]}
            country_trax: {'id': int, 'tax': decimal}

    returns: default success dictionary
get_corporate_action_id(instrument_id, impact_date, action_type, prod_seq_num)
    Retrives an existing corporate action.

    instrument_id: int
    impact_date: date
    action_type: CORPORATE_ACTION_TYPES
    prod_seq_num: int
    returns: default success dictionary and corporate action id (if found)
add_bonus_issues(bonus_issues, dont_set_dirty_snapshot=False)
    Inserts new bonus issues.

    'bonus_issues': [item]
        item: {'instrument_id': int, 'ex_date': date, 'impact_date': date or None, 'is_update': bool or None,
               'conversion_factor': decimal, 'factor': decimal or None, 'issued_instrument_id': int,
               'prod_seq_num': int or None, 'legacy_identifier': str or None, 'is_processed': bool or None,
               'dont_update_historical_prices': bool or None, 'origin_id': int or None,
               'origin_content_type_id': int or None}}

    returns: default success dictionary
import_corporate_actions_xls(filename, contents, update_historical_prices=True)
    Imports and processes a file in a generic format containing corporate actions.

    'filename': string
    'contents': string
    'update_historical_prices': bool or None # default True

    If 'update_historical_prices' is False, don't update price's corporate_action_factor.

    returns: default success dictionary
             + {'file_id': int, 'date': date or None, 'missing_instruments': [string],}
add_splits(splits, dont_set_dirty_snapshot=False)
    Inserts new split/inplit.

    'splits': [item]
        item: {'instrument_id': int, 'ex_date': date, 'impact_date': date or None, 'is_update': bool or None,
               'conversion_factor': decimal, 'factor': decimal or None,
               'prod_seq_num': int or None, 'legacy_identifier': str or None, 'is_processed': bool or None,
               'dont_update_historical_prices': bool or None, 'origin_id': int or None,
               'origin_content_type_id': int or None}}

    returns: default success dictionary
check_for_affected_realeased_portfolios(corporate_actions)
    corporate_actions: [corporate_action]
        corporate_action: {'instrument_id': int, 'impact_date': date, 'ex_date': date}

    return: {'has_affected_portfolios': bool, 'msg': str}
del_corporate_action(corporate_action_ids, soft_del=True, dont_update_historical_prices=False, dont_set_dirty_snapshot=False)
    Marks an existing corporate action as excluded.
    If soft_del is False, than really deletes it from database.

    Any impact is only valid after snapshot generation.

    corporate_action_ids: [int]
    soft_del: bool
    dont_update_historical_prices: bool

    returns: default success dictionary
get_content_type_for_fund_corporate_actions()
    Returns the content type ID for provisions associated with a CA.

    returns: {'id': int}
update_corporate_action_provisions(new_settlement_dates)
    Updates provisions generated by corporate payments, changing their settlement_dates.

    new_settlement_dates: {cpid (int): settlement_date}

    returns: {'success': boolean}
add_subscription_rights(subscription_rights, dont_set_dirty_snapshot=False)
    Inserts new subscription rights.

    'subscription_rights': [item]
        item: {'instrument_id': int, 'ex_date': date, 'impact_date': date or None,  'is_update': bool or None,
               'conversion_factor': decimal, 'factor': decimal or None, 'rights_instrument_id': int,
               'strike_price': decimal, 'strike_limit_date': date,
               'prod_seq_num': int or None, 'legacy_identifier': str or None, 'is_processed': bool or None,
               'dont_update_historical_prices': bool or None, 'origin_id': int or None,
               'origin_content_type_id': int or None}

    returns: default success dictionary
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
Module currencies (Moedas)
get_exchange_source_info(ids=None, currency_from=None, currency_to=None)
    Gets the exchange source data by id.

    'id': id

    returns: {id (int): {'name': str, 'currency_from': int, 'currency_to': int,
                        'is_default': bool, 'is_active': bool, 'is_monitoring_enabled': bool,
                        'bloomberg_ticker': str, 'bloomberg_formula': BLOOMBERG_FORMULAS,
                        'monitoring_start_time': datetime, 'monitoring_end_time': datetime,
                        'yahoo_ticker': str}
get_exchange_rates_for_attribution(fund_id, currency_from_id, start_date, end_date, source_ids=None, fund_currency_id=None)
    Returns a dictionary by date with its respective rate. The rate is always considering currency_to = fund_currency_id

    returns: {date: rate (Decimal)} or {}
get_exchange_sources_for_bloomberg_price_monitoring(check_time=True)
    Gets a list of exchange sources that should have their prices monitored by Bloomberg,
    along with all data required to subscribe to their market data via the Bloomberg API.

    returns: {'sources': [source]}
        source: {'id': int, 'ticker': string, 'formula': string}
get_exchange_source_by_bloomberg_ticker(ticker)
    Gets the exchange source ID related to a bloomberg ticker.

    'ticker': str

    returns: {'success': bool, 'error_msg': string or None, 'id': int or None}
add_exchange_rates(rates, date=None)
    Gets a list of exchange rates and creates or updates an existing rate for the same date
    and Exchange Source.

    'rates': [rate]
        rate: {'source_id': int, 'new_rate': decimal}
    'date': date or None  # default: today

    returns: default success dictionary
get_exchange_sources_for_morningstar_price_monitoring(check_time=True)
    Gets a list of exchange sources that should have their prices monitored by Morningstar,
    along with all data required to subscribe to their market data via the Morningstar API.

    returns: {'id': exchange_source}
        exchange_source: {'id': int, 'name': str, 'morningstar_ticker': str, 'morningstar_market_code': str}
get_instrument_by_currency(currency_ids=None, ids=None)
    Retrieves the instrument_id for each currency. Accepts optional filters.

    currency_ids: [int] or None

    returns: {currency_id (int): instrument_id (int)}
get_exchange_rate(currency_from_id, currency_to_id, date, preferred_source_ids=None, fund_id=None, not_fund_related=False, accept_indirect=True)
    Retrieves the exchange rate for the given currency pair at the given date, or the closest date available.
    If no rate is found, or if both currencies are the same, returns 1 as the rate
    (a resulting source_id=None indicates there is no originating data).

    currency_from_id: int
    currency_to_id: int
    date: date
    preferred_source_ids: [int] or None
    fund_id: int or None
    not_fund_related: bool
    accept_indirect: bool  # default: True

    Indicating the preferred FX sources is very important to avoid currency conversion errors.
    This can be done by passing either preferred_source_ids or fund_id. If both are passed, the latter is ignored.
    In the rare cases where FX conversion is being done without regard to any fund (e.g. converting an instrument's
    price in the Prices screen), pass not_fund_related=True to make it explicit that no fund source preferences should
    be used. If this is not done, and both preferred_source_ids and fund_id are None, an exception will be raised.
    However, think twice before using it, because those cases are really rare (for instance, converting an instrument's
    price in a report is usually done with regard to a fund).

    Uses caching to avoid extra queries (so this API is safe to call in a loop).

    returns: {'rate': decimal, 'source_id': int or None, 'actual_date': date, 'modified_on': datetime or None,
              'is_reversed': boolean, 'is_indirect': boolean or missing,
              'indirect_conversions': [indirect_conversion] or missing}
        indirect_conversion: {'rate': decimal, 'source_id': int, 'actual_date': date, 'is_reversed': boolean}

    'is_reversed' indicates whether the stored exchange rate's currency_from and currency_to are reversed
     relative to the input parameters. In either case, the returned value is already appropriate to be used
     for the given from/to pair (i.e. this API already inverts the stored rate, so the caller does not have to do it).

    'is_indirect' indicates whether an indirect conversion was done (using the reference currency).
    For indirect conversions, 'is_reversed' is True if either conversion used reverse information, and
    'actual_date' indicates the oldest date of the conversions.

    Precedence details:
    - a closer-date conversion has higher precedence than any older-date conversion (regardless of source/indirection)
    - a direct conversion has higher precedence than a same-date indirect conversion (regardless of source)
    - source precedence is: preferred sources > default sources > other sources
get_currencies_by_acronym(acronyms=None)
    Retrieves the currency id corresponds to each input acronym.

    acronyms: [string] or None

    returns: {acronym (str): currency_id (int)}
get_currency_by_instrument(instrument_ids=None)
    Retrieves the currency_id for each instrument.

    instrument_ids: [int] or None

    returns: {instrument_id (int): currency_id (int)}

    If a supplied instrument is not a currency, it is not returned in the dictionary.
get_simple_exchange_rates(start_date=None, end_date=None, source_ids=None, currency_from_ids=None, currency_to_ids=None, get_names=False, show_month_last_price=False)
    Returns matching exchange rates.

    This API does not contain any of the intelligence present in get_exchange_rate(),
    such as performing indirect conversion.

    At least one of the date, source or currency parameters must be supplied, or an exception will be raised.

    start_date: date or None
    end_date: date or None
    source_ids: [int] or None
    currency_from_ids: [int] or None
    currency_to_ids: [int] or None
    get_names: bool  # default: False
    show_month_last_price: bool # default: False (show only last price for each month)

    returns: {'rates': [rate]}
        rate: {'id': int, 'source_id': int, 'source_name': str or missing, 'date': date, 'value': Decimal,
               'currency_from_id': int, 'currency_from_name': str or missing, 'modified_on': datetime,
               'currency_to_id': int, 'currency_to_name': str or missing}
get_exchange_sources_for_yahoo_price_monitoring(check_time=True)
    Gets a list of exchange sources that should have their prices monitored by Yahoo,
    along with all data required to subscribe to their market data via the Yahoo API.

    returns: {'id': exchange_source}
        exchange_source: {'id': int, 'name': str, 'morningstar_ticker': str, 'morningstar_market_code': str}
get_preset_currencies()
    Returns currencies which are commonly used in hard-coded way.

    returns: {'brl': currency or None, 'usd': currency or None, 'reference': currency or None, 'ptax_source': int or None}
        currency: {'id': int, 'name': string, 'name_plural': string, 'prefix': string, 'acronym': string}
get_n_last_rates(currency_rates, n, start_date, preferred_source_ids=[])
    Gets n last currency rates
    currency_rates: {'currency_to': int, 'currency_from': int}
    n: int
    start_date: date
    preferred_source_ids: [int]
get_exchange_rates_multiple_dates(currency_from_id, currency_to_id, start_date, end_date, preferred_source_ids=None, fund_id=None, not_fund_related=False, accept_indirect=True)
    Retrieves the exchange rate for the given currency pair for all dates in between start_date and end_date.
    For dates without an exchange rate, we return the rate of the closest date available.
    If no rate is found, or if both currencies are the same, returns 1 as the rate
    (a resulting source_id=None indicates there is no originating data).

    currency_from_id: int
    currency_to_id: int
    start_date: date
    end_date: date
    preferred_source_ids: [int] or None
    fund_id: int or None
    not_fund_related: bool
    accept_indirect: bool  # default: True

    Indicating the preferred FX sources is very important to avoid currency conversion errors.
    This can be done by passing either preferred_source_ids or fund_id. If both are passed, the latter is ignored.
    In the rare cases where FX conversion is being done without regard to any fund (e.g. converting an instrument's
    price in the Prices screen), pass not_fund_related=True to make it explicit that no fund source preferences should
    be used. If this is not done, and both preferred_source_ids and fund_id are None, an exception will be raised.
    However, think twice before using it, because those cases are really rare (for instance, converting an instrument's
    price in a report is usually done with regard to a fund).

    Uses caching to avoid extra queries (so this API is safe to call in a loop).

    returns: {'rate': decimal, 'source_id': int or None, 'actual_date': date, 'modified_on': datetime or None,
              'is_reversed': boolean, 'is_indirect': boolean or missing,
              'indirect_conversions': [indirect_conversion] or missing}
        indirect_conversion: {'rate': decimal, 'source_id': int, 'actual_date': date, 'is_reversed': boolean}

    'is_reversed' indicates whether the stored exchange rate's currency_from and currency_to are reversed
     relative to the input parameters. In either case, the returned value is already appropriate to be used
     for the given from/to pair (i.e. this API already inverts the stored rate, so the caller does not have to do it).

    'is_indirect' indicates whether an indirect conversion was done (using the reference currency).
    For indirect conversions, 'is_reversed' is True if either conversion used reverse information, and
    'actual_date' indicates the oldest date of the conversions.

    Precedence details:
    - a closer-date conversion has higher precedence than any older-date conversion (regardless of source/indirection)
    - a direct conversion has higher precedence than a same-date indirect conversion (regardless of source)
    - source precedence is: preferred sources > default sources > other sources
get_currency_data(ids=None, is_reference=None)
    Retrieves information for currencies. If a list of IDs is not specified, all currencies are returned.
    Allows optional filtering by a list of currency IDs.

    is_active: bool or None
    ids: [int] or None
    is_reference: bool or None

    returns: {'id' (int): currency}
        currency: {'id': int, 'name': string, 'name_plural': string, 'prefix': string, 'acronym': string, 'is_reference': bool}
get_currency_by_acronym(acronym)
    Retrieves the currency id which corresponds to the input acronym.

    acronym: string

    returns: id (int) or None
Module depositary_receipts (DRs)
add_dr_instruments(dr_instruments)
    Inserts new dr instruments.

    'dr_instruments': [dr_instrument]
        dr_instrument: {'name': str, 'symbol': str, 'market_id': int, 'isin_code': str, 'issuer_id': int
                        'price_divisor': int or None, 'is_monitoring_enabled': boolean or None,
                        'bloomberg_pricing_source': str or None, 'bloomberg_ticker': str or None,
                        'underlying_instrument_id': int, 'underlying_factor': decima or Nonel, 'settlement_days': int or None}
    returns: default success dictionary
before_snapshot_generation(date, fund_ids, **kwargs)
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_underlying_instrument(ids=None)
    Returns the underlying instrument for the provided ids.

    ids: [int]

    returns: {instrument_id (int): underlying_instrument_id (int)}
recalculate_prices(date)
    Recalculates prices for the given date, for all DR's contained in any fund's portfolio.
calculate_depositary_receipts_prices(instrument_ids=None, fund_ids=None, date=None)
    Calculates DR prices for long futures.

    instrument_ids: [int] or None
    date: date or None

    Returns: {instrument_id (int): {'success': bool, 'error_message': string}}
get_depositary_receipts_info(ids=None, underlying_instrument_ids=None)
    Returns instruments info

    ids: [int]

    returns: {instrument_id (int): {'underlying_instrument_id': int, 'BDR_level': BDR_LEVELS, 'id': int}}
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
update_dr_instrument(dr_instrument)
    Updates existing dr instruments.

    'dr_instrument':  {'id': (int), 'BDR_level': BDR_LEVELS}

    returns: default success dictionary
Module execution (Execuo)
get_allocated_order_suggestion(rule_id, instrument_id, date, side=None, total_quantity=None, price=None, basket_id=None, order_ids=None)
    Returns allocation suggestions based on the allocation rule provided.

    If allocation rule method is equal to ALLOCATION_METHODS.equalize_to_group_exposure,
    quantity and side parameters are not mandatory.

    In case of edition, order_id should be informed so that this order can be excluded from the
    open orders list.

    rule_id: int
    instrument_id: int
    date: date
    side: int
    total_quantity: int
    price: Decimal
    basket_id: int
    order_id: int

    returns {allocation_suggestions: funds_allocation, navs: funds_nav}
        funds_allocation: {fund_id (int): quantity (int)}
        funds_nav: {fund_id (int): nav (decimal)}
check_compliance_for_approval(execution_group_ids)
    Checks compliance for already allocated executions that are pending approval.
    'execution_group_ids': [int]

    returns: see compliance.check_compliance()
update_brokerage(fees_values, update_operations=True)
    Saves the fees in the executionallocation with the new values present.
    If is_confirmed is True, automatic calculations will not be made for the corresponding fees,
    indicating the values set are confirmed and does not need to be overridden by the system.

    VALUES ARE GIVEN IN SETTLEMENT'S CURRENCY.
    A currency_exhange rate is given to convert it to instrument's currency.

    fees_values: { execution_allocation_id (int): values}
        values:  {'settlement_fee_value': Decimal or None, 'brokerage_fee_gross_value': Decimal or None,
                  'registration_fee_value': Decimal or None, 'emolument_value': Decimal or None,
                  'brokerage_fee_rebate_value': Decimal or None}
import_orders_distribution_file(filename, contents)
    Imports a file with distribution by order_ids or instrument_ids
get_detailed_prices_for_trading(instrument_ids, date)
    Returns the instrument prices in a format suitable for trading purposes.
    This usually is a price without applying price_divisor, in the instrument's currency,
    and takes care of instrument-type idiosyncrasy (such as futures using settlement_price instead of price).

    instrument_ids: [int]
    date: date

    returns: {instrument_id (int): price}
        price: {nav_unit_value: Decimal, exposure_unit_value: Decimal}

    Missing prices are not returned.
cancel_orders(order_ids, date, is_compliance_rejection=False, is_creation_rejection=False, is_expiration=False, compliance_approval_msg=None, dont_send_bbg_cancel=False, is_automatic_rejection=False, obs=None, alternative_compliance_msg=None)
    Sets orders as cancelled. Bloomberg orders generates requests to cancel the order through bbg integration,
    and are only set to cancelled once a message of confirmation is received.

    if 'is_compliance_rejection' is True, the status is set to EXECUTION_STATUS.compliance_rejected.

    order_ids: [int]
    date: date
    is_compliance_rejection: bool  # default: False
    is_creation_rejection: bool  # default: False
    is_expiration: bool  # default: False
    compliance_approval_msg: {order_id (int): compliance_approval_msg (str)} or None
    dont_send_bbg_cancel: bool  # default: False

    returns default success dictionary
save_model_portfolio(portfolios)
    Saves a model portfolio.
get_funds_blocked_from_trading(fund_ids, simulated_order, date, portfolio_assets_by_fund=None)
    fund_ids: [fund_id]
    simulated_order: {'instrument_id': int, 'quantity': Decimal, 'side': int, 'price': decimal, 'basket_id': int or None}
    date: date

    returns: {'funds_blocked': [fund_id]}
delete_dispatch_orders(dispatch_order_ids=None, order_ids=None)
get_broker_trading_platform_codes(broker_ids=None, trading_platform=None, ids=None, broker_codes=None)
get_baskets(ids=None, names=None, is_rebalance=None, in_model_portfolio=None)
    Gets baskets.

    ids: [int] or None
    names: [str] or None  # exact matches only
    is_rebalance: bool or None

    returns: {basket_id (int): basket}
        basket: {'id': int, 'name': str, 'is_rebalance': bool or missing}
get_broker_custodians(ids=None, custodian_ids=None, use_custodian_as_key=False)
    Retrieves the custodian of all brokers in the database. May be filtered by broker ID or custodian_id.

    If use_custodian_as_key is True, then the custodian ids become the dictionary keys.

    ids: [int] or None
    custodian_ids: [int] or None

    returns: {broker_id or custodian_id (int): broker} # default: broker_id
        broker: {'id': int, 'custodian_id': int}
get_navs_for_auto_portfolio_allocation(date, fund_ids, instruments, cash_changes)
    # TODO: (JFrancese) #2189 | Review, document and move to an appropriate place.

    date: date
    fund_ids: [int]
    instruments: {instrument_id (int): instrument}
        instrument: {'price': decimal}
    cash_changes: {fund_id (int): decimal}

    returns: {fund_id (int): fund}
        fund: {'fund_id': int, 'currency_id': int, 'currency_prefix': str,
               'overall_nav': decimal, 'main_nav': decimal, 'liquid_nav': decimal,
               'overall_cash': decimal, 'main_cash': decimal, 'liquid_cash': decimal}
update_past_cl_ord_ids_dispatch(dispatch_order_id, past_cl_ord_id)
    Adds past_cl_ord_id to past_cl_ord_ids field

    dispatch_order_id: int
    past_cl_ord_id: string

    returns {'success': bool}
get_instruments_position_for_allocation(date=None, instrument_ids=None, fund_ids=None, identifiers=None, for_ideal_portfolio=False, prices=None, include_lending_quantities=True, accept_older=True)
    Retrieves the current position of instruments and their corresponding value and unit_value in the fund portfolios.
    If no date is provided gets the latest portfolio.
    If accept older is True (default), gets the closest snapshot to the given date.

    date: date or None
    instrument_id: [int] or None
    fund_ids: [int] or None
    prices: {instrument_id: decimal} or None

    returns: {instrument_id (int): funds}
        funds: {fund_id (int): position}
            position: {'quantity': Decimal, 'nav': Decimal, 'exposure_percent': Decimal,
                       'delta_exposure_percent': Decimal, 'group_exposure_percent': Decimal, 'delta_group_exposure_percent': Decimal,
                       'exposure_unit_value': Decimal, 'nav_unit_value': Decimal}

    All values are in the fund's currency. 'quantity' is always the number of units, and
    'unit_value'/'exposure_unit_value' are the prices per unit, even when the asset is negotiated in multiplier blocks.
get_weighted_expositions_allocation(rule, allocations, instrument_id, side, quantity_to_allocate, fund_navs, date, forbidden_funds, price=None, ignore_round_lot=False)
    Algorithm that equalizes the expositions of an asset for the given funds (present in the 'allocations' argument).
    The algorithm first tries to match all the expositions to the lowest asset exposition of allocations in case the
    execution is a SELL. If it's a BUY execution, try to match to the highest asset exposition.
    The allocations of each fund is done with a stack ordered by exposition (ascendant for BUY, descendant for SELL),
    always trying to match to the next asset exposition on the stack.
    If all expositions are matched and there are remaining quantity to allocate, this remaining quantity is allocated
    with the nav proportional algorithm (get_nav_proportional_allocation method).
    If there is not enough quantity to match all the expositions, the quantity is allocated with the nav proportional
    algorithm for the already balanced funds.
    The method returns a list of allocations with the given equalized expositions and quantities.

    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    allocations: [allocation]
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal or None, 'weight': Decimal or None}
    instrument_id: int
    side: int,
    quantity_to_allocate: Decimal,
    fund_navs: {fund_id (int): Decimal}
    date: date
    price: Decimal or None
    ignore_round_lot: boolean

    returns: {'allocations': [allocations], remaining_quantity: int}
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal,
                     'was_limited': bool}
update_order_status(orders_to_update, orders=None, end_date=None)
    Updates the order execution & allocation status depending on the quantity allocated.

    The input dictionary allows to override quantity status by compliance check status.
    orders_to_update: {order_id (int): pending_compliance_approval (bool)}
    orders: None or return format from get_order_info()
    end_date: date or None  # which date to set as end_date if the order has been finalized. Defaults to today

    returns: {'errors': [string]}
get_equalized_expositions_allocation(allocations, instrument_id, side, quantity_to_allocate, fund_navs, date, price=None, ignore_round_lot=False)
    Algorithm that equalizes the expositions of an asset for the given funds (present in the 'allocations' argument).
    The algorithm first tries to match all the expositions to the lowest asset exposition of allocations in case the
    execution is a SELL. If it's a BUY execution, try to match to the highest asset exposition.
    The allocations of each fund is done with a stack ordered by exposition (ascendant for BUY, descendant for SELL),
    always trying to match to the next asset exposition on the stack.
    If all expositions are matched and there are remaining quantity to allocate, this remaining quantity is allocated
    with the nav proportional algorithm (get_nav_proportional_allocation method).
    If there is not enough quantity to match all the expositions, the quantity is allocated with the nav proportional
    algorithm for the already balanced funds.
    The method returns a list of allocations with the given equalized expositions and quantities.

    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    allocations: [allocation]
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal or None,
                     'min_delta_quantity': Decimal or None, 'max_delta_quantity': Decimal or None,
                     'was_limited': bool or None}
    instrument_id: int
    side: int,
    quantity_to_allocate: Decimal,
    fund_navs: {fund_id (int): Decimal}
    date: date
    price: Decimal or None
    ignore_round_lot: boolean

    returns: [allocation]
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal,
                     'was_limited': bool}
get_brokers_administrator_codes(broker_ids=None, administrator_ids=None, file_type_identifiers=None)
    Retrieves BrokerAdministrator information. May be filteres by broker_ids, administrator_ids or file_type_ids.

    broker_ids: [int] or None
    administrator_ids: [int] or None
    file_type_identifiers: [FILE_IDENTIFIERS] or None

    returns: {(broker_id, administrator_id, file_type_id): brokers_administrator}
        broker_id: int
        administrator_id: int
        brokers_administrator: {'id': int 'broker_id': int, 'administrator_id': int, 'code': str,
        'legal_id': int, 'file_type_identifier': FILE_IDENTIFIERS or None}
import_order_allocation_file(filename, contents)
    Imports a file with allocations by order ids.
approve_orders(approval_by_order_id, propagate_approval=False)
    Approves the creation of pending orders.
    If order was pending for creation, checks compliance pior to approving.
    If order was pending for compliance approval, approves it.

    approval_by_order_id: {order_id (int): {'msg': str, 'validity': int}}

    returns: {'success': bool}
calculate_rebalance_orders(rebalance_type, fund_ids, date=None, display_currency_id=None)
    Calculates order suggestions for rebalancing fund portfolios.

    rebalance_type: ORDER_REBALANCE_TYPES (int)
    date: date or None
    fund_ids: [int] or None

    returns: {'orders': [order], 'messages': [str]}
        order: {'instrument_id': int, 'instrument_name': str, 'side': ORDER_SIDES (int), 'date': date,
                'base_price': Decimal, 'basket_id': int or None, 'by_fund': {fund_id (int): fund_order}
            fund_order: {'delta_exposure': Decimal, 'delta_quantity': Decimal, 'delta_financial': Decimal,
                         'final_exposure': Decimal, 'basket_id': int or None}
approve_allocations(execution_groups)
    Approves all allocations associated with this execution group.
    execution_groups: {group_id (int): compliance_approval_msg (str)}

    returns: {'success': boolen, 'error_msg': string or None,
              'allocation_status_by_eg': {eg_id (int): ALLOCATION_STATUS (int)}
get_allocations_by_executiongroup(execution_group_ids)
    Retrieves all execution allocations from execution group ids.

    execution_group_ids = [int]

    Returns: {execution_group_id (int): [allocation]}
        allocation: {'allocation_group_id': int, 'execution_allocation_id': int}
add_dispatch_orders(dispatch_orders, user_id=None, send_order_update=True)
    Adds or updates orders dispatch in batch. OrdersDispatch with 'order_dispatch_id' set will be updated.
    When editing, raises InvalidOrderQuantityEXception when the quantity isn't supported by the related order

    'orders_dispatch': ['order_dispatch']
        'order_dispatch': {'dispatch_order_id': int or None, 'order_id': int, date: Date, due_date: Date or None, quantity: decimal,
                            'limit_price': decimal or None, 'trading_platform': int, 'broker_trading_platform_code_id': int or None,
                             broker_id: int or None, 'broker_trading_platform_account_code_id': int or None, rebate_percent: decimal or None
consolidate_executions(date, instrument_ids=None, execution_group_ids=None, dry_run=False)
    Consolidates executions of non-allocated execution groups, by price-broker or by average price-broker,
    depending on market parametrizarion (bool consolidade_executions_on_average_price).
    Consolidation is performed inside ExecutionGroups only. Different execution groups are never merged.

    date: date
    instrument_ids: [int] or None
    execution_group_ids: [int] or None
    dry_run: bool  # default: False

    returns: {'execution_group_ids': [int], 'original_execution_count': int, 'new_execution_count': int}
get_valid_model_portfolios(date, fund_ids=None, model_ids=None, models_only=False, operations=None, basket_id=None, prices=None)
    Returns the valid model portfolios on the given date, for the given funds.

    date: date
    fund_ids: [int] or None
    basket_id: int: a basket id that should replace the model portfolio basket id
    prices: {instrument_id (int): Decimal}

    returns:  # if models_only
        {model_id (int): model}
            model: {'id': int, 'name': str, 'date': date, 'basket_id': int or None}

    returns:  # if not models_only
        {fund_id (int): model}
            model: {'id': int, 'name': str, 'date': date, 'basket_id': int or None, 'fund_id': int, 'assets': [asset]}
                asset: {'instrument_id': int, 'exposure': decimal, 'side': ORDER_SIDES (int) or None,
                        'tolerance_range': Decimal}
delete_allocation_rule(allocation_rules_ids)
    Delete the allocation rules and allocation rules funds.
    'allocation_rules_ids': [int]
    return dictionary success message
delete_executions(execution_group_id, execution_ids=None)
    Removes from database all executions from the list, provided that they have not been allocated. It is assumed
    that all executions belong to the input execution group. If no execution ids are provided, then all executions
    under the group are deleted, and the group is also deleted.

    execution_ids: [int]

    returns: {'success': boolean, 'error_msg': string or None}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
get_ideal_allocation_for_execution_groups(execution_group_ids, funds, portfolio_assets_by_fund, date=None, allocation_method=None, ignore_round_lot=False, spare_provisions=None, funds_currency=None, execution_groups_extra_values=None, use_gross_nav=False)
    Returns a ideal allocation for the given funds to the execution groups with the given ids
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    If spare_provisions is set, the NAVs will be increased/decreased by the values given for each fund.

    execution_group_id: int
    funds: [fund_id (int)]
    order_id: int or None
    allocation_method: ALLOCATION_METHODS (int) or None
    date: date or None
    ignore_round_lot: boolean
    spare_provisions: {fund_id: decimal}

    returns: {'execution_groups': {execution_group_allocation}, 'messages': [string] or None, 'compliance_limits': []}
        execution_group_allocation: {group_id (int) : { 'ideal_allocation' : [fund_allocation] }
            fund_allocation: {'fund_id': int,
                              'instrument_id': int,
                              'quantity': Decimal,
                              'delta_quantity': Decimal,
                              'exposure': Decimal,
                              'delta_exposure': Decimal,
                              'strategy_id': int,
                              'order_index': int}
add_brokerage_fee_rebate_rules(brokerage_fee_rebate_rules)
    brokerage_fee_rebate_rules: [brokerage_fee_rebate_rule]
        brokerage_fee_rule: {
            'id': int or None,
            'markets': [market_id], 'broker_accounts': [account_id],
            'basket_id' : int or None,
            'rebate_percent': Decimal or None,
            'operation_type': Decimal or None,
            'is_active': bool
        }
get_broker_accounts(ids=None, broker_ids=None, fund_ids=None, tordist_codes=None, tordist_codes_with_digits=None, codes=None, is_active=True)
    Retrieves information for broker accounts. Accepts optional filters.

    ids: [int] or None
    broker_ids: [int] or None
    fund_ids: [int] or None
    tordist_codes: [int] or None
    tordist_codes_with_digits: [code_and_digit] or None
        code_and_digit: 2-tuple (code (int), digit (int))
    codes: [str] or None

    returns: {broker_account_id (int): account}
        account: {'id': int, 'tordist_code': int, 'tordist_digit': int, 'broker_id': int, 'fund_ids': [int],
                  'code': str, 'ignore_fees_from_confimation_file': bool}
update_past_cl_ord_ids(order_id, past_cl_ord_id)
    Adds past_cl_ord_id to past_cl_ord_ids field

    order_id: int
    past_cl_ord_id: string

    returns {'success': bool}
associate_executions_to_order(order_data, skip_validations=False)
    associate deallocated executions to orders.
    If skip_validations is True, dont validate if order quantity and limit price are beeing exceeded

    order_data: {eg_id (int): order_id (int)}

    returns: {'success': bool}
get_allocation_rules(rule_ids=None)
    Returns the list of avaialble allocation rules.

    rule_ids: [int] or None

    returns: {rule_id (int): rule}
        rule: {'id': int, 'name': str, 'method': ALLOCATION_METHODS (int), 'funds': {fund_id (int): fund}}
            fund: {'id': int, 'name': str, 'weight': decimal, 'instruments_group_id': int or None}
get_total_quantity_from_open_orders(date, fund_id, instrument_id, exclude_order_ids=None)
    Sums up the open orders quantity for the given parameters (date, fund and instrument).
    If setting EXECUTION_USE_OPEN_ORDERS_FOR_EXPOSITION is False, it returns 0 so that
    open orders don't impact new ones.

    date: datetime
    fund_id: int
    instrument_id: int
    order_id: [int]

    returns: Decimal
delete_simple_allocation_chains(allocation_ids, delete_operations=True)
    Undoes the specified Allocations deletes the related executions and execution groups.
    An exception will be raised if this is attempted on an allocation that belongs to an execution group
    with more than one allocation.

    If delete_operations is True (the default), corresponding Operations will also be deleted,
    thus properly undoing the allocations' effects. This should only be set to False if this method is being
    called from a code path that deletes operation objects by themselves.

    allocation_ids: [int]
    delete_operations: bool  # default: True

    returns: default success dictionary
set_order_approval(order_id, set_pending_compliance_approval, compliance_allocation_obs=None, compliance_rules_to_propagate=None)
    Sets a new/changed order as approved/not-approved (pending aprroval) due either to a lack of
    order creation permissions or to compliance errors paired with a lack of compliance override permissions.

    order_id: int
    set_pending_compliance_approval: bool
    compliance_allocation_obs: str or None
    compliance_rules_to_propagate: [int] or None

    returns: default success dictionary
get_prices_for_trading(instrument_ids, date)
    Returns the instrument prices in a format suitable for trading purposes.
    This usually is a price without applying price_divisor, in the instrument's currency,
    and takes care of instrument-type idiosyncrasy (such as futures using settlement_price instead of price).

    instrument_ids: [int]
    date: date

    returns: {instrument_id (int): Decimal}

    Missing prices are not returned.
get_order_info(order_ids=None, start_date=None, end_date=None, fund_ids=None, side=None, basket_ids=None, allocation_status=None, execution_status=None, instrument_ids=None, include_non_allocated=True, validate_user_fund_permissions=False, is_pending_allocation=None, is_pending_approval=None, compliance_approved_only=False, get_pre_approved_rules=False, display_currency_id=None, fill_exposures=True, get_whole_multiday_orders=False, profiler_prefix='', broker_ids=None)
    Retrieves orders

    'order_ids': [int] or None
    'start_date': date or None # list orders valid after this date, inclusive
    'end_date': date or None # list orders valid before this date, inclusive
    'fund_ids': [int] or None
    'side': ORDER_SIDE (int)
    'basket_ids': [int] or None  # Pass [None] to filter only orders not associated to any basket
    'broker_ids': [int]  or None
    'allocation_status': [ALLOCATION_STATUS (int)] or None
    'execution_status': [EXECUTION_STATUS (int)] or None
    'instrument_ids': [int] or None
    'include_non_allocated': boolean or None # default True
    'validate_user_fund_permissions': boolean # default False: if True, skips preallocated orders with funds that the user is not allowed to view
    'is_pending_allocation': boolean or None # filter orders with allocation status ALLOCATION_STATUS.none and ALLOCATION_STATUS.partial
    'is_pending_approval': boolean or None # filter orders with allocation compliance errors, pending approval
    'compliance_approved_only': boolean or None # filter orders where compliance_approval_msg is not null
    'display_currency_id': int or None  # if informed, all financial values (though not prices) will be converted to it
    'fill_exposures': boolean or None # default False: return information on per-fund current and target values
    'get_period_values': boolean or None # default False: if True, also returns values for the given period

    returns: {order_id (int): order}
        order: {'order_id': int, 'funds': [], 'instrument_id': int, 'instrument_name': string, 'short_name': string,
                'instrument_type_id': int, 'side': ORDER_SIDE, 'date': date, 'due_date': date or None, 'end_date': date or None,
                'first_day_order_id': int or None, 'original_start_date': date or None,
                'quantity': decimal, 'limit_price': decimal, 'base_price': decimal,
                'basket_id': int or None, 'basket_name': str or None, 'cl_ord_id': string, 'is_fix': bool,
                'user_id': int, 'user_name': str, currency_id: int, 'compliance_approval_msg': str or None,
                'compliance_pending_msg': str or None,
                'can_modify': bool, 'execution_status': EXECUTION_STATUS (int), 'status_display': string,
                'allocation_status': ALLOCATION_STATUS (int), 'allocation_status_display': string,
                'allocation_rule_id': int, 'allocation_rule_name': string,
                'quantity_allocated': decimal, 'quantity_to_allocate': decimal,
                'quantity_executed': decimal, 'quantity_to_execute': decimal,
                'executed_percentage': decimal, 'average_price': decimal,
                'financial_value': decimal, 'executed_value': decimal, 'allocated_value': decimal,
                'funds': [fund_order],
                # If get_period_values:
                'period_execution_status': EXECUTION_STATUS (int), 'period_execution_status_display': string,
                'period_quantity': decimal, 'period_quantity_executed': decimal, 'period_quantity_to_execute': decimal,
                'period_quantity_allocated': decimal, 'period_quantity_to_allocate': decimal,
                'period_executed_percentage': decimal, 'period_average_price': decimal,
                'period_financial_value': decimal, 'period_executed_value': decimal,
                }
            fund_order: {'fund_id': int, 'fund_name': string, 'strategy_id': int, 'strategy_name': string,
                         'basket_id': int or None, 'basket_name': string or None,
                         'nav': Decimal, 'currency_id': int,
                         'quantity': Decimal, # alias of delta_quantity
                         'exposure': Decimal, # alias of current_exposure
                         'delta_quantity: Decimal, 'delta_exposure': Decimal, 'delta_financial': Decimal,
                         'executed_quantity': Decimal, 'executed_exposure': Decimal, 'executed_financial': Decimal,
                         'allocated_quantity': Decimal, 'allocated_financial': Decimal,
                         # If fill_exposures:
                         'current_quantity': Decimal, 'current_exposure': Decimal, 'current_financial': Decimal,
                         'final_quantity': Decimal, 'final_exposure': Decimal, 'final_financial': Decimal,
                         # If get_period_values:
                         'period_delta_quantity': Decimal, 'period_delta_exposure': Decimal, 'period_delta_financial': Decimal,
                         'period_executed_quantity': Decimal, 'period_executed_exposure': Decimal, 'period_executed_financial': Decimal,
                         }
set_dispatch_order_status(dispatch_order_id=None, cl_ord_id=None, execution_status=None, allocation_status=None, ignore_compliance_rejection=True)
    Updates order status. Either order id or ClOrdId must be passed as argument.

    'dispatch_order_id': int or None
    'cl_ord_id': string or None
    'execution_status': EXECUTION_STATUS (int)
    'allocation_status': ALLOCATION_STATUS (int)
    'ignore_compliance_rejection': bool

    returns default succes dictionary
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
generate_execution_generic_file(date, identifier)
    Generates executions file for this administrator.

    date: date
break_execution_group(execution_group_id, execution_ids=None)
    Removes a set of executions from an execution group, and creates a new group to contain it.

    execution_ids: [int]

    returns: {'success': boolean, 'error_msg': string or None}
set_new_cl_ord_id(cl_ord_id, new_cl_ord_id, dispatch_order_id=None)
    Updates the ClOrdId of the order with ClOrdId = 'cl_ord_id' to 'new_cl_ord_id'

    'cl_ord_id': string
    'new_cl_ord_id': string

    return default success dictionary
update_execution_allocations_sent_to_broker(ids, sent_to_broker)
    Updates sent_to_broker attribute of existing execution allocations.

    Returns: default sucess dictionary
get_orders_to_batch_action(order_ids, action)
    filter all order_ids that can do the action
get_broker_tordist_codes(ids=None)
    Retrieves the tordist codes of all brokers in the database. May be filtered by ID.

    ids: [int] or None

    returns: {broker_id (int): broker}
        broker: {'id': int, 'tordist_code': int}
add_executions(executions, user_id=None, fund_id=None, strategy_id=None, account_id=None, accounting_days=None, basket_id=None, account_by_broker_and_currency=None, skip_compliance_check=False, instruments_affected_by_compliance=None, skip_order_checking_for_hard_matched_orders=False)
    Inserts new executions. Each execution is either automatically added to an existing execution
    group or, if no compatible groups are found, a new execution group is created.

    If an allocated execution is to be added (i.e. ia a fund ID is specified, either globally or in the execution),
    a new execution group is necessarily created for each execution.

    If allocating, a compliance test will be performed unless skip_compliance_check is true;
    if the tests do not pass, a ComplianceError will be raised.
    Allocation accounts can be specified in one of three ways:
    - a single account for all executions, using the 'account_id' parameter
    - one account for each broker-currency pair, using the 'account_by_broker_and_currency' parameter
    - for each execution
    If a fund is passed but the account is not specified, the default account for executions
    (in the instruments' currencies) will be used.

    'executions': [execution]
        execution: {'': int or None, 'order_id': int or None,
                    'instrument_id': int, 'broker_id': int, 'execution_source': EXECUTION_SOURCES (int) or None,
                    'side': EXECUTION_SIDES (int), 'execution_date': date, 'settlement_date': date,
                    'quantity': int, 'unit_value': decimal, 'is_exercise': bool or None # default: False,
                    'fund_id': int or None, 'account_id': int or None, 'strategy_id': int or None,
                    'rebate_percent': decimal or None, # defined and used only when allocating
                    'currency_id': int or None # only necessary if different from instrument's currency
                    'payment_acrollover_base_pricecount_id': int or None, # only when allocating
                    'payment_exchange_rate': decimal or None,
                    'exec_ref_id': string or None, 'accounting_days': int or None,
                    'operation_extra_values': dict or None,  # used only when allocating
                    'rollover_base_price': decimal or None,
                    'rate': dexecution_group_idecimal or None,
                    'no_cash_impact': bool or None# default False,
                    'origin_id': int, 'origin_content_type_id': int,
                    'skip_price_creation': boolean or None # default False
                    'user' : int or None,
                    'dispatch_order_id': int or None,
                    '': Decimal or None
                    }
    'fund_id': int or None
    'strategy_id': int or None
    'account_id': int or None
    'account_by_broker_and_currency': {broker_id(int): {account_by_currency}} or None
        account_by_currency: {currency_id (int): account_id (int)}
    'skip_compliance_check': bool or None  # default: False
    'check_orders_limit_price': If true checks execution price against order limit price

    returns: default success dictionary + {'execution_group_ids': [int]}
get_content_type_for_allocations()
    Returns the content type ID for the Allocation model.

    returns: {'id': int}
get_default_basket()
    Returns the default Basket
    returns: { 'basket_id': int, 'basket_name': string}
add_allocation_rules(allocation_rules)
    If the allocation rule object has a id key, should update it, otherwise inserte a new Allocation Rule.
    'allocation_rules' = [allocation_rule]
        'allocation_rule' = {
            'id': int or None
            'funds': [fund] or None
                fund: {'fund_id': int, weight: int},
            'name': String,
            'method': int,
            'is_active': bool,
            instruments_group: int or None,
        }
    returns: default success dictionary + {'allocation_rules': [int], 'allocation_rules_funds': [int]}
get_allocated_order_suggestion_group_exposure(rule, instrument, date, side, price, quantity_to_allocate, forbidden_funds, navs, fund_ids=None)
add_exchange_fee_rules(exchange_fee_rules)
    exchange_fee_rules: [exchange_fee_rule]
        exchange_fee_rule: {
            'id': int or None,
            'markets': [market_id],
            'instrument_type_id': int or None,
            'min_daily_value' : Decimal or None,
            'min_adtv': Decimal or None,
            'execution_type: int or None,
            'legal_entity_type': int or None,
            'emolument_percent': Decimal or None,
            'settlement_fee_percent': Decimal or None,
            'registration_fee_percent': Decimal or None
            'is_active': bool
        }
send_brokers_lending_operations_email(date=None, include_only_new=False, broker_ids=None)
    Generates broker lending operations file(s) and send it to counterparties by email.
add_orders(orders, skip_compliance_check=None, user_id=None, is_warning=None, rules_to_propagate=None, instruments_affected_by_compliance=None, compliance_results_to_email=None, can_override_compliance=None, allocation_rule_id=None, send_order_update=True, send_compliance_pending_orders_email=True)
    Adds or updates orders in batch. Orders with 'order_id' set will be updated.

    Orders with 'send_to_bloomberg' set will be sent to create a new order on bloomberg,
    or update an already sent order.

    When editing, raises InvalidOrderQuantityException when new quantity exceeds executed/allocated quantity.

    'orders': [order]
        order: {'order_id': int or None, 'instrument_id': int, 'side': ORDER_SIDES (int), 'date': date,
                'due_date': date, 'quantity': decimal, 'limit_price': decimal or None, 'base_price': decimal,
                'basket_id': int or None, 'notes': string or None, 'trading_platform': int, yield_value: decimal or None,
                'broker_trading_platform_code_id': int or None, 'broker_trading_platform_account_code_id': int or None,
                'funds': {fund_id (int): fund_order}, 'accounting_days': int or None, consolidate_change: bool or None,
                'rebate_percent': decimal or None}
        fund_order: {'fund_id': int, 'instrument_id': int, 'quantity': decimal, 'strategy_id': int,
                     'delta_exposure': decimal or None, 'basket_id': int or None}

    returns:
add_baskets(baskets)
    Insert a new Basket.
    baskets: [basket]
        basket:{
            'id': int or None,
            'name': str
            'is_rebalance': bool
        }

    return: default success dictionary
get_nav_proportional_allocation(allocations, instrument_id, side, quantity_to_allocate, fund_navs, date, price=None, default_price=None, ignore_round_lot=False)
    Algorithm that returns the allocations of an execution for the given funds (present in the 'allocations' argument)
    proportionally with its nav values.
    The method returns a list of allocations with the given expositions and quantities calculated based on the nav
    values.
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    allocations: [allocation]
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal or None,
                     'min_delta_quantity': Decimal or None, 'max_delta_quantity': Decimal or None,
                     'was_limited': bool or None}
    instrument_id: int
    side: int,
    quantity_to_allocate: Decimal,
    fund_navs: {fund_id (int): Decimal}
    date: date
    price: Decimal or None  # if supplied, it is used forcefully
    default_price: Decimal or None  # if supplied, it is used only when there is no price in the database
    ignore_round_lot: boolean

    returns: [allocation]
        allocation: {'fund_id': int, 'quantity': Decimal, 'exposure': Decimal, 'delta_quantity': Decimal,
                     'was_limited': bool}
get_order_to_modify(modified_items, fund_ids=[], group_by_instrument=False)
get_simple_order_info(order_ids=None, cl_ord_ids=None, past_cl_ord_id=None, dispatch_order_ids=None, get_fund_orders=False)
    Returns basic order data.

    order_ids: [int] or None
    cl_ord_ids: [string] or None
    get_fund_orders: bool  # default: False

    returns: {order_id (int): order}
        order: {'id': int, 'cl_ord_id': str or None, 'instrument_id': int, 'side': ORDER_SIDES (int),
                'date': date, 'due_date': date or None, 'quantity': Decimal,
                'base_price': Decimal or None, 'limit_price': Decimal or None, 'funds': [fund_order] or missing,
                'instrument_name': str, 'side_display': str, 'short_name': str}
        fund_order: {'fund_id': int, 'quantity': Decimal, 'strategy_id': int, 'basket_id': int or None}
get_funds_by_broker(broker_ids=None, fund_ids=None, is_active=True)
    broker_ids: [int] or None
    fund_ids: [int] or None
    is_active: bool  # default: True

    returns: {broker_id (int): [fund]}
        fund: {'fund_id': int, 'fund_name': string}
import_orders_file(filename, contents)
    Imports a generic orders file
delete_brokerage_rebate_fee_rules(brokerage_fee_rebate_rule_ids)
delete_executions_by_id(ids=None, group_ids=None)
    Removes from database all given executions or execution groups.
    Returns an error if they have already been allocated.
    The executions' execution groups will be deleted if they no longer have executions.

    ids: [int] or None
    group_ids: [int] or None

    Please note that the all executions matching EITHER the supplied execution IDs or group IDs will be deleted
    (it's an "OR" filter rather than an "AND" filter).

    returns: {'success': boolean, 'error_msg': string or None}
get_brokerage_fee_rebate_rules(broker_account_ids, market_ids, is_active=True, operation_types=None)
    Retireves the brokerage fe rebate rules for broker_accounts and market_ids.

    broker_account_ids: [int]
    market_ids: [int]
    is_active: bool # default=True
    operation_types: [int] or None

    returns: [rule]~
        rule: {'rule_id': int, 'rebate_percent': decimal, 'market_ids': [int], 'broker_account_ids: [int],
               'operation_type': int or None}
delete_orders(order_ids)
    Removes from database all orders from the list.

    order_ids: [int]

    returns: {'success': boolean, 'error_msg': string or None}
get_execution_group_info(execution_group_ids=None, fund_ids=None, start_date=None, end_date=None, instrument_ids=None, market_ids=None, broker_ids=None, side=None, basket_ids=None, bypass_orders=False, execution_allocation_ids=None, use_exchange_rate=False, execution_status=None, group_by_broker=False, group_by_instrument=False, compliance_approved_only=False, allocation_status=None, order_ids=None, display_currency_id=None, get_pnl=False, is_root_call=False, profiler_prefix=u'')
    Returns execution groups' info with their respective executions, orders and allocations.
    Allocations are grouped by fund.

    Orders is a list of all orders that match the same date, side and instrument of the execution_group.
    If bypass_orders = True, it doesn't return the possible orders matched to the executions group, neither the
    unmatched orders. Set bypass_orders to True if you don't need to return these orders. This is important for huge
    optimization purposes.
    If basket filtering is used, only execution groups matched to orders are returned, since it's an order-only field.

    Orders that match the filtering criteria but don't match any execution group are added as fake execution groups
    with execution_group_id=None.

    If compliance_approved_only = True, returns only Orders and Execution Groups
    where compliance_approval_msg is not null.

    When an allocation status filter is used, only execution groups with executions are returned.

    Group-by-broker and group-by-instrument cannot be used at the same time.
    A ValueError exception will be raised if done so.

    PnL calculation can be triggered by passing get_pnl=True. PnL is always calculated using the instrument's closing
    price at the execution date.

    'execution_group_ids': [int] or None
    'fund_ids': [int] or None
    'start_date': date or None
    'end_date': date or None
    'instrument_ids': [int] or None
    'market_ids': [int] or None
    'broker_ids': [int] or None
    'side': EXECUTION_SIDES (int) or None
    'basket_ids': [int] or None
    'bypass_orders': bool
    'execution_status': [EXECUTION_STATUS (int)] or None # EGs without orders are always in 'completed' status
    'allocation_status': [ALLOCATION_STATUS (int)] or None
    'group_by_broker': boolean # default: False; groups executions by ExecutionGroup *and* broker
    'group_by_instrument': boolean # default: False; groups execution by instrument *instead* of ExecutionGroup
    'compliance_approved_only': boolean # default: False; filters by compliance_approval_msg <> null
    'display_currency_id': int or None  # if informed, all financial values (though not prices) will be converted to it
    'get_pnl': bool  # default: False

    returns: {'items': [execution_group]}
        execution_group: {'execution_group_id': int, 'side': EXECUTION_SIDES (int),
                          'instrument_id': int, 'instrument_name': string,
                          'basket_id': int or None, 'basket_name': string or None
                          'execution_date': date, 'settlement_date': date,
                          'allocation_status': ALLOCATION_STATUS(int), 'allocation_status_display': string,
                          'manually_split': boolean, 'explanation': string, 'quantity': Decimal,
                          'quantity_allocated': Decimal, 'quantity_to_allocate': Decimal,
                          'instrument_default_strategy_id': int or None,
                          'orders': [order], 'executions': [execution], 'allocations': [allocation],
                          'average_price': Decimal, 'total_value': Decimal, 'total_pnl': Decimal or missing}
            order: *execution.get_order_info() output
            execution: {'execution_id': int, 'quantity': Decimal, 'unit_value': Decimal,
                        'quantity_allocated': Decimal, 'quantity_to_allocate': Decimal, 'unit_value': Decimal,
                        'value': Decimal, 'pnl': Decimal or missing, 'broker_id': int, 'broker_name': string,
                        'currency_id': int, 'currency_name': string, 'payment_exchange_rate': Decimal or None,
                        'execution_source': EXECUTION_SOURCES (int), 'execution_source_display': string,
                        'execution_source_display_short': string, 'rollover_base_price': Decimal or None,
                        'brokerage_fee_gross_value': Decimal or None,
                        'brokerage_fee_rebate_value': Decimal or None, 'emolument_value': Decimal or None,
                        'settlement_fee_value': Decimal or None, 'registration_fee_value': Decimal or None
                        }
            allocation: {'fund_id': int, 'fund_name': string, 'quantity': Decimal, 'value': Decimal,
                         'average_price': Decimal, 'sent_to_broker': boolean}
match_brokerage_fees(detailed_fees, consolidate_option_exercise_sides=None, consolidation_type=None, all_funds_by_broker=False, all_active_brokers=False, market_acronyms=None, is_carrying_matching=False)
    Locates ExecutionAllocations for the given fee items.
    In addition, calculates the consolidated brokerage fees.

    If 'consolidate_option_exercise_sides' is True, execution sides for option exercises will be converted
    to simple buy/sells for the matching process.

    If 'all_funds_by_broker' is True, match will consider all local executions of brokers contained in the file.
    If False, it will only consider funds in this file.

    If 'all_active_brokers' is True, match will consider all local executions,
    regardless of the brokers or funds contained in the files.

    'all_funds_by_broker' and 'all_active_brokers' should not be True at the same time (since 'all_active_brokers'
    also include 'all_funds_by_broker' results. This is garanteed by the front end.

    If 'is_carrying_matching' is True the broker_ids coming from detailed_fees will be considered to be carrying_broker_ids

    If market_acronyms era specified, filter only operations from these markets

    detailed_fees: [fee]  # represents fees for each execution
    consolidate_option_exercise_sides: boolean or None  # default: False
         fee: {'instrument_id': int, 'side': EXECUTION_SIDES (int), 'execution_date': date,
               'broker_id': int, 'fund_ids': [int], 'broker_account_id': int, 'quantity': Decimal,
               'unit_value': Decimal, 'brokerage_fee_gross_value': Decimal, 'brokerage_fee_rebate_value': Decimal,
               'emolument_value': Decimal, 'settlement_fee_value': Decimal, 'registration_fee_value': Decimal}
    consolidation_type: IMPORT_CONSOLIDATION_TYPE (int)  # default: no_consolidation

    returns: default success dictionary + {'unmatched_fee_indices': [int], 'unmatched_eas': [ea],
                                           'eas_to_save': [ea], 'consolidated_fees': [cf]}
        ea: {'is_day_trade': boolean, 'registration_fee_value': Decimal, 'brokerage_fee_rebate_value': Decimal,
             'brokerage_fee_gross_value': Decimal, 'allocation': int, 'emolument_value': Decimal, 'operation': int,
             'execution': int, u'id': int, 'settlement_fee_value': Decimal, 'quantity': Decimal,
             'operation_type': OPERATION_TYPES (int) or None}
        cf: {'brokerage_fee_rebate_value': Decimal, 'registration_fee_value': Decimal, 'is_confirmed': boolean,
             'brokerage_fee_gross_value': Decimal, 'settlement_date': date, 'exchange_rate': Decimal,
             'emolument_value': Decimal, 'settlement_fee_value': Decimal, 'date': date, 'broker_account': int,
             'fund': int, u'id': int, 'market': int, 'settlement_currency': int}

    Fees which are passed to the function but do not have a matching ExecutionAllocation will be indicated in the
    unmatched_fee_indices output entry by their positions in the detailed_fees input list.
update_dispatch_order_status(dispatch_orders_to_update, dispatch_orders=None, end_date=None, update_orders=True)
    Updates the order execution

    The input dictionary allows to override quantity status by compliance check status.
    orders_to_update: {order_id (int): pending_compliance_approval (bool)}
    orders: None or return format from get_order_info()
    end_date: date or None  # which date to set as end_date if the order has been finalized. Defaults to today

    returns: {'errors': [string]}
edit_executions_currency_data(currency_data)
    Edits executions currency and payment_exchange_rate
    currency_data : {execution_id: {currency: Int, 'per': Decimal}}

    returns {success: Bool}
get_open_orders_for_execution_matching(date, instrument_ids)
    Returns all open orders into which new executions can be matched.

    date: date
    instrument_ids: [int]

    returns: {'orders': [order]}
        order: {'order_id': int, 'instrument_id': int, 'side': ORDER_SIDES (int), 'quantity': Decimal,
                'limit_price': Decimal or None, 'start_date': date}
merge_orders(order_ids)
    Combines N orders with the same instrument, side and dates into a sigle order.
    'order_ids': [int]

    returns: {'success': bool, 'error_msg': str or None}
get_dispatch_orders(dispatch_order_ids=None, order_ids=None, group_by_order_id=False, cl_ord_ids=None, past_cl_ord_id=None)
get_ideal_allocation(execution_group_id, funds, group_info=None, order_id=None, allocation_method=None, date=None, ignore_round_lot=False, spare_provisions=None, funds_currency=None, portfolio_assets_by_fund=None)
    Returns a ideal allocation for the given funds to the execution_group
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    If spare_provisions is set, the NAVs will be increased/decreased by the values given for each fund.

    execution_group_id: int
    funds: [fund_id (int)]
    order_id: int or None
    allocation_method: ALLOCATION_METHODS (int) or None
    date: date or None
    ignore_round_lot: boolean
    spare_provisions: {fund_id: decimal}

    returns: {'allocations': [allocation], 'messages': [string] or None}
        allocation: {'fund_id': int, 'instrument_id': int, 'quantity': Decimal, 'delta_quantity': Decimal,
                     'exposure': Decimal, 'delta_exposure': Decimal}
get_funds_to_allocate(rule_id, instrument_id, funds_exposure=None, funds_final_exposure=None)
get_broker_market_codes(broker_ids=None, market_ids=None)
    Retrieves codes related to broker and market.

    broker_ids: [int]
    market_ids: [int]

    returns {broker_id, market_id: {codes}}
        codes: {'clearing_code': string, 'broker_clearing_code': string, 'broker_bridge_clearing_code': string}
get_execution_allocations(allocation_ids=None)
    Get executionallocation's data

    allocation_ids: [int] or None
send_order_to_compliance_approval(order_ids)
    Set orders execution status as pending_compliance_approval
delete_exchange_fee_rules(exchange_fee_rule_ids)
get_default_accounts_for_execution_allocation(execution_keys)
    Retrieves the default accounts to allocate executions of a certain fund, instrument and broker.
    Checks the instrument currency to make sure that the allocation goes to an account in the same currency.

    execution_keys: [execution_key]
        execution_key: (fund_id, instrument_id, broker_id)
            fund_id: int
            instrument_id: int
            broker_id: int or None

    returns: {(fund_id, instrument_id, broker_id): account_id}
get_open_orders_from_instrument_group(date, fund_ids, instrument_id)
    Checks if the given instrument belongs to a group that contains open orders that need to be considered
    on exposure calculation.

    date: datetime
    fund_ids: [int]
    instrument_id: int

    returns: {order_id (int): order}
import_model_portfolio_from_xls(filename, contents, date=None, basket_id=None, save_portfolio=False)
    Imports a XLS file containing a model portfolio for funds.

    filename: string
    contents: string

    returns: default success dictionary + {file_id: int}
cancel_dispatch_order(dispatch_order_id=None, order_id=None)
roll_orders(order_ids, end_date)
    Marks the selected orders as having been canceled in the given end_date, and creates a new order
    starting in the next business day with the remaining quantity. A pointer is kept from the new order
    to the first one in its series. FIX IDs are cleared in the old order and copied to the new order.

    order_ids: [int]
    end_date: end_date

    returns: {'new_id_by_old_id': {int: int}}
get_proposed_allocation(date, fund_ids, instrument_id, side, price, desired_exposure=None, desired_delta_quantity=None, ignore_round_lot=False, spare_provisions=None)
    Returns the fund allocation calculated based on the passed value desired_exposure OR desired_quantity.
    Note that desired_delta_quantity is the quantity of the operation (sell/buy), NOT the final desired quantity.
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    If 'spare_provision' is set, the value will be added to the NAV of the funds.

    date: date
    fund_ids: [fund_id (int)]
    instrument_id: int
    instrument_id: int
    side: int
    price: Decimal
    desired_exposure: decimal or None
    desired_quantity: decimal or None
    ignore_round_lot: boolean
    spare_provisions: {fund_id: decimal}

    returns: {'allocations': [allocation], 'messages': string or None}
        allocation: {'fund_id': int, 'instrument_id': int, 'quantity': Decimal, 'delta_quantity': Decimal,
                     'exposure': Decimal, 'delta_exposure': Decimal}
disassociate_executions_to_order(exec_group_ids)
    Marks the specified execution groups as not associated to any order.
    exec_group_ids : [int]

    returns: { 'success': boolean }
get_brokerage_info_for_operations(operations, break_by_execution=True)
    Retrieves brokerage information for operations generated from allocations. In addition to the operation's fees,
    this API returns information on each execution that makes up the operation's originating Allocation.

    operations: [op]
        op: {'id': anything, 'broker_id': int, 'origin_id': int or None, 'origin_content_type_id': int or None,
             'extra_values': dict}

    returns: {operation_id (int): [op]}
        op: {'executions': [exec], 'broker_id': int,
             'brokerage_fee_gross_value': Decimal, 'brokerage_fee_rebate_value': Decimal,
             'emolument_value': Decimal, 'registration_fee_value': Decimal, 'settlement_fee_value': Decimal}
        exec: {'execution_id': int, 'execution_allocation_id': int, 'quantity': Decimal, 'price': Decimal,
               'brokerage_fee_gross_value': Decimal, 'brokerage_fee_rebate_value': Decimal,
               'emolument_value': Decimal, 'registration_fee_value': Decimal, 'settlement_fee_value': Decimal}
check_order_for_compliance_approval(order_id)
get_execution_group_by_order(orders, weak=True, profiler_prefix='')
    'orders': { order_id (int): {'instrument_id': int, 'date': date, 'due_date': date, 'side': side}}
    'weak': bool # if True, the api tries to match orders using instrument, side and date information.
                 # Else, only returns execution groups with order_id set, or only falls into one order

    returns: {order_id (int): *execution.get_execution_group_info() output}
order_can_perform_action(orders)
    return for each order if it is possible to execute all possible actions;
delete_brokerage_fee_rules(brokerage_fee_rule_ids)
delete_executions_by_exec_ref_id(exec_ref_ids)
    Deletes executions by its fix ExecRefId value.

    exec_ref_ids: [string]

    returns {exec_ref_id (string) : default success dictionary}
filter_compliance_prior_approval(funds_compliance_data, fund_orders)
    Filters compliance results, removing alerts regarding rules that where pre-approved on ordem creation (pre-trade).
    funds_compliance_data : look at check_compliance return
    fund_orders: [fund_order]
    fund_order: {'instrument_id': int, 'quantity': Decimal, 'side': ORDER_SIDES, 'price': Decimal,
                    'fund_id': int or None, 'strategy_id': int or None, 'execution_date': date,
                    'existing_order': bool}

    returns: {funds_compliance_data: filtered compliance data, 'is_compliant': bool}
get_simple_ideal_allocation(execution_group_basic_info, funds, ignore_round_lot=False, spare_provisions=None, use_gross_nav=False)
    Returns a ideal allocation for the given funds to the execution_group considering the quantity in
    FundOrders. No compliance evaluation is performed.
    If ignore_round_lot is True, quantities will not be rounded to the registered instrument's round lot,
    but to the nearest integer.

    If spare_provisions is set, the NAVs will be increased/decreased by the values given for each fund.

    No allocation will be returned for Execution Groups with no associated orders or fund orders.
    A list with these groups ids is returned.

    execution_group_basic_info: {group_id (int) : {'order_index': int}}
    funds: [fund_id (int)]
    ignore_round_lot: boolean
    spare_provisions: {fund_id: decimal}

    returns: {'execution_groups': {execution_group_allocation}, 'messages': [string] or None, 'compliance_limits': [], 'execution_groups_to_calculate': []}
        execution_group_allocation: {group_id (int) : { 'ideal_allocation' : [fund_allocation] }
            fund_allocation: {'fund_id': int,
                              'instrument_id': int,
                              'quantity': Decimal,
                              'delta_quantity': Decimal,
                              'exposure': Decimal,
                              'delta_exposure': Decimal,
                              'strategy_id': int,
                              'order_index': int}
get_default_allocation_rule(implicit_max_funds=None)
    Returns the allocation rule that should be used by default for quick allocation.

    The default rule is one named "Default" or "Padrao". In case there is no such rule, the first N funds
    are returned, where N is given by the 'implicit_max_funds' parameter (defaults to 8).
    Pass 0 to disable the implicit generation feature and return an empty list in case there is no default rule.

    implicit_max_funds: int or None

    returns: {'rule_id': int, 'rule_name': str, 'method': ALLOCATION_METHODS (int), 'fund_ids': [fund_id (int)]}
is_deletable_simple_allocation_chain(allocation_ids, default_if_missing=True)
    Returns whether the specified allocations are simple allocations (ExecutionGroup contains only one allocation)
    that can be deleted with the API delete_simple_allocation_chains().

    allocation_ids: [int]
    default_if_missing: bool  # default: False

    The value for missing allocations is determined by the 'default_if_missing' parameter.

    returns {allocation_id (int): {'can_delete': bool, 'execution_group_id': int or None}
check_open_orders(date=None, rules=None, funds=None, check_executed_qty=False)
    Checks open oders regarding compliance, if the order is not valid, set execution_status
    as pending_compliance_approval send email and cancel order in Bloomberg.

    'date': date or None
    'rules': {'compliance_rule_id': int, 'rule_name': string, 'template': string, 'type': int, 'params': JSON,
                'applicable_funds': [cr_fund],'periods': [object]} or None
    'funds': [int] or None

    returns:  'success': Bool, 'pending_orders': [{'asset', 'side', 'qty', 'price', 'financial', 'fund', 'obs',
                                                      'start_date', 'due_date'}]
get_order_to_allocate(order_ids, orders_info=None)
get_order_info_for_trading(filter_dict, convert_to_string=True)
delete_execution_groups(execution_group_ids)
    Removes from database all execution groups from the list, and its corresponding executions.

    execution_ids: [int]

    returns: {'success': boolean, 'error_msg': string or None}
get_broker_trading_platform_account_codes(broker_ids=None, trading_platform=None, account_codes=None)
add_brokerage_fee_rules(brokerage_fee_rules)
    brokerage_fee_rules: [brokerage_fee_rule]
        brokerage_fee_rule: {
            'id': int or None,
            'markets': [market_id], 'broker_accounts': [account_id],
            'side': int or None,
            'min_daily_value': Decimal or None,
            'fee_fixed': Decimal or None,
            'fee_percent': Decimal or None,
            'minimum_per_trade = Decimal or None,
            'is_active': bool
        }
get_carrying_deals(deal_keys)
    deal_keys: [{broker_id: int, market_id: int, 'fund_id': int}]
    returns: key: {'carrying_brokerage_rate': decimal, 'carrying_broker_id': int} or None
get_brokers(ids=None, tordist_codes=None, name=None, bloomberg_codes=None, fis_codes=None, atg_codes=None, custodians=None)
    Retrieves ids and shallow info on all brokerage firms in the database.
    May be filtered by broker IDs and tordist codes.

    broker_ids: [int] or None
    tordist_codes: [string] or None
    name: string or None

    returns: {broker_id (int): broker}
        broker: {'id': int, 'name': string, 'tordist_code': int, 'custodian_id': int,
                 'country_id': int, 'legal_id': string, 'bic_code': string, 'admin_code': string, 'file_code': string}
get_execution_allocations_for_broker_file(broker_id, date, allowed_market_ids=None, sent_to_broker=None, is_carrying_matching=False)
    Retrieves execution allocation information for allocations file generation.

    broker_id: int
    date: date
    allowed_market_ids: [int] or None
    sent_to_broker: bool or None

    returns: {execution_allocation_id (int): ea}
        ea: {'symbol': string, 'broker_code': int, 'broker_digit': int, 'qty': Decimal, 'price': Decimal,
             'side': EXECUTION_SIDES (int), 'user_code': int, 'client_code': int, 'client_digit': int}
calculate_brokerage_fees(brokerage_keys, execution_allocations=None)
    Calculates brokerage fees using the brokerage fee rules registered.
    Adds the consolidated brokerage fees, as well as the values for all execution allocations for the keys
    given, ie., for each triple market, broker account and execution date.

    brokerage_keys: {'market_id': int, 'broker_account_id': int, 'execution_date': date, 'side': BROKERAGE_FEE_RULE_SIDES}

    returns: default success dictionary
suggest_auto_portfolio_allocation(currency_id, funds, instruments, positions, orders)
    # TODO: (JFrancese) #2189 | Review, document and merge with regular allocation methods.

    Warning: all prices and financial values must be in the main currency_id.
    currency_id: int
    funds: {fund_id: fund}
        fund: {'is_main': bool, 'is_restricted': bool, 'main_cash': decimal}
    instruments: {instrument_id: inst}
        inst: {'price': decimal}
    positions: {instrument_id: ipos}
        ipos: {fund_id: fpos
        fpos: {'quantity': decimal, 'value': decimal}
    orders: {order_index: order}
        order: {'instrument_id': int, 'side': EXECUTION_SIDES (int), 'price': decimal,
                'quantity': decimal, 'main_group_quantity': decimal}

    return: {'ideal_main_exposures': {instrument_id: decimal}, 'quantities_by_order': {order_index: order},
             'positions_by_instrument': {instrument_id: ipos}, 'positions_cash': cpos}
        order: {'total_quantitiy': decimal, 'by_fund': {fund_id: decimal}
        ipos: {fund_id: ifpos}
            ifpos: {'ideal_main_exposure': decimal, 'main_financial': decimal,
                    'ideal_quantity': decimal, 'needed_quantity': decimal}
        cpos: {fund_id: cfpos}
            cfpos: {'ideal_main_exposure': decimal, 'main_financial': decimal}
undo_allocations(execution_group_ids=None, execution_ids=None, order_ids=None, start_date=None, end_date=None, delete_operations=True, compliance_approval_msg=None, is_compliance_rejection=False)
    Removes all allocation groups under the given execution groups. Corresponding Operations are also deleted
    (unless delete_operations=False), undoing all further effects of the allocations.

    Note: delete_operations should only be set to False if this method is being
    called from a code path that deletes operation objects by themselves.

    Note that this is the only way permitted by the system to undo an allocation:
    individual allocations (by fund) in an execution group cannot be undone.

    If the user does not have permission to allocate executions, they will not be able to undo the execution groups,
    and a NoPermissionToAllocateError will be raised.
    However, if the user has permission to check compliance, they will be able to undo the allocations when rejecting
    an allocation through the compliance workflow.

    Additional `start_date` and `end_date` parameters can be used to filter the allocations to be undone to the ones
    with executions between the given dates. This is particularly useful for multi-day orders allocations, so
    allocations outside the range are not affected (for instance, when only the executions from a single day during
    the order lifetime is set to be undone).

    execution_group_ids: [int] or None
    execution_ids: [int] or None
    order_ids: [int] or None
    start_date: date or None
    end_date: date or None
    delete_operations: bool
    compliance_approval_msg: {eg_id (int): compliance_approval_msg (str)} or None
    is_compliance_rejection: bool

    returns: {'success': bool}
get_executions(instrument_id=None, side=None, execution_group_id=None, is_allocated=None, allocation_group_id=None, date=None, ids=None, origins=None, exec_ref_ids=None)
    Retrieves all executions (operations) that satisfy the filtering criteria. This function also
    returns the quantity that still needs allocation.

    instrument_id: int or None
    side: int or None
    execution_group_id: int or None
    allocation_group_id: int or None
    is_allocated: boolean or None
    date: date or None
    ids: [int] or None

    returns: [executions]
    execution: {'execution_id': int, 'trader_id': int, 'broker_id': int, 'broker_name': string, 'quantity': Decimal,
                'unit_value': Decimal, 'quantity_to_allocate': int, 'value': decimal, 'group_id': int,
                'allocation_group_id': int}
send_brokers_allocation_email(date=None, include_only_new=False, broker_ids=None)
    Generates broker allocation file(s) and send it to counterparties by email.
add_exercise_option_executions(option_executions, user_id, strategy_id=None)
    Inserts new executions of option exercise, then allocates them to consolidate the results of each exercise.

    'option_executions': [execution]
        execution: {'intrument_id': int, # ie. the id of the option which was exercised
                    'side': EXECUTION_SIDES (int), # ie. the side of the option exercise
                    'result_side': EXECUTION_SIDES (int) or None, # ie. the side of the result of the exercise
                    'broker_id': int, 'broker_account_id': int or None, 'execution_date': date, 'settlement_date': date,
                    'quantity': int, 'unit_value': decimal, 'account_id': int or None, 'fund_ids': [int] or None}
    'strategy_id': int or None

    returns: default success dictionary + {'execution_group_ids': [int]}
get_allocated_order_suggestion_nav_proportionally(rule, instrument_id, date, quantity_to_allocate, forbidden_funds, navs, fund_ids=None, pl_group_weight=None)
get_open_orders_for_compliance_check(date, skip_order_ids=None, fund_ids=None, executed_quantity_only=False)
    Returns all open orders which should be taken into account when checking compliance of new orders.
    Dont include already allocated quantity.
    If executed_quantity_only is True, use executed and non-allocated quantity instead of full order quantity.

    date: date
    skip_order_ids: [int] or None
    fund_ids: [int] or None
    executed_quantity_only: bool or None (default False)

    returns: {'orders': [order]}
        order: {'order_id': int, 'fund_id': int or None, 'instrument_id': int, 'quantity': Decimal,
                'side': ORDER_SIDES (int), 'price': Decimal, 'limit_price': Decimal or None,
                'exposure': Decimal, 'strategy_id': int or None, 'execution_date': date, 'existing_order': bool}
get_execution_info_for_trading(filter_dict)
build_model_portfolios_before_transactions(date, fund_ids=None, merge_model_portfolio=False, prices=None, exchange_rates=None)
    Builds model portfolios considering fund's portfolio on the given date,
    ignoring any transactions converted in this date.

    date: date
    fund_ids: [int] or None
    prices: {instrument_id (int): Decimal}
    exchange_rate: {instrument_id(int): Decimal}

    returns: {fund_id (int): model}
        model: {'id': None, 'name': str, 'date': date, 'basket_id': int or None, 'fund_id': int, 'assets': [asset]}
            asset: {'instrument_id': int, 'exposure': decimal, 'side': ORDER_SIDES (int) or None,
                    'tolerance_range': Decimal}
get_basic_execution_group_info(execution_group_ids)
    Returns basic information on execution group, i.e. only those directly attache to the EG model,
    without querying for completion status, etc.

    execution_group_ids: [int]

    returns: {id (int): eg}
        eg: {'id': int, 'instrument_id': int, 'side': EXECUTION_SIDES (int),
             'execution_date': date, 'settlement_date': date, 'order_id': int or None, 'modified_on': datetime}
allocate_executions(allocations, user_id=None, check_round_lot=False, instruments_affected_by_compliance=[], return_allocation_ids=False)
    Allocates a list of executions along a list of funds, according to specified values. This function does not
    have any intelligence on what quantity to allocate to each fund (this should have been calculated beforehand
    and informed in the 'allocations' parameter), but it does decide which executions (from the specified
    ExecutionGroups) to allocate to each fund, using an algorithm to make funds' average prices as close as possible.

    If order_id is not None, the allocation group that is created gets assigned to it.

    user_id is provided in order to check if the user has sufficient privileges to override compliance errors.
    If no user user is passed it assumes it *does* have sufficient privileges.

    If origin_instrument_id is set, the operations and provisions created by this allocation will set
    origin_instrument_id as this value.

    'allocations': {execution_group_id (int): allocation}
        allocation: {'funds_allocation': [fund_allocation],
                     'order_id': int or None,
                     'skip_compliance_check': bool or None,  # default: False
                     'origin_instrument_id': int or None,
                     'no_cash_impact': bool or None, # default: False
                     }
            fund_allocation: {'fund_id': int, 'quantity': Decimal, 'account_id': int or None, 'strategy_id': int,
                              'rebate_percent': decimal or None #  used to override brokerage rebate rules,
                              'operation_extra_values': dict or None, 'is_confirmed': bool or None
                              'payment_account_id': int or None # used to override default payment account
                              'basket_id': int or None}
    user_id: int or None

    returns: {execution_group_id (int): allocation}
        allocation: {'allocation_group_id': None or int, 'compliance_errors': *compliance.check_compliance()}
edit_executions(executions)
    Edits executions' information.

    Only information from the Execution model can be edited;
    fields that would require re-grouping the execution to another EG (e.g. instrument or date)
    should be modified using edit_execution_groups().

    Fails if any of the executions has already been allocated.

    executions: [execution]
        execution: {'id': int, 'broker_id': int, 'quantity': Decimal, 'price': Decimal,
                    'execution_source': EXECUTION_SOURCES (int), 'brokerage_fee_gross_value': Decimal or None,
                    'brokerage_fee_rebate_value': Decimal or None, 'emolument_value': Decimal or None,
                    'settlement_fee_value': Decimal or None, 'registration_fee_value': Decimal or None,
                    'currency_id': int or None, 'payment_exchange_rate': Decimal or None,
                    'yield_value': Decimal or None, 'rollover_base_price': Decimal or None}

    returns: default success dictionary
Module forwards (Termos)
get_forward_agreements(ids=None, start_date=None, end_date=None, date_type=None, side=None, broker_ids=None, fund_ids=None, instrument_ids=None, strategy_id=None, show_fully_settled_agreements=None, origin_ids=None, origin_content_type_id=None)
add_forward_agreements(agreements, skip_compliance_check=None)
    Adds forward agreements, generating the executions and operations for the underlying and forward instrument.

    agreements: [agreement]
        agreement: {'instrument_id': int or None, # the underlying instrument
            'forward_instrument_id': int or None, # the forward instrument
            'id': int or None, # present for edition
            'unit_value': decimal, 'rate': decimal, 'issue_date': date, 'due_date': date,
            'broker_id': int, 'fund_id': int, 'settlement_account_id': int, 'payment_account_id': int,
            'side': int (FORWARD_SIDES), 'strategy_id': int or None, 'basket_id': int or None,
            'origin_id': int or None, 'origin_content_type_id': int or None}

    returns default success dictionary +
        {'forward_agreement_ids': [int], 'provision_ids': int, 'execution_ids': int}

    raises ComplianceError
undo_settlements(settlements)
    Undoes the effect of agreement settlements.

    [settlements]
get_forwards_info(ids=None, expiration_date_from=None, expiration_date_to=None, underlying_instrument_ids=None)
    Obtains forwards basic info.

    ids: [int] or None
    expiration_date_to: date or None
    expiration_date_from: date or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'expiration_date': date, 'underlying_instrument_id': int}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
update_values_for_corporate_actions(date, agreements)
    Apply the changes on quantities and base values caused by corporate actions.
    If a settlement is present in the given date, its effects will be applied after.

    date: date
    agreements: {agreement_id (int): agreement_update}
        agreemen_update: {'agreement_id': int, 'unit_value': decimal, 'quantity': decimal}

    returns default success dictionary
add_forwards_settlements(settlements)
    Settles forward agreements, generating the underlying instrument operation

    settlements: {agreement_id: settlement}
        settlement: {'date': date, 'agreement_id': int, 'quantity': decimal or None}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
delete_agreements(agreements)
    Deletes forward agreements and effects
get_forward_instruments_to_fill()
add_forwards_instruments(forwards)
    Adds forwards instruments from instrument manager

    forwards: [forward]
        forward: {'name': string, 'is_monitoring_enabled': boolean, 'market_id': int, 'symbol': string,
                  'currency_id': int, 'issuer_id': int, 'price_divisor': decimal, 'isin_code': string,
                  'underlying_instrument_id': int, 'pricing_rule': PRICING_RULE (int)}
Module funds (Fundos)
get_fund_portfolio_settings(ids=None, is_active=None, is_investment_vehicle=None, daily=None)
    Retrieves funds' settings for portfolio generation.

    ids: [int] or None
    is_active: bool or None
    is_investment_vehicle: bool or None
    daily: bool or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'is_investment_vehicle': bool, 'portfolio_periodicity': PORTFOLIO_PERIODICITIES (int),
               'migration_date': date or None}
get_conversion_rule_redemption_validation_info(ids=None)
    Retrieves redemption information about a ConversionRule.

    Allows optional filtering by a list of ConversionRule IDs.

    ids: [int] or None

    returns: {conversionrule_id (int): conversionrule}
        conversionrule: {'redemption_limit': Decimal, 'redemption_limit_period':int, 'id': int, 'lockup_period': int}
get_all_fund_names(is_active=None, ids=None, is_internal=None, professional_investors_only=None, qualified_investors_only=None)
    Retrieves basic information about all registered funds, including external funds.
    Acceps optionals filters. Returned data is sorted alphabetically.

    is_active: bool or None
    is_internal: bool or None
    ids: [int] or None

    returns: {'funds': [funds]}
        fund: {'id': int, 'name': string, 'legal_id': str, 'legal_name': str, 'currency_id': int, 'is_internal': bool, 'is_active': bool}
get_fund_fees_by_fund(ids, date=None)
    Returns funds information about fund fee rules.

    ids: [int]
    date: Date or None

    returns: {fund_id (int): fund_and_rule}
        fund_and_rule: FundFeeRule.objects.values() results
update_fund_performance_fee_rule(fund_id, rule_id)
    Updates fund's performance fee rule.
    'fund_id': int
    'rule_id': int

    returns: default success dict
get_fund_variation(fund_id, date=datetime.date(2018, 9, 4))
    Get fund variation between two given dates
    :param fund_id
    :param current_date:
    :param compare_date:
    :return: fund_variation
get_funds_by_administrator_code(administrator_codes, values=None)
get_funds(is_active=None, ids=None, name=None, partial_name=None, administrator_ids=None, legal_ids=None, is_fof=None, management_area_ids=None, user_id=None, holiday_types_ids=None, generate_snapshots=None, partial_names=None, partial_names_in_administrator=None, is_managerial=None, qualified_investors_only=None, professional_investors_only=None, admin_codes=None, as_of=None, values=None)
    Retrieves basic information about all internal funds. Acceps optionals filters.
    Returned data is sorted alphabetically.

    is_active: bool or None
    ids: [int] or None
    name: string or None
    partial_name: string or None
    administrator_ids: [int] or None
    legal_ids: [string] or None
    user_id: int, False or None  # if False, does not attempt to obtain the current user
    generate_snapshots: bool or None
    partial_names: [string] or None
    partial_names_in_administrtor: [string] or None
    qualified_investors_only: bool or None
    professional_investors_only: bool or None
    as_of: date, (date,date) or None

    Partial searches are made in an inclusive approach.

    returns: {id (int): fund}
        fund: {'id': int, 'name': string, 'legal_name': str, 'currency_id': int, 'secondary_currency_id': int or None,
                administrator_id': int, 'name_in_administrator': str, 'administrator_code': str, 'legal_id': str}
get_fund_expected_proffitability(fund_id, date)
    Retrieves the FundExpectedProffitability for a given Fund on a given Date

    fund_id: int
    date: Date

    returns: {fund_id: int, date: Date, max_proffitability: Decimal, min_proffitability: Decimal} or None
set_fund_id_in_administrator(administrator_code, id_in_administrator)
    Sets the administrator ID for the fund matched by the given administrator code.

    administrator_code: str
    id_in_administrator: str

    returns: {'success': bool}
get_funds_without_liabilities_control()
    Gets the fund_ids of all funds that have their liabilities control disabled

    returns: [(int) fund_id]
save_disclaimer_by_fund(fund_id=None, disclaimer=None)
get_fund_groups(ids=None, fund_ids=None, types=None)
    Returns details of all Fund Groups.
    ids: [int]
    fund_ids: int or None
    types: [FUND_GROUP_TYPES] or None

    returns: {'fundgroups': [fundgroup]}
    fundgroup: {'id': int, 'name': string, 'type': string}
get_managed_account_fund_ids()
    Gets the fund_ids of all funds that have classification=FUND_CLASSIFICATIONS.managed_account

    returns: [(int) fund_id]
get_reverse_conversion_data(conversion_date, transaction_type, fund_ids)
    Calculates request/payment date and conversion fees for funds, in order to make the desired conversion date match.
    If a fund does not have a simple (D+x) conversion rule, it will not be present in the return data.

    conversion_date: date
    transaction_type: CONVERSION_TRANSACTION_TYPES (int)
    fund_ids: [int]

    returns: {fund_id (int): data}
        data: {'conversion_rule_id': int, 'conversion_rule_name': string,
               'request_date': date, 'conversion_date': date, 'payment_dates': [date] or None,
               'transaction_fee_amount': decimal or None, 'transaction_fee_percent': decimal or None}
get_fund_administrator_data_by_names_in_administrator(partial_administrator_codes=None, partial_names_in_administrator=None, partial_legal_ids=None, admin_ids=None)
    Retrieves fund administrator data, for funds which matches any of the given parameters.
get_fund_default_strategy(fund_ids=None)
    Retrieves each fund's default strategy.

    fund_ids: [int] or None

    returns: {fund_id (int): strategy}
        strategy: {'id': int, 'name': string}
get_base_fund_manager_info(ids=None)
    Retrieves manager information for internal and external funds. Accepts optional filters.

    ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': str, 'manager_id': int, 'manager_name': string, 'manager_short_name': string}
get_base_fund_classifications(ids=None)
    Retrieves market information for internal and external funds. Accepts optional filters.

    ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': string, 'classification': FUND_CLASSIFICATIONS (int), 'is_fof': boolean,
               'legal_entity_type': FUND_LEGAL_ENTITY_TYPES (int) or None  # only for internal funds
              }
make_custom_portfolio_combination(date, fund_ids=None, group_ids=None, shareholder_ids=None, client_ids=None)
    Returns the proportions of each fund in a custom portfolio combination, i.e. how much of each fund should be
    included (a multiplier between 0 and 1) in the portfolio visualization when generating the snapshot for the given
    combination of fund groups, shareholders, etc. If a fund is an allocated fund,
    per-strategy participations are also returned.

    date: date
    fund_ids: [int] or None
    group_ids: [int] or None
    shareholder_ids: [int] or None
    client_ids: [int] or None

    returns: {'name': string, 'currency_id': int or None, 'funds': {fund_id (int): fund}}
        fund: {'id': int, 'name': string, 'multiplier': decimal,
               'by_strategy': {strategy_id (int): multiplier (decimal)} or missing}
get_fund_by_groups(group_ids=None, types=None, fund_ids=None, filter_inner_funds=False, flat=False)
    Returns a dictionary relating all fund groups to their respective fund ids. Allows filtering by group ID.
    Only groups containing accessible funds are returned.

    group_ids: [int] or None
    types: [FUND_GROUP_TYPES (int)] or None
    fund_ids: [int] or None
    filter_inner_funds: bool  # default: False
    flat: bool  # default: False

    The behavior of 'fund_ids' depends on the value of 'filter_inner_funds'. If false (default), the fund IDs will
    be used to filter groups containing one or more of the specified funds, but then all funds of such groups will be
    returned. If true, only the specified funds will be returned.

    returns: {group_id (int): group}
        group: {'group_id': int, 'name': string, 'funds': [fund]}
            fund: {'id': int, 'name': string}

    If flat=True, returns: {'entries': [entry]}  # Excel-compatible
        entry: {'group_id': int, 'group_name': string, 'fund_id': int, 'fund_name': string}
add_conversion_rule(conversion_rule_dicts)
    Inserts new Conversion Rule.

    'conversion_rule_dicts': [conversion_rule_dict]
        conversion_rule_dict: {'legal_id': str, 'full_name': str, 'client_id': int or None}
    returns: default success dictionary
get_fund_names(*args, **kwargs)
    This API is a deprecated version of get_funds() returning a list instead of a smart-dict.
    Prefer using get_funds() instead, as this will be removed in the future.

    Parameters: see get_funds()

    returns: {'funds': [funds]}
    fund: {'id': int, 'name': string, 'legal_name': str, 'currency_id': int, 'administrator_id': int
           'name_in_administrator': str}
get_active_status(fund_ids)
    True if a fund or a list of funds is active

    fund_ids : [int]

    returns: { int : bool }
get_fund_administrator_data(ids=None, administrator_ids=None, administrator_codes=None, ids_in_administrator=None, names_in_administrator=None, legal_ids=None, isin_codes=None, partial_names_in_administrator=None, partial_administrator_codes=None, partial_legal_ids=None, liabilities_administrator_ids=None, BR_names_in_administrator=None, BR_codes_in_administrator=None)
    Retrieves administrator data about internal funds. Allows optional filters.

    ids: [int] or None
    administrator_ids: [int] or None
    administrator_codes: [int] or None
    ids_in_administrator: [int] or None
    names_in_administrator: [str] or None
    legal_ids: [string] or None
    isin_codes: [string] or None
    partial_names_in_administrator: [string] or None
    partial_administrator_codes: [string] or None
    partial_legal_ids: [string] or None
    liabilities_administrator_ids: [string] or None
    BR_names_in_administrator: [str] or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': str, 'legal_id': string, 'isin_code': str, 'cblc_code': str,
               'administrator_code': str, 'id_in_administrator': str, 'liabilities_id_in_administrator': str or None,
               'name_in_administrator': str, 'administrator_id': int, 'administrator_name': string,
               'administrator_template': ADMINISTRATOR_TEMPLATES (int), 'integration_module': str or None,
               'administrator_parameters': [admin_param], 'uses_d_minus_one_nav_for_compliance': boolean,
               'can_export_operations_on_unofficial_dates': bool, 'legal_name': str,
               'BR_name_in_administrator': str, 'BR_code_in_administrator': str, }
        }
            admin_param: {'key': ADMINISTRATOR_PARAMETER_KEYS (int), 'value': str}
get_allocated_funds(ids=None, is_active=None, check_user_permissions=False)
    Returns funds that use allocated liabilities.

    ids: [int] or None
    is_active: bool or None
    check_user_permissions: bool  # default: False

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': string, 'min_pnl_date': date}
add_fund_fee_rule_ranges(fund_fee_rule_id, fund_fee_rule_ranges)
    Adds fund fee rule ranges to an existing fund fee rule in batch.

    fund_fee_rule_id: int
    fund_fee_rule_ranges: [fund_fee_rule_range]
        fund_fee_rule_range: {'rule_id': int, 'minimum_base_value': Decimal, 'yearly_rate': Decimal,
                            'fixed_fee_value': Decimal, 'minimum_fee_value': Decimal,
                    }
get_fund_by_administrators(admin_templates, values=None, fund_values=None)
    Obtains basic information for base funds of a certain administrator.
    admin_ids: [ADMINISTRATOR_TEMPLATES]

    returns: {base_fund_id (int): info}
        info: {'id', 'name', 'is_active', 'is_internal', 'classification', 'is_fof', 'legal_id', 'legal_name',
               'isin_code', 'start_date', 'external_start_date', 'manager_id', 'market_id', 'currency_id',
               'holiday_type_id', 'min_balance', 'min_initial_subscription', 'min_additional_subscription',
               'decimal_places_nav', 'decimal_places_navps', 'decimal_places_shares', 'decimal_places_provision',
               'rounding_rule', 'subscription_limit_time', 'redemption_limit_time', 'bloomberg_ticker'} or *values
get_base_fund_by_name(name)
    Retrieves internal/external fund by name

    name: string

    returns: {'id': int}
add_funds_group(group_name, funds, type)
    Create a fund group.

    group_name: string
    funds: {id (int): fund}
        fund: {'id': int, 'name': string, 'legal_name': str, 'currency_id': int, 'secondary_currency_id': int or None,
                administrator_id': int, 'name_in_administrator': str, 'administrator_code': str, 'legal_id': str}
    type = FUND_GROUP_TYPES (int)
get_base_fund_attribution_currency_info(ids=None)
    Retrieves currency information for performance attribution calculation.

    ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': string, 'attribution_currencies': [int]}
get_basefund_benchmarks(fund_ids=None, start_date=None, end_date=None)
    Returns base funds' benchmarks. If start and end dates are also supplied, the variations are returned as well.

    fund_ids: [int]
    start_date: date or None
    end_date: date or None

    return: {fund_id (int): [benchmark]}
        benchmark: {'benchmark_id': int or None, 'benchmark_name': string, 'variation': decimal or None}
get_base_fund_by_legal_id(legal_ids=None)
    Retrieves internal/external funds' identification information.

    legal_ids: [string] or None

    returns: {legal_id: fund}
        fund: {'id': int, 'legal_id': string or None}
get_fund_enable_lookthrough(ids=None)
    Returns information about permission for expansion on full lookthrough

    ids: [int] or None

    returns: {fund_id (int): {'enable_full_lookthrough': boolean}}
get_base_fund_info_by_sti_code(sti_codes, internal=None, external=None, is_active=None)
    Retreves fund information by the given sti codes.

    sti_codes: [int]
    internal: boolean
    external: boolean
    is_active: boolean

    returns {'external_funds': {id (int): fund}, 'internal_funds': {id (int): fund}}
        fund: {'id': int, 'name': string}
update_fund_adm_fee_data(fund_id, rule_id, maximum_administration_fee=None)
    Replaces current administration fee rule associated to a fund (if any)
    and sets the maximum_administration_fee attribute.
    'fund_id': int
    'rule_id': int
    'maximum_administration_fee': str or None

    returns: default success dict
get_base_fund_identification_info(ids=None)
    Retrieves internal/external funds' identification information.

    ids: [int] or None

    returns: {id: fund}
        fund: {'id': int, 'legal_id': string or None, 'isin_code': string or None}
import_navps_approval_thresholds(filename, contents)
    Imports a xls file containing a description of FundExpectedProffitability and creates them
connect_funt_to_conversion_rule(fund_ids=[], conversion_rule_id=[])
    Associate a fund with a connection rule

    fund_ids [int]
    conversion_rule_id [int]
    returns: default success dictionary
get_conversion_data(base_fund_id, transaction_type, request_date, conversion_rule_id, mirrored_base_fund_ids=None, conversion_date=None)
    Calculates conversion dates and fees for one fund, given a request date and conversion rule.
    Optionally calculates reverse conversion information for additional funds, determining the
    request date for each of them in such a way that all funds' conversion dates will be the same.

    base_fund_id: int
    transaction_type: CONVERSION_TRANSACTION_TYPES (int)
    request_date: date
    conversion_rule_id: int
    mirrored_base_fund_ids: [int] or None
    conversion_date: date or None # if set, all calculations of conversion_dates are overriden

    returns: {'conversion_rule_id': int, 'conversion_rule_name': string,
              'request_date': date, 'conversion_date': date, 'payment_dates': [date] or None,
              'transaction_fee_amount': decimal or None, 'transaction_fee_percent': decimal or None,
              'mirrored_funds': {fund_id (int): mirror_data}, 'unavailable_mirrored_fund_ids: [int],
              'pay_installments_on_same_conversion_date': boolean}
        mirror_data: {'conversion_rule_id': int, 'conversion_rule_name': string,
                      'request_date': date, 'conversion_date': date, 'payment_dates': [date] or None,
                      'transaction_fee_amount': decimal or None, 'transaction_fee_percent': decimal or None}
get_conversion_rule_basic_info(fund_ids)
    Obtains shallow information of the conversion rules for the given funds.
    The lists are ordered such that rules without transaction fees always comes first.

    fund_ids:[fund_id]
        fund_id: int

    returns: {fund_id: {'subscription': [rule], 'redemption': [rule]}}
        rule: {'id': int, 'name': string, 'template': CONVERSION_RULE_TEMPLATES,
               'conversion_days': int, 'conversion_days_is_business_only': boolean,
               'payment_days': int, 'has_fee': bool, 'periodicity_description': string}
get_fund_performance_fee_rules(ids=None, date=None)
    Returns funds information about performance fee rules.

    ids: [int]

    returns: {fund_id (int): fund_and_rule}
        fund_and_rule: Fund.objects.values() results
                       + {'currency_exchange_sources': [int], 'strategies': {strategy_id (int): strategy},
                          'is_allocated': bool, 'pfee_rule': pfee_rule}
        pfee_rule: PerformanceFeeRule.objects.values() results + {'rule_period': {'start_date': date. 'end_date': date},
                                                                  'last_period': {'start_date': date. 'end_date': date}}
        strategy: {'id': int, 'accounts_for_performance': bool}
get_base_fund_info(ids=None, is_active=None, is_internal=None, classifications=None, values=None, exclude_fund_ids=None)
    Obtains basic information for base funds.
    Optional filters are available.
    Optionally a 'values' param can be passed to filter the fields that the this method returns. This is good for
    optimization purposes. If no values is passed, all the fields from BaseFund will be retrieved.

    ids: [int] or None
    is_active: bool or None
    is_internal: bool or None
    classifications: [FUND_CLASSIFICATIONS (int)] or None
    values: [string] or None
    exclude_fund_ids: [int] or None

    returns: {base_fund_id (int): info}
        info: {'id', 'name', 'is_active', 'is_internal', 'classification', 'is_fof', 'legal_id', 'legal_name',
               'isin_code', 'start_date', 'external_start_date', 'manager_id', 'market_id', 'currency_id',
               'holiday_type_id', 'min_balance', 'min_initial_subscription', 'min_additional_subscription',
               'decimal_places_nav', 'decimal_places_navps', 'decimal_places_shares', 'decimal_places_provision',
               'rounding_rule', 'subscription_limit_time', 'redemption_limit_time', 'bloomberg_ticker'} or *values
get_conversion_rule_info(ids=None)
    Retrieves conversion information about a ConversionRule.

    Allows optional filtering by a list of ConversionRule IDs.

    ids: [int] or None

    returns: {conversionrule_id (int): conversionrule}
        conversionrule: {'conversion_days': int, 'name':str, 'id': int, 'fee_amount': decimal or None, 'fee_percent': decimal or None}
get_available_fund_groups(types=None)
before_snapshot_generation(date, fund_ids, **kwargs)
get_content_type_for_performance_fee(date=None, fund_ids=None)
    Returns the content type ID for performance fee provisions calculated by the system.

    If 'date' is set, the next FundPerformanceFeeRule, grouped by funds and filtered by 'fund_ids', if set,
    will be returned. This is used to check if a provision corresponds to the same period as date.

    returns: {'id': int, 'origins': [origins] or None}
        origins: {'id': int, 'fund_id': int, 'settlement_month': date}
get_fund_fee_rules(category_ids=None, provisioning_types=None)
import_funds_xls(filename, contents)
    Imports and processes a file in a generic format containing funds.

    'filename': string
    'contents': string

    returns: default success dictionary
             + {'file_id': int, 'date': date or None}
get_funds_by_allocation_group(fund_ids=None, group_ids=None, flat=False)
    Obtains information on allocation groups (for Ideal Portfolio allocation).

    fund_ids: [int] or None
    group_ids: [int] or None

    returns: {group_id (int): group}
        group: {'group_id': int, 'name': str, 'is_main': bool or missing, 'is_restricted': bool or missing,
                'fund_ids': [int]}

    If flat=True, returns: {'funds': [fund]}
        fund: {'group_id': int, 'name': str, 'is_main': bool or missing, 'is_restricted': bool or missing,
               'fund_id': int}
get_fund_decimal_places(ids=None, short=False)
    Retrieves funds decimal places information from internal and external funds.

    ids: [int] or None
    short: bool or None  # default: False

    returns: {id: fund}
        # if short=False (default)
        fund: {'id': int, 'decimal_places_nav': int, 'decimal_places_navps': int, 'decimal_places_shares': int,
               'decimal_places_provision': int, 'rounding_rule': ROUNDING_RULES (int),
               'rounding': Decimal rounding constant (str)}
        # if short=True
        fund: {'id': int, 'nav': int, 'navps': int, 'shares': int, 'provision': int,
               'rounding_rule': ROUNDING_RULES (int), 'rounding': Decimal rounding constant (str)}
update_fund_conversion_rules(fund_id, rule_ids)
    Replaces current conversion rules associated to a fund (if any)
    with new conversion rules passed as parameters.
    'fund_id': int
    'rule_ids': [int]

    returns: default success dict
get_managed_funds(ids=None, include_inactive=False, as_of=None)
    Retrieves all funds that the current user has access to.

    ids: [int] or None
    include_inactive: bool
    as_of: date, (date,date) or None

    returns: [fund]
        fund: {'id': int, 'name': str, 'name_in_administrator': str or None}
get_performance_fee_rules()
get_dates_intervals_from_date(initial_date, fund_id)
get_administrators(ids=None, templates=None, names=None)
    Retrieves administrator information. Allows optional filters.

    ids: [int] or None
    templates: [ADMINISTRATOR_TEMPLATES (int)] or None

    returns: {administrator_id (int): administrator}
        administrator: {'id': int, 'name': str, 'template': ADMINISTRATOR_TEMPLATES (int),
                        'integration_module': string or None}
calculate_fund_fees(date, fund_ids=None, rule_ids=None)
    Calculates fees accordingly with the rule parameters.

    date: date
    rule_ids: [int] or None
    fund_ids: [int] or None

    returns: {'success': boolean}
get_fund_start_date(fund_ids)
add_funds_group_membership(fund, group, is_active)
    Create fund group membership

     fund: {id (int): fund}
        fund: {'id': int, 'name': string, 'legal_name': str, 'currency_id': int, 'secondary_currency_id': int or None,
                administrator_id': int, 'name_in_administrator': str, 'administrator_code': str, 'legal_id': str}
get_money_market_funds(ids=None)
    Returns external funds which are money-market funds.
    Accepts optional filters.

    returns: {fund_id (int): fund}
        fund: {'days_for_average_maturity': int, 'id': int}
get_fund_release_mail_list(ids=None)
    Retrieves users that must be warned when the portfolio for a day is released.

    ids: [int] or None

    returns: {fund_id (int) : [user_ids]}
        user_ids : [int]
get_strategies_by_fund(fund_ids=None, include_inactive=False, return_all_if_empty=True, fund_as_dict=False, is_overnight_default=None, is_money_market_default=None)
    Retrieves a list of strategies associated to each fund.

    fund_ids: [int] or None
    include_inactive: bool  # default: False
    return_all_if_empty: bool  # default: True
    fund_as_dict: bool  # default: False

    returns: {fund_id (int): fund}
        fund: [strategy] or {strategy_id (int): strategy}  # if fund_as_dict = False or True, respectively
        strategy: {'id': int, 'name': string, 'is_active': bool or None, 'is_default': bool or None,
                   'replacement_id': int or None, 'replacement_type': STRATEGY_REPLACEMENT_TYPES (int) or None,
                   'does_not_account_for_participation': bool or None, 'is_overnight_default': bool or None,
                    'is_money_market_default': bool or None }

    If 'return_all_if_empty' is True and 'fund_ids' is not None, all strategies will be returned for funds
    without any matching strategy association.

    Bools are not returned when 'false' to avoid generating very large response dicts when there are many
    funds/strategies. If 'include_inactive' is False, then 'is_active' is also not returned
    (because it is necessarily true for all entries).
add_fund_fee_rule_details(fund_id, fund_fee_rule_id, start_date, end_date)
    Associate a fund fee rule to a fund.

    fund_id: int
    fund_fee_rule_id: int
    start_date: date
    end_date: date
get_fund_adm_fee_data(fund_id)
    Gets administration fee rule associated to a fund (if any)
    and its maximum_administration_fee attribute.
    'fund_id': int
    'rule_id': int
    'maximum_administration_fee': str or None

    returns: {'fund_id': int, 'rule_id': int
    'maximum_administration_fee': str or None}
get_base_fund_currency_info(ids=None, date=None)
    Retrieves currency and exchange information for internal and external funds. Accepts optional filters.

    ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': string, 'currency_id': int, 'currency_exchange_source_ids': [int]}
add_fund_fee_rule(fee_rules)
    Adds fund fee rules in batch.

    fee_rules: [fee_rule]
        fee_rule: {'rule_name': string, 'is_active': bool, 'currency': int or None, 'custodian': int or None,
                    'provisioning_type': PROVISIONING_TYPES (int), 'periodicity': int, 'base_month': date or None,
                    'regression_is_simple_interest': bool, 'regression_days_in_year': int, 'provisioning_start_days': int,
                    'provisioning_start_days': int, 'provisioning_business_days_only': bool, 'settlement_days': int,
                    'settlement_days_is_business_only': bool, 'base_date_type': FEE_RULE_BASE_DATE_TYPES_FOR_USER_SELECTION (int),
                    'days_for_base_date': int, 'base_value_type': FEE_RULE_BASE_VALUE_TYPES (int), 'days_for_base_value_average': int,
                    'provision_category': PROVISION_CATEGORIES (int), 'compounding': COMPOUNDING_FREQUENCIES (int)
                    }

    returns: {'fund_fee_rule_ids': [int]}
get_fund_disclaimer(ids)
    Retrieves disclaimer information for the given funds.

    ids: [int]

    returns: {fund_id (int): fund}
        fund: {'id': int, 'disclaimer': string}
get_base_fund_market_info(ids=None, get_country=None)
    Retrieves market information for internal and external funds. Accepts optional filters.
    If get_country is True, the country is also returned.

    ids: [int] or None
    is_active: bool or None
    get_country: bool or None  # default: False

    returns: {fund_id (int): fund}
        fund: {'id': int, 'market_id': int, 'currency_id': int, 'holiday_type_id': int,
               'country_id': int or missing}
get_fund_liabilities_settings(ids=None, liabilities_modes=None, is_liabilities_enabled=None, is_allocated=None, is_active=None, is_fof=None, check_user_permissions=False, requires_capital_commitment=None, alert_on_approaching_redemptions=None, as_of=None)
    Retrieves funds' settings regarding liabilities. Accepts optional filters.

    ids: [int] or None
    liabilities_mode: [LIABILITIES_MODES (int)] or None
    is_liabilities_enabled: bool or None  # ignored if liabilities_mode is present
    is_allocated: bool or None  # ignored if liabilities_mode is present
    is_active: bool or None
    is_fof: bool or None
    check_user_permissions: bool  # default: False
    requires_capital_commitment: bool or None
    alert_on_approaching_redemptions: bool or None
    as_of: date, (date,date) or None

    returns: {id: fund}
        fund: {'id': int, 'name': str, 'administrator_id': int, 'liabilities_mode': LIABILITIES_MODES (int),
               'is_allocated': bool, 'requires_capital_commitment': boolean, 'transfer_full_hwm': boolean or None,
               'dividends_passthrough': boolean}
get_management_areas(ids=None)
    Retrieves management areas information. Allows optional filters.

    ids: [int] or None

    returns: {management_area_id (int): management_area}
        management_area: {'id': int, 'name': str}
get_investment_vehicle_info()
    Returns a dictionary by fund_id with investment vehicle information.

    Returns: {fund_id (int): market_and_code} or None
        market_and_code: {market_id (int): vehicle_fund_code (string)}
get_content_type_for_fund_fees()
    Returns the content type for provisions generated by fund fee rules.

    returns {'id': int}
Module fund_assets (Instrumentos de Fundos)
get_funds_by_instruments(instrument_ids=None, is_allocated=None, default_none=True)
    Retrieves the fund_id for each given instrument, keyed by instrument ID.
    Returned values are None for specified instrument IDs with no associated fund, unless 'default_none' is False..

    If a list of instrument IDs is not specified, all registered fund-instruments are returned.

    returns: {instrument_id (int): fund_id (int) or None}
before_snapshot_generation(date, fund_ids, **kwargs)
    Snapshot generation hook.

    'date': date
    'fund_ids': [int]

    returns: {'success': bool}
add_operations(operations, **kwargs)
    Saves a group of fund asset operations to the database.

    operations: [operation]
        operation: {'fund_id': int, 'instrument_id': int, 'strategy_id': int, 'type': FUND_OPERATION_TYPES (int),
                    'request_date': date, 'conversion_date': date, 'settlement_date': date,
                    'shares': decimal, 'price': decimal, 'financial_value': decimal, 'percentage': decimal or None,
                    'is_converted': bool or None, 'account_id': int or None, 'exchange_rate': decimal or None,
                    'origin_id': int or None, 'origin_content_type_id': int or None}
    **kwargs: accepts all named parameters of API portfolio.add_operations()

    Use is_converted=True for operations that are created with definitive values and should not be changed if
    the instrument's price changes.

    Important: if 'account_id' is in a currency different from the instrument's, it is assumed to be the
    PAYMENT account. In this case, 'price' and 'financial_value' must be in the account's currency.
    The field 'exchange_rate' can only be specified if the account is also specified, or an Exception will be raised.
    'exchange_rate' is expected to be in the direction: from the account's currecny to the instrument's currency.

    returns: {'success': bool, 'operation_ids': [int]}
unconvert_operations_by_id(operation_ids)
    Marks the indicated operations as not having been converted.

    operation_ids: [int]

    returns: {'success': bool, 'error_msg': string or None}
convert_operations_by_id(operations)
    Updates the given fund operations' price values and marks the operations as converted, so no further changes
    will be made when the snapshot is recalculated.

    operations: {operation_id (int): operation}
        operation: {'price': Decimal}

    returns: {'success': bool, 'error_msg': string or None}
add_portfolio_transfers(transfers, **kwargs)
    For now, this is just a wrapper around Portfolio's add_portfolio_transfers API.

    This allows an instrument to change funds, accounts and/or strategies.

    transfers: [transfer]
        transfer: {'instrument_id': int, 'request_type': REQUEST_TYPES (int), 'value': Decimal,
                   'quantity': Decimal, 'price': Decimal,  'description': string or None,
                   'request_date': date, 'conversion_date': date, 'settlement_date': date,
                   'fund_from_id': int, 'fund_to_id': int,
                   'account_from_id': int, 'account_to_id': int, 'strategy_from_id': int, 'strategy_to_id': int}
    **kwargs: accepts all named parameters of API portfolio.add_portfolio_transfers()

    Note: only 'conversion_date' is currently being used (as the sole 'date' field in portfolio transfers).

    returns: {'success': bool, 'transfer_ids': [int]}
get_allocated_fund_instrument_ids(instrument_ids=None, fund_ids=None)
    Returns the instrument IDs associated with allocated funds. Accepts optional filtering by instrument or fund ID.

    instrument_ids: [int] or None
    fund_ids: [int] or None

    returns: [int]
get_instruments_by_funds(fund_ids=None, is_internal=None, is_allocated=None, default_none=True)
    Retrieves the instrument_id for each given fund, keyed by fund ID.
    Returned values are None for specified fund IDs with no associated instrument, unless 'default_none' is False.

    If a list of fund IDs is not specified, all registered fund-instruments are returned.

    returns: {fund_id (int): instrument_id (int) or None}
get_shareholders_by_funds(fund_ids=None, is_allocated=None, default_none=True)
    Retrieves the shareholder_id for each given fund, keyed by fund ID.
    Returned values are None for specified fund IDs with no associated shareholder, unless 'default_none' is False..

    If a list of fund IDs is not specified, all registered fund-shareholders are returned.

    fund_ids: [int] or None

    returns: {fund_id (int): shareholder_id (int) or None}
get_money_market_instruments(instrument_ids=None, fund_ids=None)
    Returns the instrument IDs of money market funds.
    Accepts optional filters.

    instrument_ids = [int] or None
    fund_ids = [int] or None

    returns: {'instrument_ids': [int]}
update_conversion_preview_for_date(date, fund_ids)
    Updates non-converted fund operations' values to reflect their current conversion information.

    'date': date,
    'fund_ids': [int]

    returns: {'success': bool, 'error_msg': string or None}
get_shareholders_info(shareholder_ids=None, fund_ids=None, is_active=None)
    Retrieves shareholder info grouped by shareholder.
    Optional filters are available.

    shareholder_ids: [int] or None
    fund_ids: [int] or None
    is_active: bool or None

    returns: {shareholder_id (int): shareholder}
        shareholder: {'id': int, 'fund_id': int, 'fund_name': string, full_name': string}
get_fund_assets_info(ids=None, is_active=None)
    Obtains basic information for fund_assets instruments.

    ids: [int]
    is_actives: bool or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'base_fund_id': int, 'name': string, 'base_fund_classification': FUND_CLASSIFICATIONS(int)}
get_operations(ids=None, start_date=None, end_date=None, date_type=None, fund_ids=None, instrument_ids=None, types=None, strategy_id=None, exclude_money_market=False, is_converted=None)
    Returns fund operations matching the given criteria.
    Date searching is performed on the conversion date only (for now).

    ids: [int] or None
    start_date: date or None
    end_date: date or None
    date_type: TRANSACTION_FILTER_DATE_TYPES (int)
    fund_ids: [int] or None
    instrument_ids: [int] or None
    strategy_id: int or None
    types: [FUND_OPERATION_TYPES (int)] or None
    exclude_money_market: bool
    is_converted: bool or None

    returns: {id (int): operation}
        operation: {'id': int, 'fund_id': int, 'instrument_id': int, 'is_confirmed': bool, 'strategy_id': int, 'account_id': int,
                    'type': FUND_OPERATION_TYPES (int), 'type_display': string, 'is_converted': bool,
                    'request_date': date or None, 'conversion_date': date, 'settlement_date': date,
                    'quantity': Decimal, 'price': Decimal, 'financial_value': Decimal, 'percentage': Decimal or None,
                    'requested_net_value': Decimal or None, 'sent_to_administrator': bool, 'price_multiplier': Decimal,
                    'fund_name': string, 'instrument_name': string, 'strategy_name': string, 'account_name': string,
                    'decimal_places_price': int, 'decimal_places_quantity': int}
get_funds_by_shareholders(shareholder_ids=None, is_allocated=None, default_none=True)
    Retrieves the fund_id for each given shareholder, keyed by shareholder ID.
    Returned values are None for specified shareholder IDs with no associated fund, unless 'default_none' is False..

    If a list of shareholder IDs is not specified, all registered fund-shareholders are returned.

    shareholder_ids: [int] or None

    returns: {shareholder_id (int): fund_id (int) or None}
Module futures (Futuros)
before_snapshot_generation(date, fund_ids, **kwargs)
get_future_instruments_to_fill()
add_future_instruments(future_instruments)
    Inserts new future instruments.

    'future_instruments': [future_instrument]
        future_instrument: {'name': str, 'symbol': str, 'market_id': int, 'isin_code': str, 'issuer_id': int
                            'maturity_date': date, 'underlying_instrument_id': int, 'price_divisor': int or None,
                            'settlement_currency_id', 'settlement_currency_source_id': int or None,
                            'morningstar_ticker': str or None, 'is_morningstar_monitoring_enabled': bool or None,
                            'daily_settlement_rule': DAILY_SETTLEMENT_RULES, 'risk_pricing_rule': FUTURES_RISK_PRINCING_FORMULA
                            'face_value': decimal}
    returns: default success dictionary
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_content_type_for_future_settlement()
    Returns the content type ID for the FutureSettlement model.

    returns: {'id': int}
get_currency_futures(ids=None, min_date=None, max_date=None)
    Retrieves all futures whose underlying instrument is a currency and has expiration date between provided dates.

    ids: [int] or None
    min_date: date or None
    max_date: date or None

    returns: [int]
calculate_future_prices(instrument_ids=None, fund_ids=None, date=None)
    Calculates future prices for long futures.

    instrument_ids: [int] or None
    date: date or None

    Returns: {instrument_id (int): {'success': bool, 'error_message': string}}
get_short_future_ids(u_inst_ids, date)
    Gets short future id by underlying instrument id, based on the given date.
    Returns the first future from the given underlying instrument with maturity date equal or greater than date.

    u_inst_ids: [int]
    date: date

    returns: {underlying_instrument_id (int): short_future_id (int)}
calculate_daily_settlement(date, fund_ids)
    Recalculates the daily settlement provisions for the given funds in the given date.

    date: date
    fund_ids: [int]

    returns: {'success': boolean, 'log': string or None}
calculate_exposure_prices(prices_dict)
    Gets the current price of the instruments in the input list used to calculate exposure.
    The returned value is always 'per unit', regardless of the existence of a multiplier.

    prices_dict: dictionary containing prices data

    returns: {instrument_id (int): price (Decimal) or None}
get_details_for_portfolio(date, instrument_id_list)
    Returns the portfolio column names and values that are specific to this module. The group
    name is hard-coded and is returned on the first level of the output.

    'date': date
    'instrument_id_list': [int]

    returns: {'group_display_name': string, 'columns': [columns], 'extra_data': {extra_data},
              'tooltips': {tooltips}, 'buttons': {buttons}}
    column: {'display_name': string, 'format': formats, 'column_identifier': string}
    extra_data: {'column_identifier': any, ...} # 'any' means it depends on the column
    tooltips: {'column_identifier': string, ...}
    buttons: {'column_identifier': URL, ...}
get_future_settlements_info(ids)
    Retrieves information related to the provided settlements

    ids: [int] or None

    returns: {settlement_id (int): values} or {}
       values: {'id': int, 'future_instrument_id': int, 'fund_id': int, 'date': date}
recalculate_prices(date)
    Recalculates prices for the given date, for all futures contained in any fund's portfolio.
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
get_daily_settlement_payment_date(date, instrument_ids)
    Retrieves the payment date for the given instruments' settlement provisions.

    date: date
    instrument_ids: [int]

    returns: {instrument_id: date}
get_futures_info(ids=None, maturity_date_from=None, maturity_date_to=None, underlying_instrument_types=None, daily_settlement_rule=None, underlying_instrument_ids=None)
    Obtains basic information for future instruments.
    Accepts optional filters.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    maturity_date_from: date or None
    maturity_date_to: date or None
    underlying_instrument_types = [int] or None
    underlying_instrument_ids = [int] or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'maturity_date': date, 'underlying_instrument_id': int, 'underlying_instrument_name': unicode, 'underlying_factor': float,
               'name': string or None, 'currency_id': int or None,
               'settlement_currency_id': int or None, 'settlement_currency_source': int or None, 'market_id': int,
               'market_price_max_age': int or None},
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
Module rollover (Instrumentos de Rolagem)
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_rollover_info(ids=None, sold_instrument_ids=None, bought_instrument_ids=None)
    Obtains rollover instruments' basic info.

    ids: [int] or None
    sold_instrument_ids: [int] or None
    bought_instrument_ids: [int] or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'sold_instrument_id': int, 'bought_instrument_id': int}
get_rollover_instruments_to_fill()
add_rollover_instruments(rollover_instruments)
    Inserts new rollover instruments.

    'rollover_instruments': [rollover_instrument]
        future_instrument: {'name': str, 'symbol': str, 'market_id': int, 'isin_code': str, 'issuer_id': int
                            'sold_instrument_id': int,
                            'bought_instrument_id': int, 'price_divisor': int or None,}
    returns: default success dictionary
Module indices (ndices)
add_index_prices(*args, **kwargs)
get_indices_info(ids=None, value_types=None, has_previews=None, reference_dates=None, anbima_code=None, values=None, underlying_index_ids=None, auto_compute_prices=None, show_in_portfolios_overview_report=None, index_types=None)
    Retrieves basic information for each input index id. Optional filters are available.

    If reference_dates are set, information about prices for the period set in Index.reference_period will
    be retrieved.

    ids: [int] or None
    types: [int] or None
    has_previews: boolean or None
    reference_dates = [date]
    anbima_code = String or none
    values = [string] # Index fields
    underlying_index_ids: [int] or None
    auto_compute_prices: boolean or None
    index_types: [INDEX_TYPES] or None

    returns: {index_id (int): index,
              'base_prices': decimal} # if reference_dates is set
        index: {'id': int, 'name': string, 'has_previews': boolean, 'reference_period': int,
                'value_type': VALUE_TYPES (int), 'regression_days': int or None,
                'regression_days_is_simple_interest': boolean or None, 'type': int,
                'market_id': int, 'regression_days_is_business_only': bool or None,
                'multiplier': decimal, 'additional_hurdle': decimal or None,
                'underlying_index_id': int or None,
                'auto_compute_prices': bool, 'show_in_portfolios_overview_report': bool,
                'auto_compute_prices_start_date': date or None}
DEPRECATED_get_index_variations(params)
    Calculates index variations for multiple date pairs and/or indices.

    params: [param]
        param: {'index_id': int, 'administrator_id': int or None, 'start_date': date, 'end_date': date,
                'to_currency_id': int or None, 'preferred_source_ids': [int] or None}

    returns: {'items': [item]}
        item:  {'index_id': int, 'start_date': date, 'end_date': date, 'variation': decimal}
prepare_indexes_prices_based_on_underlying(indexes_info)
    Prepares prices to create/update for compound indices based on the price
    of the underlying index.

    Used for:
        * Indices creation (model save method)
        * Indices update with recalculation

    indexes_info: {index_id : index_info (Index model to dict)}

    returns: [price_to_add]
        price_to_add: {
            'date': date,
            'instrument_id': index_id (int),
            'nav_unit_value': Decimal,
            'extra_values': {'is_preview': True},
        }
get_benchmark_variations(underlying_index_prices, regression_is_simple_interest, regression_days_is_business_only, market_id, benchmark_offset)
    Get daily benchmark variation considering the value for
    benchmark_variation_date_offset in the index form.

    Used for:
        * Indices creation (model save method)
        * Indices update with recalculation

    underlying_index_prices: [Price dict]
    regression_is_simple_interest: bool
    regression_days_is_business_only: bool
    market_id: int
    benchmark_offset: int

    returns {date: variation (Decimal)}
get_underlying_index_prices(underlying_index_id, auto_compute_prices_start_date, regression_days_is_business_only, market_id, regression_is_simple_interest, benchmark_variation_date_offset)
    Gets price for underlying index considering the value for
    benchmark_variation_date_offset in the index form.

    Used for:
        * Indices creation (model save method)
        * Indices update with recalculation

    underlying_index_id: int
    auto_compute_prices_start_date: date
    regression_days_is_business_only: bool
    market_id: int
    regression_is_simple_interest: bool
    benchmark_variation_date_offset: int

    returns: [price]
        price: Price dict
add_index_prices_from_bloomberg_price_monitoring(prices, date=None, price_source=None)
    This is a wrapper around add_index_prices which parses the parameters from JSON formats.
    add_index_prices is called asynchronously to allow transaction management.

    prices: see add_index_prices # values here are strings, which will be converted

    returns: {}
Module lending (Aluguel de Aes)
get_fund_asset_information(quantity, side, allocation_type, initial_data=None, fund_ids=None, date=None, instrument_id=None)
        Obtains the fund asset information to generate the lending allocation suggestion. Created to avoid the code replication before calling the lending.get_allocation_suggestions function

    quantity: Decimal # total quantity to be allocated
    side: int (LENDING_SIDES)
    allocation_type: int (LENDING_ALLOCATION_TYPE)
    initial_data: [fund_assets] or None
    fund_ids: [int]
    date = Date
    instrument_id: int

    Returns [fund_assets]
        fund_assets:
            {
              'instrument_id': int,
              'underlying_quantity': Decimal,
              'available_underlying_quantity': Decimal,
              'lending_quantity': Decimal,
              'lent_quantity': Decimal,
              'fund_id': int,
              'price': Decimal,
              'quantity': Decimal
            }
get_agreements_initial_base_value(agreement_ids)
get_lending_market_data(date, instrument_ids=None, accept_older=True)
    Retrieves lending market data information. Accepts optional filters.
    If accept_older is True, gets the latest available data for each instrument.

    'date': date or None
    'instrument_ids': [int] or None
    'accept_older': bool (default: True)

    returns: {instrument_id (int): md}
        md: {'instrument_id': int, 'date': date, 'modified_on': datetime, 'total_traded_quantity': decimal or None,
             'volume_average_30d': decimal or None, 'equity_float': decimal or None,
             'average_lender_interest_rate': decimal or None, 'average_borrower_interest_rate': decimal or None,
             'short_interest_rate': decimal or None}
update_values_for_corporate_actions(date, agreements)
    Apply the changes on quantities and base values caused by corporate actions.
    If a settlement is present in the given date, its effects will be applied after.

    date: date
    agreements: {agreement_id (int): agreement_update}
        agreemen_update: {'agreement_id': int, 'base_value': decimal, 'quantity': decimal}

    returns default success dictionary
get_first_market_data_date()
    "
    Returns first_date (Date)
add_lending_market_data(lending_market_data)
    Adds lending market data info. If there is already some data for
    this instrument and date, updates this line.
    'lending_market_data': [lending_market_data]
        lending_market_data: {'instrument_id': int, 'date': date, 'total_traded_quantity': decimal or None,
                              'average_lender_interest_rate': decimal or None, 'average_borrower_interest_rate': decimal or None,
                              'short_interest_rate': decimal or None, 'volume_average_30d': decimal or None,
                              'equity_float': decimal or None}
get_lending_allocation_suggestion(fund_assets, total_quantity_in_agreement, side, date, allocation_type=None)
    Retrieves suggestions for lending allocation, based on the quantities in custody of
    the stock being lended/borrowed.

    fund_assets: [{fund_asset_info}]
    total_quantity_in_agreement: decimal # total quantity to be allocated
    side: LENDING_SIDE: the side of the original agreement.
        fund_asset_info: {
            'fund_id': int,
            'available_underlying_quantity': decimal, # available quantity of asset
            'underlying_quantity': decimal, # total quantity of asset
            'lent_quantity': decimal # total lent quantity (optional)
        }

    returns [{fund_asset_info} + return_info]
        return_info: {'quantity': decimal}
get_agreements_current_base_value(agreement_ids, date=None)
    Retrieves the current base value of lending agreements in a given date.

    agreement_ids: [int]
    date: date

    returns: {agreement_id(int): base_value}
        base_value: {'value': decimal, 'valid_from': date, 'agreement_id': int}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
delete_agreements(agreement_ids)
    Deletes lending agreements in batch.

    agreement_ids: [int]

    returns: {}
import_lending_agreements(files)
add_lendings_settlements(settlements)
    Stores settlement information to the respectives contracts.

    settlements: {lending_id (int): settlement}
        settlement: {'quantity': Decimal or None, 'date': settlement_date or None, 'request_date': request_date or None,
                     'sent_to_administrator': boolean or missing, 'request_id': str or None}

    returns: {'settlement_ids': [int], 'error_message': string}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_lending_instruments(ids=None, underlying_symbols=None, underlying_ids=None, output_underlying_symbols=True, side=None)
    Retrieves information on the lending instrument and its underlying instrument. Accepts optional filters.

    ids: [str] or None
    underlying_symbols: [str] or None
    underlying_ids: [int] or None
    output_underlying_symbols: bool or None  # default: True
    side: LENDING_SIDES or None

    returns: {instrument_id (int): lending_instrument}
        lending_instrument: {
            'id': int,
            'side': int
            'underlying_instrument_id': int,
            'underlying_symbol': str or None  # unless output_underlying_symbols is False
        }
match_settlements(settlements)
    Matches BTC settlement informations with local data. Used to retrieve information about currency and fund

    settlements: {contract_number (int): settlement}
        settlement: {'side' int, 'instrument': string, 'quantity': Decimal, 'price': Decimal, 'days': int,
                     'yearly_interest_rate': Decimal, 'gross_value': Decimal, 'irrf': Decimal, 'value': Decimal,
                     'fund_name': string, 'date': date}

    returns: {contract_number (int): match}
        match: {'contract_number': int, 'lending_instrument__currency_id': int, 'fund_id': int}
update_settlements_sent_to_administrator(ids, sent_to_administrator)
    Updates sent_to_administrator attribute of existing lending settlements.

    Returns: default sucess dictionary
get_lending_action_suggestion(asset)
    Algorithm that returns the suggestions of lending action to take for an asset, depending on the its quantities and
    provisions.

    asset: {'fund_id': int, 'd1': date, 'd2': date, 'd3': date, 'available_quantity': Decimal,
            'to_settle_d1': decimal, 'to_settle_d2': decimal, 'to_settle_d3': decimal,
            'to_settle_d1_by_broker': settlements, 'to_settle_d2_by_broker': settlements,
            'to_settle_d3_by_broker': settlements, 'max_lender_percentage': Decimal, 'lendings': [lending]}
                settlements: {broker_id (int or None): Decimal}
                lending: {'lending_id': int, 'reversibility_type': int, 'side': int, 'quantity': Decimal}

    returns: suggestion or {}
        suggestion: {'borrow': Decimal, 'lend': Decimal, 'settle_borrowed': Decimal, 'settle_lend': Decimal,
                     'messages': [string]}
match_positions(positions, date, fund_ids, broker_ids, settlements=None)
    Matches BTC position informations with local data, saving contract numbers for contracts which doesn't have one
    yet and returning local information for later comparison.

    positions: { contract_number (string): [position] }
        position: {'side': int, 'symbol': string, 'instrument_id':int,
        'contract_number': string, 'issue_date': date, 'reversibility_type': int, 'due_date': date,
        'reversibility_date': date, 'quantity': Decimal, 'base_value': Decimal, 'yearly_interest_rate': Decimal,
        'fund_name': string, 'fund_id__in': [int], 'broker_id': int}


    returns: {
        'already_registered': position + { 'id': int, 'fund_id': int, lending_instrument_id': int,
                        'is_compulsory': boolean, 'lending_instrument_underlying_instrument__display_name': string},
        'newly_added: same as above,
        'registered_but_not_in_file': same as above,
        'not_found': position,
        'error_message': string
    }
get_agreements_initial_quantity(agreement_ids)
add_lending_agreements(lending_agreements, renew=False, skip_compliance_check=False, check_duplicated_agreement=True)
    Inserts new lending agreements.
    If renew is set to True, the lending agreements will be renewed.
    The method by default checks for compliance errors before saving new lending agreements. If no compliance error are
    found, it proceeds with the saving of the agreement, otherwise it DOESN'T saves the lending agreements and returns
    the compliance errors. To skip the compliance check, set skip_compliance_check to True.

    lending_agreements: [agreement]
        agreement: {'id': int or None, 'contract_number': string or None,'due_date': date,
                    'issue_date': date, 'is_compulsory': boolean, 'quantity': Decimal, 'reversibility_date': date
                    'reversibility_type': REVERSIBILITY_TYPES(int), 'yearly_interest_rate': Decimal, 'side': int, 'fund_id':int,
                    'broker_id': int, 'instrument_id': int, 'account_id': int or None, 'strategy_id': int,
                    'base_value': decimal or None, 'settlement_account_id': int,
                    'skip_provision_calculation': boolean or None, 'sent_to_administrator': boolean or None}
    renew: bool  # default: False
    skip_compliance_check: bool  # default: False
    check_duplicated_agreement: bool # default: True

    returns: {'lending_agreement_ids': [int], 'provision_ids': [int], 'error_message': string,
              'compliance_errors': *compliance.check_compliance() output or None}
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
get_content_type_for_lending_agreement()
    Returns the content type ID for the LendingAgrement model.

    returns: {'id': int}
add_lendings_settlements_from_file(settlements)
    Adds the settlements defined in file imported. Distributes the quantity settled in case the contract is
    diveded in multiple funds.

    settlements: {lending_id (int): settlement}
        settlement: {'quantity': Decimal or None, 'date': date or None}.

    returns: {'settlement_ids': [int], 'error_message': string}
undo_settlements(settlements=[], settlement_ids=None, return_remaining_settlements=False, date_reassignment=None)
    Undo the given settlements, deleting their effects.
    settlements: {'date': date, 'agreement_id': int}
get_instrument_by_agreement(ids)
    Retrieves the instrument ids corresponding to each lending agreement id.

    ids: [int]

    returns: {agreement_id (int): instrument_id (int)} or {}
get_lending_settlements(date=None, request_date=None, output_lendings=False, start_date=None, end_date=None, request_start_date=None, request_end_date=None, fund_ids=None, agreement_ids=None)
    Retrieves the lending settlements for a given date.
    If output_lendings is True, the lendings for each settlement will be retrieved.

    returns: {id (int): lending_settlement}
get_agreements_current_quantity(agreement_ids, date=None)
    Retrieves the current quantity of lending agreements in a given date.

    agreement_ids: [int]
    date: date

    returns: {agreement_id(int): quantity}
        quantity: {'value': decimal, 'valid_from': date, 'agreement_id': int}
update_agreement_internal_code(codes_by_id)
import_lending_internal_codes(files)
get_lending_suggestions(date, fund_ids=None, instrument_id=None, broker_id=None, position=None, skip_items_with_no_suggestions=None, simulated_orders=None)
    Retrieves lending suggestions for a specific date. Accepts optional filters.
    lending_ids=None ,fund_id=None, instrument_id=None, broker_id=None, date=None

    'fund_ids': [int] or None,
    'instrument_id': int,
    'broker_id': int,
    'date': date or None,
    'position': LENDING_POSITIONS (int) or None
    'skip_items_with_no_suggestions': bool or None  # default: True
    'simulated_orders': [simulated_order] or None
            simulated_order: {'instrument_id': int, 'quantity': Decimal, 'side': ORDER_SIDES, 'price': Decimal,
                              'fund_id': int or None, 'strategy_id': int or None, 'execution_date': date,
                              'existing_order': bool}

    returns: {'items': [fund], 'broker_names': {id (int): string}}
        fund: {'fund_id', 'fund_name': string, 'instruments': [instrument]}
            instrument: {
                'instrument_id': int, 'instrument_name': string, 'quantity': Decimal, 'available_quantity': Decimal,
                'to_settle_d1': Decimal, 'to_settle_d2': Decimal, 'to_settle_d3': Decimal, 'lendings': [lending],
                'suggestion': *get_lending_action_suggestion()
            }
                lending: {
                    'lending_id': int, 'contract_number': string, 'fund': string, 'fund_id': int, 'account': string,
                    'settlement_account_id': int, 'instrument': string, 'instrument_id': int, 'broker': string,
                    'broker_id': int, 'reversibility_type': int, 'side': int, 'issue_date': date, 'due_date': date,
                    'yearly_interest_rate': Decimal, 'quantity': Decimal, 'current_qty': Decimal,
                    'is_compulsory': boolean
                }
update_agreements_sent_to_administrator(ids, sent_to_administrator)
    Updates sent_to_administrator attribute of existing lending agreements.

    Returns: default sucess dictionary
update_lending_quantities(new_quantities)
    Updates the quantities of the given lendings. This API updates the total quantity of the
    agreement, it does not act as a settlement.

    new_quantities = {lending_id (int): quantity(decimal)}

    returns: default success dictionary
get_lending_info(lending_ids=None, fund_id=None, instrument_id=None, broker_id=None, strategy_id=None, side=None, date_type=None, start_date=None, end_date=None, show_fully_settled_agreements=None, instrument_ids=None, fund_ids=None, is_renewed=None, retrieve_settlements=True, contract_number=None, broker_ids=None, pending_allocation_only=False, look_through=False, contract_numbers=None, renewed_from_ids=None)
    Retrieves lending contract information. Accepts optional filters.

    'lending_ids': [int] or None
    'fund_ids': [int] or None
    'fund_id': int or None
    'instrument_id': int or None
    'instrument_ids': [int] or None
    'fund_ids': [int] or None
    'broker_id': int or None
    'strategy_id': int or None
    'side': int or None
    'date_type': LENDING_FILTER_DATE_TYPES (int) or None  # this field is REQUIRED if start_date/end_date are supplied
    'start_date': date or None
    'end_date': date or None
    'show_fully_settled_agreements': boolean or None
    'is_renewed': boolean or None
    'retrieve_settlements'
    'contract_number': str or None
    'broker_ids': [int]

    returns: {'items': [lending], 'current_date': date}
        lending: {
            'lending_id': int, 'contract_number': string, 'fund': string, 'fund_id': int, 'strategy_id': int,
            'strategy_name': string, 'settlement_account': string, 'settlement_account_id': int, 'instrument': string,
            'instrument_id': int, 'broker': string, 'broker_id': int, 'reversibility_type': int, 'side': int,
            'issue_date': date, 'due_date': date, 'settled_date': date or None, overdue: bool,
            'yearly_interest_rate': Decimal, 'is_compulsory': boolean,
            'quantity': Decimal, 'current_qty': Decimal, 'base_value': Decimal, 'lending_instrument_id: int,
            'sent_to_administrator': boolean, 'agreement_account_id': int,
        }
generate_generic_broker_lending_operations_xls(date, broker_ids, return_file_contents=False, include_only_new=False)
    Generate broker lending operations xls
get_underlying_instrument(ids)
    Retrieves the ID and quantity of the subjacent instrument of a lending contract.

    ids: [int]

    returns: [instruments]
        instrument: {'lending_contract_id': int, 'instrument_id': int, 'quantity': int}
get_lending_provisions(lending_ids, date)
    Retrieves provisions that match the given lending ids and that are valid or settled in the given date, i.e.
    the provisions satisfying start_date <= date < clearing_date or start_date <= date <= settlement_date.

    lending_ids: [lending_id]: int
    date: date

    returns: [provisions]
        provision: {'id': int, 'description': string, 'origin_id': int, 'origin_content_type_id': int,
                    'category_id': int, 'instrument_id': int}
Module liabilities (Passivo)
get_transaction_orders_by_origin(origins)
    Retrieves transaction orders that match the given origins.

    origins: [origin]
        origin: {'origin_id': int, 'origin_content_type_id': int}

    returns: {order_id (int): order}
        order: {'id': int, 'origin_id': int, 'origin_content_type_id': int}
get_approaching_transactions(fund_ids, date, navps=None, combine_opposite_sides=None, filter_by_request_date=True, show_older_not_converted=False, is_converted=False, strategy_ids=None)
    Retrieves the list of transactions that will occur in the future.
    Only the next 7 days' transactions are detailed individually. The rest is grouped by month.

    Redemptions (and outgoing transfers) specified by shares are converted to financial values using the date's navps,
    which may optionally be passed as a parameter to avoid an extra database hit.

    If combine_opposite_sides is True (the default), all transactions in the same date are combined
    together and only the net resulting value is inforemd.

    If filter_by_request_date is True (the default), only transactions already requested in informed date will be incuded,
    i.e., where request_date <= date.

    If show_older_not_converted is True (the default is False), transactions with conversion dates in the past but
    not correctly converted will be returned.

    Transaction values are converted to the first fund's currency.

    'fund_id': int
    'date': date
    'navps': Decimal or None
    'filter_by_request_date': bool
    'is_converted': bool
    'strategy_ids': [int or None] or None


    returns: {'detailed': [transaction], 'grouped_by_month': [transaction]}
        transaction: {'transaction_id': int or None, 'conversion_date': date, 'value': decimal, 'is_converted': boolean,
                      'redemption_shares': decimal or None}

    'redemption_shares' is only defined for detailed transactions that represent a redemption requested by number of
    shares.

    Positive values are subscriptions, and negative values are redemptions. Items are ordered by date.
    For the grouped_transactions, the conversion date will always be the first day of the month,
    and transaction_id will be None.
get_investor_account_ids(shareholder_id=None, legal_id=None, partial_legal_id=None, fund_id=None)
    Retrieves information on investor accounts. Accepts optional filters.

    shareholder_id: int or None
    legal_id: string or None
    partial_legal_id: string or None
    fund_id: int or None

    returns: {'ids': [int]}
delete_transactions(transaction_ids, delete_related_operations=False, dont_set_dirty_snapshot=False)
    Marks the indicated transactions as deleted, undoing all actions that have already been carried.

    'transaction_ids': [int]'
    'delete_related_operations': bool  # default: False
    'dont_set_dirty_snapshot': bool

    returns: {'success': bool, 'error_msg': string or None}
import_hwms_xls(filename, contents)
    Imports and processes a file in a generic format containing ticket high water marks (HWMs).

    'filename': string
    'contents': string

    returns: default success dictionary
             + {'file_id': int, 'date': date or None}
get_pnl_items_and_results(date, calculate_fund_ids=None, check_user_permissions=True, positions=None, positions_fund_ids=None, original_pnl_items=None, save=False, return_items=False, return_allocations=False, return_investor_results=False, return_results_by_account=False, return_results_by_fund=False, return_delta_positions=False, filter_fund_ids=None, filter_allocation_ids=None, item_types=None, indirection_type=None, provision_category_ids=None, description=None, strategy_ids=None, allocation_criteria=None, participation_strategy_ids=None, participation_account_ids=None)
    Retrieves the PnL items, allocations and results at the selected date, including indirect PnLs.
    Optional filters are avaialble. The returned lists depend on the return_* parameters.

    If the investors' positions are not informed, they will be obtained from the database using the opening positions.

    IF the original PnL items are not informed, they will be obtained from database and the values will be obtained
    from date's portfolio snapshots. Please note that in this case update_pnl_items() must have been called
    beforehand to create the items in the PnL Items table.

    Positions for funds not in 'positions_fund_ids' are ignored and are always fetched from the database.
    Original PnL items for funds not in 'calculate_fund_ids' are ignored, and are always fetched from the database.

    If 'save' is True, modified result entries for funds in 'calculate_fund_ids' are created/updated/removed
    in the database, and new allocation entries are also created; if the calculation date is the period end date,
    obsolete allocation entries are removed.

    date: date
    calculate_fund_ids: [int] or None
    check_user_permissions: bool  # default: True
    positions: [position] or None
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int,
                   'allocated_value': decimal, 'allocated_pfee': decimal}
    positions_fund_ids: [int] or None
    original_pnl_items: [original_item] or None
        original_item: {'item_id': int, 'original_fund_id': int, 'name': str, 'value': Decimal, 'strategy_id': int,
                        'type': PNL_ITEM_TYPES (int), 'provision_category_id': PROVISION_CATEGORIES (int) or None,
                        'origin_instrument_id': int or None, 'origin_provision_id': int or None}
    save: bool  # default: False

    # Result toggles:
    return_items: bool  # default: False
    return_allocations: bool  # default: False
    return_investor_results: bool  # default: False
    return_results_by_account: bool  # default: False
    return_results_by_fund: bool  # default: False
    return_delta_positions: bool  # default: False

    # Filters:
    filter_fund_ids: [int] or None
    item_types: [PNL_ITEM_TYPES (int)] or None
    indirection_type: PNL_INDIRECTION_TYPE (int) or None
    provision_category_ids: [PROVISION_CATEGORIES (int)] or None
    description: str or None
    strategy_ids: [int] or None
    allocation_criteria: [PNL_ALLOCATION_CRITERIA_FOR_FILTERING (int)] or None
    participation_strategy_ids: [int] or None
    participation_account_ids: [int] or None  # only for items with investor-level allocation

    returns: {'items': [item] or None, 'allocations': [allocation] or None, 'investor_results': [result] or None,
              'results_by_account': {investor_account_id (int): account_result},
              'results_by_fund': {fund_id (int): fund_result}, 'delta_positions': [position],
              'allocation_errors': [str]}
        item: {'item_id': int, 'original_fund_id': int, 'original_fund_name': str, 'name': str, 'value': Decimal,
               'date': date, 'period_start_date': date, 'period_end_date': date,
               'strategy_id': int, 'strategy_name': str, 'type': PNL_ITEM_TYPES (int), 'type_display': str,
               'provision_category_id': PROVISION_CATEGORIES (int) or None, 'provision_category_display': str or None,
               'origin_instrument_id': int or None, 'origin_provision_id': int or None}
        allocation: item +
                    {'allocation_id': int, 'fund_id': int, 'fund_name': str, 'currency_id': int, 'currency_prefix': str,
                     'master_fund_id': int or None, 'master_fund_name': str or None,
                     'allocation_criterion': PNL_ALLOCATION_CRITERIA (int), 'allocation_criterion_display': str,
                     'participation_strategy_id': int or None, 'participation_strategy_name': str or None,
                     'participation_investor_accounts': {investor_account_id (int): factor (Decimal)} or None}
        result: item +
                {'result_id': int or None, 'fund_id': int, 'fund_name': str, 'currency_id': int, 'currency_prefix': str,
                 'account_id': int, 'account_name': str, 'account_as_fund_id': int or None, 'value': decimal}
        account_result: {'account_id': int, 'account_name': str, 'fund_id': int, 'fund_name': str,
                         'currency_id': int, 'currency_prefix': str, 'value': decimal, 'participation_in_fund': decimal,
                         'detailed_by_strategy': {strategy_id (int): strategy_result}}
            strategy_result: {'strategy_id': int, 'strategy_name': string,
                              'participation_in_strategy': decimal, 'value': decimal}
        fund_result: {'fund_id': int, 'fund_name': str, 'currency_id': int, 'currency_prefix': str, 'value': decimal}
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int,
                   'allocated_value': decimal, 'allocated_pfee': decimal}
get_liabilities_distribution_data(date, fund_id)
    Obtains data for Liabilities Distribuion report.

    date: date
    fund_id: int

    returns: {'report_data': [report_data]}
        report_data: {'num_shareholders': int, 'average_ticket': Decimal,
                    'first_shareholder_participation': Decimal,
                    'second_shareholder_participation': Decimal,
                    'third_shareholder_participation': Decimal,
                    'forth_shareholder_participation': Decimal,
                    'fifth_shareholder_participation': Decimal,
                    'top_5_shareholders_participation': Decimal,
                    'top_10_shareholders_participation': Decimal,
                    'num_shaholders_with_10_participation': int,
                    'num_shaholders_with_25_participation': int,
                    'num_shaholders_with_50_participation': int}
get_transactions_to_send_to_admin(date, fund_ids=None, transaction_ids=None)
    Retrieves transactions that should be sent to the administrator.
    Can be filtered by date, fund and/or transaction ID.

    date: date
    fund_ids: int or None
    transaction_ids: [int] or None

    returns: {transaction_id (int): transaction}
        transaction: {'id': int, 'fund_id': int 'investor_account_id': int, 'bank_account_id': int or None,
                      'type': int, 'redemption_type': int or None, 'shares': Decimal or None,
                      'net_value': Decimal or None, 'fee_value': Decimal or None,
                      'conversion_date': date, 'settlement_date': date or None, 'request_date': date or None,
                      'settlement_type': int(TRANSACTION_SETTLEMENT_TYPES) or None}
get_administrator_fee_details_for_period(start_date, end_date, admin_ids=None, fund_ids=None)
    Returns the administrator fee details to calculate the fee to be paid over the fund's administration fee
    when calculating rebate fee.
    returns {administrator_id: rules_by_fund}
        rules_by_fund: {fund_id : [range]}
        range: {'rule_id': 1, 'id': 1, 'minimum_base_value': Decimal, 'rate': Decimal, 'minimum_fee_value': Decimal}
import_performance_fee_calculation_memory_xls_file(files)
    Imports and processes a file containing performance fee calculation memory.

    files: [file]
        file: {'filename': string, 'contents': string}

    returns: default multifile dictionary + {'item_count': int}
get_clients_administrator_codes(client_ids=None, administrator_ids=None)
    Retrieves ClientAdministrator information. May be filteres by client_ids or administrator_ids

    client_ids: [int] or None
    administrator_ids: [int] or None

    returns: {(client_id, administrator_id): client_administrator}
        client_id: int
        administrator_id: int
        brokers_administrator: {'id': int 'broker_id': int, 'administrator_id': int, 'code': str}
undo_period_opening(date, fund_ids)
    Undoes the processing of the period opening for the given funds.

    date: date
    fund_ids: [int]

    returns: default success dictionary
add_shares_transfers(transfers, no_accounting_effects=False, dont_set_dirty_snapshot=False)
    transfers: [transfer]
        transfer: {'source_investor_account_id': int, 'target_investor_account_id': int, 'value': decimal,
                   'conversion_date': date, 'request_type': REQUEST_TYPES (int), 'description': string or None,
                   'source_settlement_account_id': int, 'target_settlement_account_id': int,
                   # For regular funds only:
                   'generates_performance_crystallization': boolean, 'auto_convert': boolean,
                   # For allocated funds only:
                   'source_strategy_id': int, 'target_strategy_id': int, 'convert_at_opening': bool,
                   'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int), 'hwm_percentage': Decimal or None,
                  }
    no_accounting_effects: bool  # default: False
    dont_set_dirty_snapshot: bool  # default: False

    returns: default success dictionary + {'transaction_ids': [int]}
get_shareholder_start_date_by_fund(shareholder_id, fund_id)
    Get the date of the first ticket position for a given fund and shareholder.
    shareholder_id: int
    fund_id: int

    return: date or None
get_shareholder_group(ids=None, shareholder_ids=None, get_shareholder_ids=False)
    Returns the shareholder group

    returns: {'shareholder_group_id': {
        'id': int
        'name': str
        'shareholder_ids':set()
    }}
calculate_performance_fee(date, funds_portfolio_overview, fee_rule_ids=None, profiler=None, force_recalculation=False)
    Calculates the performance fee of the given funds, by the given date.
    If a 'fee_rule_ids' is set, only the given fee rules represented by the ids will be used.
    date: date
    funds_portfolio_overview: {fund_id (int): portfolio_overview}
    fee_rule_ids: [int]
        portfolio_overview: {'gross_navps': decimal, 'admin_navps': decimal or None, 'nav': decimal, 'shares': decimal,
                             'is_navps_approved': bool}


    returns default success dictionary + {'funds': provisions_and_performance_details}
        provisions_and_performance_details: {fund_id (int): {'provisions_to_add': [provision],
                                                             'performance_fees': [performance_fee]
                                                             'tickets': [ticket]}
            provision: {'name': string, 'nav_value': decimal, 'category_id': PROVISION_CATEGORIES (int),
                        'is_settled': boolean}
            performance_fee: {'performance_fee': decimal, 'ticket_id': int, 'fee_rule_id': int,
                              'deduct_from_shares': boolean}
            tickets: {'id': int, 'fund_id': int, 'account_id': int, 'highwatermark': decimal, 'shares': decimal,
                 'shareholder_id': int, 'investor_account_id': int}
add_transactions(transactions, keep_estimated_values=False, no_accounting_effects=False, dont_set_dirty_snapshot=False)
    Saves a group of liability transactions to the database.

    If an account ID is omitted, the first suitable account for the shareholder/fund combination will be used.

    If the redemption's settlement date is omitted, it will be calculated using the fund's conversion rules,
    attempting to match the given rule given by the input, then by the (request date, conversion date, transaction fee)
    combination.
    If the fund has no matching rules, an exception will be raised.

    transactions: [transaction + (subscription or redemption)]  # must be an unique dict.
        transaction: {'type': TRANSACTION_TYPES (int), 'fund_id': int,
                      'investor_account_id': int, 'settlement_type': int (TRANSACTION_SETTLEMENT_TYPES) or None,
                      'bank_account_id': int or None, 'strategy_id': int or None,
                      'request_date': date, 'conversion_date': date, 'settlement_date': date or None,
                      'conversion_rule_id': int or None, 'convert_at_opening': boolean or None,
                      'net_value': Decimal or None, 'shares': Decimal or None, 'percentage': Decimal or None,
                      'fee_value': Decimal or None, 'performance_fee_value': decimal or None,
                      'settlement_account_id': int or None, 'conversion_exchange_rate': Decimal or None,
                      'status': TRANSACTION_STATUS (int) or None,
                      'transaction_administrator_code': string or None, 'description': string,
                      'origin_id': int, 'origin_content_type_id': int}
        subscription: transaction + {'capital_commitment_id': int or None}
        redemption: transaction + {'shareholder_id': int or None
                                   'redemption_request_type': REQUEST_TYPES (int) or None,
                                   'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                                   'hwm_percentage': Decimal or None,
                                   'shares_deduction_type': SHARES_DEDUCTION_TYPES (int) or None}
                                    # ^ required if 'type' == TRANSACTION_TYPES.shares_deduction
        incoming_shares_transfer: transaction + {}
        outgoing_shares_transfer: transaction + {'redemption_request_type': REQUEST_TYPES (int),
                                                 'generates_performance_crystallization': boolean,
                                                 'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                                                 'hwm_percentage': Decimal or None}
        amortization: transaction + {'gross_value': Decimal, 'redemption_request_type': REQUEST_TYPES (int)
                                     'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                                     'hwm_percentage': Decimal or None}}
        dividends: transaction + {'gross_value': Decimal, 'redemption_request_type': REQUEST_TYPES (int),
                                  'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                                  'hwm_percentage': Decimal or None}}
    keep_estimated_values: bool  # default: False
    no_accounting_effects: bool  # default: False
    dont_set_dirty_snapshot: bool  # default: False

    returns: default success dictionary + {'transaction_ids': [int]}
import_transactions_xls_file(files, auto_create_shareholders=False, no_accounting_effects=False)
    Imports and processes a file containing transactions.

    files: [file]
        file: {'filename': string, 'contents': string}
    auto_create_shareholders: bool  # default: False
    no_accounting_effects: bool  # default: False

    returns: default multifile dictionary + {'item_count': int}
save_data_from_pfee_memory_calculation_file(date, pfees)
    Saves data from performance fee memory calculation file.

    return default success dictionary
update_investor_account(investoraccounts_dicts)
    Update investor account.

    'investoraccounts_dicts': [investoraccounts_dict]
        investoraccounts_dict: {'id': int, 'name': str, 'sh_id': int, 'fund_id': int, 'code': str}
    returns: default success dictionary
edit_transaction(t, dont_set_dirty_snapshot=False)
    Saves changes to an existing Transaction.
convert_allocated_transactions_by_date_and_phase(fund_ids, date, workflow_phase, positions=None, hwms=None, affect_assets=True, preview=False, dont_set_dirty_snapshot=False)
    Saves or previews the effects of converting the specified funds' transactions (for allocated funds only),
    in the specified workflow phase.

    If the positions and highwatermarks are not specified, they will be obtained through other APIs.

    fund_ids: [int]
    date: date
    workflow_phase: PERIOD_WORKFLOW_PHASES (int)
    positions: [position] or None
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int,
                   'allocated_value': decimal, 'allocated_pfee': decimal}
    hwms: [hwm] or None
        hwm: {'item_id': int or None, 'fund_id': int, 'investor_account_id': int, 'strategy_id': int,
              'base_date': date, 'cost': decimal, 'hurdle': decimal, 'transfer_hwm_percent': decimal or None,
              'benchmark_index_id': int or None, 'benchmark_multiplier': decimal, 'benchmark_additional': decimal}
    preview: bool  # default: False
    dont_set_dirty_snapshot: bool  # default: False

    returns: {'success': bool, 'error_msg': string or None, 'funds': {fund_id (int): fund},
              'position_deltas': [position], 'hwms_to_add': [hwm]}
        fund: {'provisions_to_add': [provision], 'provisions_to_change': [provision]}
            provision: {'id': int or None, 'name': string, 'strategy_id': int, 'attribution_strategy_id': int or None,
                        'category_id': int, 'nav_value': Decimal, 'is_settled': bool}
set_shares_total_from_snapshot(date, fund_ids, create_transactions=True, no_cash_impact=False, dont_set_dirty_snapshot=False)
    Updates an adjustment shareholder's ticket positions in the given funds so that the total number of shares
    for each fund matches the quantities in the snapshots.

    date: datetime.date
    fund_ids: [int]
    create_transactions: bool  # default: True
    no_cash_impact: bool  # default: False
    dont_set_dirty_snapshot: bool  # default: False

    returns: default success dictionary
import_distributor_transaction_txt(filename, contents, auto_create_shareholders, auto_create_operations, date_scheduling)
    Processes a TXT liabilities transaction file. Matches imported transactions with existing ones.
    Optionally may auto-create missing shareholders.

    filename: string
    contents: string
    auto_create_shareholders: bool
    auto_create_operations: bool
    date_scheduling: date

    returns: default success dictionary
             + {'file_id': int, 'funds': [fund], 'min_conversion_date': date, 'max_conversion_date': date,
                'new_matches': [transaction], 'already_converted': [transaction],
                'unmatched_imported': [transaction], 'unmatched_local': [transaction], 'failed': [transaction]}
        fund: {'id': int, 'name': string, 'code': string}
        transaction: {'transaction_id': int or None, 'transaction_administrator_code': string or None,
                      'fund_id': int or None, 'fund_name': string,
                      'investor_account_id': int or None, 'investor_account_code': string,
                      'shareholder_legal_id': string, 'shareholder_full_name': string,
                      'type_display': string, 'type': TRANSACTION_TYPES (int),
                      'request_date': date, 'conversion_date': date,
                      'gross_value': Decimal, 'net_value': Decimal, 'fee_value': Decimal, 'tax_value': Decimal,
                      'performance_fee_value': Decimal,
                      'shares': Decimal, 'conversion_navps': Decimal, 'description': string or None,
                      'error_msg': string or None,  # if this has a non-None value, bits of info are missing
                     }
unconvert_transactions_after_date(date, dont_set_dirty_snapshot=False)
    Undoes the conversions of all transactions which converted after the given date.

    'date': date
    'dont_set_dirty_snapshot': bool

    returns: default success dictionary
get_content_type_for_transaction()
    Returns the content type ID for provisions associated with a redemption.

    returns: {'id': int}
calculate_redemptions_taxes(redemptions)
    redemptions: [redemption]  # must be an unique dict.
    redemption: {'type': TRANSACTION_TYPES (int), 'fund_id': int,
                  'investor_account_id': int, 'settlement_type': int (TRANSACTION_SETTLEMENT_TYPES) or None,
                  'bank_account_id': int or None, 'strategy_id': int or None,
                  'request_date': date, 'conversion_date': date, 'settlement_date': date or None,
                  'conversion_rule_id': int or None, 'convert_at_opening': boolean or None,
                  'net_value': Decimal or None, 'shares': Decimal or None, 'percentage': Decimal or None,
                  'fee_value': Decimal or None, 'performance_fee_value': decimal or None,
                  'settlement_account_id': int or None, 'conversion_exchange_rate': Decimal or None,
                  'status': TRANSACTION_STATUS (int) or None,
                  'transaction_administrator_code': string or None, 'description': string,
                  'origin_id': int, 'origin_content_type_id': int, 'shareholder_id': int or None
                  'redemption_request_type': REQUEST_TYPES (int) or None,
                  'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                  'hwm_percentage': Decimal or None,
                  'shares_deduction_type': SHARES_DEDUCTION_TYPES (int) or None}
                  # ^ required if 'type' == TRANSACTION_TYPES.shares_deduction

    returns: redemptions dict with tax_value key filled
get_simple_subaccount_positions(date, fund_ids=None, account_ids=None, strategy_ids=None)
    Returns the investors' position per investor account + strategy pair at the given date.

    date: date
    fund_ids: [int] or None
    account_ids: [int] or None
    strategy_ids: [int] or None

    returns: {'positions': [position]}
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int or None,
                   'shares': decimal or None, 'allocated_value': decimal or None, 'allocated_pfee': decimal or None}
get_rebate_fee_for_period(start_date, end_date, client_ids=None, fund_ids=None, hide_days_without_administration_fee=False, show_shareholders_details=True)
    Calculates rebate fee for all days in the given period.

    fund_id: int
    client_id: int
    start_date: date
    end_date: date
    hide_days_without_administration_fee: bool

    if hide_days_without_administration_fee is True, the days without administration fee are not returned in the details


    returns {'start_date': date, 'end_date': date, 'summary': summary_data, 'total_by_shareholder':, [total_by_shareholder], all_values': [rebate_details]
        summary_data: {'total_rebate': Decimal, 'total_admin_fee': Decimal, 'currency_prefix': string,
                       'fund_name': string, 'client_name': string, 'currency_id': int, 'currency_name_plural': string}
        rebate_details: {'admin_fee': Decimal, 'net_admin_fee': Decimal, 'administrator_fee': Decimal, 'rebate_rate': Decimal,
                         'fund_name': string, 'client_name': string, 'rebate_value': Decimal, 'date': date, 'currency_prefix': string,
                         'client_rate': Decimal}
        total_by_shareholder: {'shareholder_id': int, 'full_name': string, 'position': Decimal, fee: Decimal}
save_performance_fees(date, performance_fees, profiler=None)
    Adds or updates information about historical performance fees calculated for each valid ticket
    in a single date, and calculates the consolidated performance fee for the funds.

    performance_fees: [performance_fee]
        performance_fee: {'ticket_id': int, 'date': date, 'corrected_highwatermark_b1': decimal,
                          'corrected_highwatermark_b2': decimal or None, 'fund_id': int,
                          'highwatermark': decimal, 'highwatermark_date': date}

    returns default success dictionary
undo_period_closure(date, fund_ids)
    Undoes the processing of the period closure for the given funds.

    date: date
    fund_ids: [int]

    returns: default success dictionary
get_tickets_and_highwatermarks_for_performance(fund_ids, date, return_shareholders_data=False)
    Returns tickets position and highwatermark information for performance calculation.

    fund_ids: [int]
    date: date
    return_shareholders_data: bool

    returns: {ticket_id (int) : ticket_data }
        ticket_data: {'id': int, 'fund_id': int, 'highwatermark': Decimal,
                      'highwatermark_date': date, 'shares': Decimal }
set_ticket_administrator_codes(codes_by_id)
    Sets the administrator code field to the given tickets.

    codes_by_id: {ticket ID (int): code (string)}

    returns: {}
calculate_performance_by_ticket(date, tickets, funds, fee_rule_ids, benchmarks_by_rule, portfolio, data, benchmark_info, fund_decimal_places)
settle_performance_fee_shares_deduction(fund_id, date)
    Settles the performance fees by shares deduction. The parameter 'date' is considered the last day
    of a performance calculation period.

    fund_id: int
    date: date

    returns: {'success': bool, 'error_msg': string or None}
calculate_performance_by_fund(date, funds, benchmarks_by_rule, portfolio, data, benchmark_info, fund_decimal_places)
get_tickets(date=None, fund_ids=None, shareholder_ids=None, ticket_ids=None, administrator_codes=None, administrator_ids=None, get_positions=False, investor_account_ids=None, ignore_converted_tickets=True, get_subscription_navps=False, prefer_original_start_date=False, get_original_start_date=False)
    Retrieves the tickets. Optional filters are accepted.

    If get_positions is True, shares position and highwatermark information will be retrieved for each ticket.
    If the date is not specified, the current date is used.

    For highwatermark information, the api tries to find the nearest highwatermark before the requested date.
    Highwatermark information for a ticket with the requested date as the base date will only be retrieved if no older
    highwatermark information is found, indicating that this ticket was created on the requested date.

    date: datetime or None
    fund_ids: [int]
    shareholder_ids: [int]
    ticket_ids: [int]
    administrator_codes: [int] # ticket codes in administrators
    administrator_ids: [int] # filter tickets by their administrators
    get_positions: boolean  # default: False
    investor_account_ids: int or None
    ignore_converted_tickets: bool  # default: True
    prefer_original_start_date: bool  # default: False
    get_original_start_date: bool  # default: False

    returns: {ticket_id (int): ticket}
        ticket: {'id': int, 'administrator_code': string, 'fund_id': int,
                 'shareholder_id': int, 'shareholder_name': string, 'shareholder_legal_id': string,
                 'account_id': int, 'account_administrator_code': string,
                 'start_date': date, 'shares': decimal or None, 'strategy_id': int,
                 'highwatermark': decimal or None, 'highwatermark_date': date or None,
                 'end_date': date or None, 'subscription_navps': decimal or None}
get_total_shares_per_high_watermark_day(fund_id, reference_date)
    Gets a list of the high watermark dates and shares of all tickets related to the input fund
    that were active on the input date. Shares from different shareholders are grouped by date.

    'fund_id': int
    'reference_date': date

    returns: [dates_and_shares]
    date_and_share: {'high_watermark_date': date, 'shares': decimal}
add_clients(client_dicts)
    Inserts new Client.

    'client_dicts': client_dicts]
        client_dicts: {'full_name': str, 'legal_id': str }
    returns: default success dictionary
get_performance_fee_by_ticket_and_date(ticket_ids, date, accept_older=False)
    Gets performance info for ech ticket in the provided date
    'ticket_ids': [int]
    'date': date
    'accept_older': bool

    returns {ticket_id (int): 'highwatermark': decimal, 'highwatermark_date': date,
            'benchmark_1_corrected_highwatermark': decimal, 'benchmark_2_corrected_highwatermark': decimal
            'performance_fee': decimal, 'deduct_from_shares': bool}
update_pnl_allocations(allocations)
    Updates the PnL allocation settings of the given allocations.

    allocations: [allocation]
        allocation: {'allocation_id': int, 'strategy_id': int or None,
                     'allocation_criterion': PNL_ALLOCATION_CRITERIA (int) or None,
                     'participation_strategy_id': int or None,
                     'participation_investor_accounts': {investor_account_id (int): factor (Decimal)} or None}

    returns: {'success': bool}
get_position_date_range(start_date, end_date, client_ids=None, fund_ids=None, return_values_by_ticket=False, return_funds_total_position=False)
    Returns shareholder positions by client in the range of dates provided.

    start_date: date
    end_date: date
    client_ids: [int]
    fund_ids: [int]
    return_values_by_ticket: bool

    if return_values_by_ticket is False position data is not returned.
    if return_funds_total_position is True, client filter is applied only to the returning dictionary

    returns {'client_id': client_data_by_date }
        client_data_by_date: {'date': {total: Decimal, 'by_fund': [shareholders_data]}
            shareholders_data: {'total': Decimal, 'shareholder_id': int, 'positions': position}
                position: { "end_date": date, "shareholder_id": int, "shares": Decimal, "fund_id": int,
                            "ticket_id": int, "client_id": int, "date": date, "start_date": date}
add_bank_account(bank_account_dicts)
    Inserts new bank accounts.

    'bank_account_dicts': [bank_account_dict]
        bank_account_dicts: {sharedholder_id: int, bank_account_type: int, bank_id: int,
                             branch: str, number: str, digit:str or None, code:str or None}
    returns: default success dictionary
get_shareholders_by_name_or_legal_id(ids=None, partial_names=None, partial_legal_ids=None)
    Retrieves shareholders by the given partial names or partial legal ids. The search
    will retrieve all shareholders which match any of the given data.

    If ids are given, information about these will also be retrieved. User for optimization.

    partial_names = [string]
    partial_legal_ids = [string]
get_clients(ids=None, is_active=None)
    Returns basic information on clients. Optional filters are available.

    ids: [int] or None
    is_active: bool or None

    returns: {id (int): client}
        client: {'id': int, 'full_name': string, 'legal_id': int}
unsettle_performance_fee_shares_deduction(fund_id, date)
    Reverts the changes due to settlement of performance fees by shares deduction.

    fund_id: int
    date: date

    returns default success dictionary
save_data_from_positions_file(date, funds, shareholders, investor_accounts, tickets, transactions_to_unconvert, tickets_to_delete, ticket_positions_to_delete)
    Saves data from positions file import.

    returns default success dictionary + {'tickets_created': [int (ticket_id)], 'shareholders_created': [int (shareholder_id)]}
add_shareholder(shareholders_dicts)
    Inserts new shareholder.

    'shareholders_dicts': [shareholders_dict]
        shareholders_dict: {'legal_id': str, 'full_name': str, 'client_id': int or None}
    returns: default success dictionary
send_rebate_report_email(start_date, end_date, template_ids=None)
    Send an e-mail to selected clients with rebate information for the given period.

    start_date: date
    end_date: date
    client_ids: [int] or None
get_consolidated_position_date_range(start_date, end_date, first_day_of_month=False, last_day_of_month=False, end_month_full=False, **kwargs)
    Queries the get_consolidated_position API in every date in a date range.
    WARNING: this version is not yet optimized for multi-date queries; it is merely a shell API to make it easier
    for external systems to interoperate with AlphaTools.

    By default, all dates in the range are returned.
    However, when at least one of first_day_of_month or last_day_of_month is True, only the first/last day of each month
    will be returned. Optionally, the month which contains end_date can be returned in full (up to end_date)
    by passing end_month_full=True.

    Accepts all input parameters from get_consolidated_position, except for 'date', plus:
    'start_date': date
    'end_date': date
    'first_day_of_month': bool
    'last_day_of_month': bool
    'end_month_full': bool

    Returns results in the same format as get_consolidated_position, with the addition of the 'date' key in every row.
get_bank_account_info(ids=None, shareholder_ids=None)
    Retrieves BankAccount information.

    Allows optional filtering by a list of BankAccount IDs.

    ids: [int] or None

    returns: {bankaccount_id (int): [bankaccount]}
        bankaccount: {
            'id': int,
            'bank_id': int,
            'branch': str,
            'number': str,
            'digit': str,
            'type': int,
            'is_active': boolean
        }
get_capital_commitments(date=None, ids=None, investor_account_ids=None, fund_ids=None, client_ids=None, shareholder_ids=None, shareholder_partial=None, currency_ids=None)
    Gets capital commitments.

    date: date or None
    ids: [int] or None
    investor_account_ids: [int] or None
    fund_ids: [int] or None
    client_ids: [int] or None
    shareholder_ids: [int] or None
    shareholder_partial: string or None
    currency_ids: [int] or None

    returns: {id (int): commitment}
        commitment: {'id': int, 'name': string, 'display_name': string, 'investor_account_id': int,
                     'fund_id': int, 'shareholder_id': int, 'currency_id': int,
                     'start_date': date, 'current_date': date,
                     'committed_value': decimal, 'uncalled_value': decimal, 'invested_value': decimal,
                     'updates': [update]}
        update: {'id': int, 'transaction_id': int or None, 'description': string,
                 'date': date, 'after_selected_date': bool,
                 'committed_value': decimal, 'invested_value': decimal, 'uncalled_value': decimal,
                 'delta_committed_value': decimal, 'delta_invested_value': decimal, 'delta_uncalled_value': decimal}
get_investor_account_code(ids=None)
    Retrieves the code from InvestorAccounts.

    Allows optional filtering by a list of InvestorAccounts IDs.

    ids: [int] or None

    returns: {investir_account_id (int): str}
add_and_convert_transactions(transactions_to_create=None, transactions_to_convert=None, affect_assets=True, auto_create_operations=False)
    Adds transactions and immediately converts them afterwards. Accepts per-ticket specification.
    Existing transactions may also be informed; these will only be converted.

    transactions_to_create: [transaction]
    transactions_to_convert: [transaction]
        transaction: {'transaction_id': int or None, 'transaction_administrator_code': string or None,
                      'fund_id': int, 'investor_account_id': int, 'auto_convert': bool or None,
                      'type': TRANSACTION_TYPES (int), 'request_date': date, 'conversion_date': date,
                      'gross_value': Decimal, 'net_value': Decimal, 'fee_value': Decimal, 'tax_value': Decimal,
                      'performance_fee_value': Decimal,
                      'shares': Decimal, 'conversion_navps': Decimal, 'description': string or None,
                      'ticket_transactions': [tt]}
            tt: {'ticket_id': int or None, 'ticket_administrator_code': string, 'shares': Decimal,
                 'gross_value': Decimal, 'net_value': Decimal, 'fee_value': Decimal, 'tax_value': Decimal
                 'performance_fee_value': Decimal,}
    affect_assets: bool  # default: True
    auto_create_operations: bool  # default: False

    Redemptions with one or more TicketTransactions without a ticket_id will be converted without ticket specification;
    the default system algorithm for selecting tickets will be used.

    Transaction and Ticket administrator codes are also set, if present in the parameters.

    If 'affect_assets' is False, no provisions will be created.
    If 'auto_create_operations' is True, operations will be created for investors which are internal funds.

    returns: {'success': bool, 'error_msg': string or None}
get_transaction_orders_info(start_date, end_date, fund_ids=None, date_type=1, order_types=None)
    Retrieves transfer information. Accepts optional filters.

    'start_date': date
    'end_date': date
    'fund_ids': [int] or None
    'date_type': TRANSACTION_FILTER_DATE_TYPES (int)
    'order_types': [TRANSACTION_ORDER_TYPES] or None

    returns: {'transaction_orders': [transaction_order] or None, 'errors': [Django form error] or None}
            transaction_order: {'order_id': int, 'fund_id': int, 'strategy_id': int, 'value': decimal,
            'type_id': TRANSACTION_ORDER_TYPES (int), 'request_date': date, 'settlement_date': date,
            'conversion_date': date, 'description': string or None, 'status': TRANSACTION_ORDER_STATUS}
get_shareholders(ids=None, legal_ids=None, partial_legal_ids=None, names=None, partial_names=None, client_ids=None, is_active=None, investor_account_ids=None, creation_date=None)
    Returns basic information on the matching shareholders.

    partial legal ids and partial names search will be aggregated
    ids: [int] or None
    legal_ids: [string] or None
    partial_legal_ids: [string] or None
    names: [string] or None
    partial_names: [string] or None
    client_ids: [int] or None
    is_active: bool or None

    returns: {shareholder_id (int): shareholder}
        shareholder: {'id': int, 'legal_id': string, 'full_name': string, 'currency_id': int or None,
                      'coholder_legal_id': string, 'coholder_full_name': string,
                      'client_id': int or None, 'client_name': string or None}
update_ticket_administrator_codes(tickets)
    Updates ticket administrator codes.

    tickets: [ticket]
        ticket: {'ticket_id': int, 'administrator_code': string}

    returns default success dictionary
get_shareholder_currency_info(ids)
    Retrieves currency and exchange information for the specified shareholders.

    ids: [int]

    returns: {shareholder_id (int): shareholder}
        shareholder: {'id': int, 'currency_id': int, 'currency_exchange_source_ids': [int]}
init_day(date)
    Updates provision values for redemptions
get_account_participations(date, fund_ids, date_period_type=None, positions=None, positions_fund_ids=None)
    Returns all investor accounts' participations in the given funds in the given date,
    as well as per-strategy participations and committed-values for funds with "By Participation" liability mode.

    If 'positions' is passed, these positions are used instead of querying the database for applicable TicketPositions.
    If 'positions_fund_ids' is also informed, then only positions pertaining to those funds are used, and positions
    for other funds are obtained by querying the database.

    date: date
    fund_ids: [int]
    date_period_type: DATE_PERIOD_TYPES (int) or None  # default: selected_date
    positions: [position] or None
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int or None,
                   'shares': decimal or None, 'allocated_value': decimal or None, 'allocated_pfee': decimal or None}
    positions_fund_ids: [int] or None

    returns: {fund_id: fund_result}
        fund_result: {'fund_id': int, 'date': date, 'total_shares': decimal, 'total_allocated_value': decimal or None,
                      'shares_by_account': {investor_account_id (int): decimal},
                      'allocated_value_by_account': {investor_account_id (int): decimal},
                      'participation_by_account': {investor_account_id (int): decimal},
                      'by_strategy': {strategy_id (int): strategy_result} or None}
            strategy_result: {'total_shares': decimal, 'total_allocated_value': decimal,
                              'participation_in_fund': decimal,
                              'shares_by_account': {investor_account_id (int): decimal},
                              'allocated_value_by_account': {investor_account_id (int): decimal},
                              'participation_by_account': {investor_account_id (int): decimal}}

    Strategy values are the stored financial positions (opening or closing, not including
    any non-processed mid-period profits and losses).
update_high_water_mark(funds_hwm, date, ticket_ids)
    Sets new high water marks for the tickets of the given funds, at the given date.

    funds_hwm: {fund_id (int): highwatermark value (decimal)}
    date: date

    returns: {'success': bool}
get_data_affected_by_positions_import(date, fund_ids, navps_by_fund=None)
    Retrieves info affected by the position file import.
    This method retrieves:
        - Tickets with start date from the given date onwards, inclusive
        - TicketPositions with date from the given date onwards, exclusive
        - Transactions converted from the given date onwards, exclusive
    All searchs are made independently, in spite of the possible relation between the results.

    date: date
    fund_ids: [int]
    navps_by_fund: {fund_id (int): decimal}

    returns {'transactions': [transaction], 'tickets': [ticket], 'ticket_positions': [ticket_position]}
        transaction: {
            'transaction_id': int, 'value': decimal, 'conversion_date': date, 'is_converted': boolean,
            'redemption_shares': decimal, 'fund_id': int, 'shareholder_id': int, 'shareholder_name': string}
        ticket: {
            'id': int, 'fund_id': int, 'account_id': int, 'shareholder_id': int, 'account_code': int,
            'administrator_code': string, 'start_date': date, 'end_date'}
        ticket_position: {
            'id': int, 'date': date, 'shares': decimal, 'ticket_id': int}
get_transactions(transaction_ids=None, start_date=None, end_date=None, date_type=None, transaction_types=None, fund_ids=None, strategy_ids=None, client_ids=None, shareholder_ids=None, shareholder_text=None, capital_commitment_ids=None, is_converted=None, convert_at_opening=None, shares_deduction_types=None, use_shareholder_currencies=False, use_fund_currencies=False, view_currency_id=None, estimate_values=None, quick_estimation=True, get_settlements=False, get_tickets=False, get_incoming_transactions_ticket_position=False)
    Gets information on a certain date's liability transactions.
    Accepts several filters and display options.

    transaction_ids [int] or None
    start_date: date or None
    end_date: date or None
    date_type: TRANSACTION_FILTER_DATE_TYPES (int)
    transaction_types: [TRANSACTION_TYPES (int)]
    fund_ids: [int] or None
    strategy_ids: [int] or None
    client_ids: [int] or None
    shareholder_ids: [int] or None
    shareholder_text: string or None
    capital_commitment_ids: [int] or None
    is_converted: bool or None
    convert_at_opening: bool or None
    shares_deductions_types: [SHARES_DEDUCTION_TYPES (int)]
    use_shareholder_currencies: bool  # default: False
    use_fund_currencies: bool  # default: False
    view_currency_id: None # convert values to this currency
    estimate_values: bool or None  # default: False
    quick_estimation: bool # default: True
    get_settlements: bool  # default: False
    get_tickets: bool  # default: False
    get_incoming_transactions_ticket_position: bool #default False

    Only one of the following parameters may be filled: 'use_shareholder_currencies', 'use_fund_currencies'
    or 'view_currency_id'. An exception will be raised if more than one is filled.

    When quick_estimation=True (default behavior), positions used for percentage/full redemptions may be cached.

    returns: {'transactions': [transaction]}
        transaction: {'transaction_id': int, 'transaction_administrator_code': string or None,
                      'fund_id': int, 'fund_name': string, 'fund_uses_allocated_liabilities': bool,
                      'fund_uses_shares': bool, 'investor_account_id': int, 'investor_account_code': string or None,
                      'shareholder_id': int, 'shareholder_legal_id': string, 'shareholder_full_name': string,
                      'strategy_id': int or None, 'strategy_name': string or None,
                      'client_id': int, 'client_name': string, 'description': string,
                      'type_display': string, 'type': TRANSACTION_TYPES, 'status': TRANSACTION_STATUS (int),
                      'status_display': string, 'request_date': date, 'conversion_date': date, 'settlement_date': date,
                      'gross_value': Decimal or None, 'net_value': Decimal or None,
                      'fee_value': Decimal or None, 'tax_value': Decimal or None,
                      'percentage': Decimal or None, 'shares': Decimal or None,
                      'conversion_navps': Decimal or None, 'conversion_exchange_rate': Decimal or None,
                      'currency_id': int, 'currency_prefix': string, 'fund_currency_id': int,
                      'fund_currency_prefix': string, 'display_currency_id': int, 'display_currency_prefix': string,
                      'net_value_is_estimated': bool, 'gross_value_is_estimated': bool, 'shares_is_estimated': bool,
                      'performance_fee_value_is_estimated': bool, 'conversion_exchange_rate_is_estimated': bool,
                      'settlement_type': (int) TRANSACTION_SETTLEMENT_TYPES or None,
                      'bank_account_id': int, 'is_editable': bool,
                      'capital_commitment_id': int or None,  # for subscriptions
                      'shares_deduction_type': SHARES_DEDUCTION_TYPES # for shares deductions
                      'redemption_settlements': [redemption_settlement] or None,
                      'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES (int) or None,
                      'hwm_impact_type_display': str or None, 'hwm_percentage': Decimal or None}
        redemption_settlement: {'id': int, 'date': date, 'value': Decimal}
get_valid_asset_strategy_replacements(fund_ids=None)
    Returns a list of strategy IDs that are equivalent (are in the same asset strategy replacement group).

    fund_ids: [int] or None

    returns: {fund_id (int): {strategy_id (int): {alternate_strategy_id (int): alternate}}}
        alternate: {'id': int, 'name': str}
before_snapshot_generation(date, fund_ids, **kwargs)
unconvert_transaction_orders(ids)
    Unconvert transaction orders and corresponding transacitons.
    'ids': [int]

    retunrs: default success dictionary
get_shareholder_dict_hash(ids=None)
    Returns basic information on the matching shareholders.
    returns: {
                legal_id (int) : fields_hash: (str)
            }
add_investor_account(investoraccounts_dicts)
    Inserts new investor account.

    'investoraccounts_dicts': [investoraccounts_dict]
        investoraccounts_dict: {'name': str, 'sh_id': int, 'fund_id': int, 'code': str}
    returns: default success dictionary
update_shareholder(shareholder_dicts)
    Update shareholder.

    'shareholder_dicts': [shareholder_dic]
        shareholder_dic: {'id': int, 'name': str, 'sh_id': int}
    returns: default success dictionary
convert_transactions_by_id(transactions, preview=None, affect_assets=None, dont_set_dirty_snapshot=False)
    Saves or previews the effects of converting the specified transactions.
    Details per ticket can be optionally informed.

    transactions: {transaction_id (int): transaction}
        transaction {'conversion_navps': Decimal, 'tax_value': Decimal or None, 'fee_value': Decimal or None,
                     'ticket_transactions': [tt] or None, 'origin_ticket_id': int or None,
                     'conversion_date_from_file': date or None}
            tt (subscriptions): {'ticket_administrator_code': string or None, 'net_value': Decimal or None,
                                 'shares': Decimal or None}  # only one entry is allowed
            tt (redemptions): {'ticket_id': int, 'net_value': Decimal, 'fee_value': Decimal, 'tax_value': Decimal,
                               'shares': Decimal or None}
                               # If 'shares' is specified, it must match the net/fee/tax values.
            tt (amortizations or dividends): {'ticket_id': int, 'net_value': Decimal, 'fee_value': Decimal,
                                            'tax_value': Decimal}
    preview: bool or None  # default: False
    affect_assets: bool or None  # default: True
    dont_set_dirty_snapshot: bool  # default: False

    returns: {'success': bool, 'error_msg': string or None}
get_highest_hwm(fund_id, date)
    Retrieves fund'd highest HWM for a given date.
    fund_id: int
    date: date

    return: hwm_value (decimal)
delete_high_water_marks(date, ticket_ids=None, fund_ids=None)
    Deletes HWM entries for given dates and tickets.

    ATTENTION: this method DOES NOT deletes highwatermarks from the start date of tickets to avoid inconsistency.
    High water marks of initial dates should be updated instead of deleted.
    date: date
    ticket_ids: [int]
    fund_ids: [int]

    returns: default success dict
get_shareholder_info(ids=None, partial_legal_ids=None, partial_names=None, client_ids=None, investor_account_ids=None, is_active=None, creation_date=None)
    Obtains information on shareholders that match the given filters.

    ids: [int] or None
    partial_legal_ids: [string] or None
    partial_names: [string] or None
    client_ids: [int] or None
    investor_account_ids: [int] or None
    is_active: bool or None

    returns: {shareholder_id (int): shareholder}
        shareholder: {'id': int, 'legal_id': string, 'full_name': string,
                      'coholder_legal_id': string, 'coholder_full_name': string,
                      'client_id': int or None, 'client_name': string or None,
                      'currency_id': int or None, 'currency_exchange_source_ids': [int],
                      'investor_accounts': {id (int): investor_account},
                      'bank_accounts': {id (int): bank_account, 'client': string, 'type': int,
            investor_account: {'id': int, 'code': string, 'name': string, 'fund_id': int, 'fund_name': string}
            bank_account: {'id': int, 'data': string}
get_performance_view_data(fund_id, date, flat=False, order_by=None, order_by_direction=None, hide_tickets_without_performance=False)
    Retrieves performance fee information for display.

    fund_id: int
    date: date
    flat: bool  # default: False
    order_by: PERFORMANCE_VIEW_DATA_ORDER_BY_TYPE
    order_by_direction: PERFORMANCE_VIEW_DATA_ORDER_DIRECTION
    hide_tickets_without_performance: Bool

    returns: {'adm_performance_fee': decimal, 'calculated_performance_fee': decimal, 'local_performance_fee': decimal,
              'difference': decimal, 'difference_relative': decimal # between calculated and adm performance
              'fee_rule': fee_rule 'fund_overview': fund_overview, 'success': True}
         fee_rule: {'benchmark_1': benchmark,
                    'benchmark_1_decimal_places': int or None,
                    'benchmark_1_id': int or None, 'benchmark_2': benchmark or None,
                    'benchmark_2_id': int or None,
                    'consolidated_performance_fee': consolidated_performance, 'deduct_from_shares': bool, u'id': int,
                    'is_active': bool, 'limit_net_navps_to_highwatermark': bool, 'name': string,
                    'performance_fees': [performance], 'rate': decimal or None, 'rate_b1_only': decimal,
                    'rate_b2_only': decimal, 'rate_both': decimal, 'rate_both_base': decimal, 'settlement_days': int,
                    'settlement_days_is_business_only': bool, 'settlement_months': [int], 'template': int,
                    'use_hurdle_from_other_strategies': bool},
            benchmark: {'id': int, 'name': string}
            consolidated_performance: {'date': date, 'fund_id': int, u'id': int,  'performance_fee': decimal}
            performance: {'benchmark_1_corrected_highwatermark': decimal, 'benchmark_1_variation': decimal,
                          'benchmark_2_corrected_highwatermark': decimal, 'date': date, 'deduct_from_shares': bool,
                          'highwatermark': decimal, 'highwatermark_date': date, u'id': int, 'modified_on': date,
                          'performance_fee': decimal, 'ticket': ticket, 'ticket_id': int}
                ticket: Ticket.objects.values result
        fund_overview: {'all_snapshots': [snapshot], 'comparison_id': int, 'currency_id': int,
                        'currency_info': currency_info, 'date': date, 'decimal_places_navps': int,
                        'decimal_places_provision': int, 'decimal_places_shares': int, 'fund_has_daily_portfolios': bool,
                        'generated_on': date, 'gross_navps': decimal, 'id': int, 'is_navps_approved': bool,
                        'is_official_date': bool, 'last_online_navps': decimal, 'managerial_nav': decimal or None,
                        'name': string, 'nav': decimal, 'navps': decimal,  'navps_ex_amortizations': decimal,
                        'navps_variation_previous_day': decimal,  'shares': decimal,  'snapshot_id': int,
                        'status': SNAPSHOT_STATUS, 'type': SNAPSHOT_TYPE},
            snapshot: {'generated_on': date, 'selected': bool, 'snapshot_id': int, 'type': SNAPSHOT_TYPE},

    When flat=True:
    - The contents of /fund_overview are merged into the root dictionary
    - The contents of /fund_overview/fee_rule are merged into the root dictionary
    - The contents of /fund_overview/fee_rule/consolidated_performance are merged into the root dictionary
    - The contents of /fund_overview/fee_rule/performance_fees are returned as a list after root named /tickets
    - The contents of /fund_overview/fee_rule/performance_fees/ticket are merged into the content of the item in /tickets
create_corporate_payments_for_transactions_orders(ids=[<type 'int'>])
accept_period_process_discrepancies(date, discrepancies_by_fund, discrepancies_by_investor_accounts, pfees_to_set)
    Saves discrepancies between local period process results and administrator data.

    discrepancies_by_fund: {fund_id (int): discrepancies_by_strategy}
    discrepancies_by_investor_account: {investor_account_id (int): discrepancies_by_strategy}
        discrepancies_by_strategy: {strategy_id (int): {'diff_position': Decimal}}
    pfees_to_set: [pfee]
        pfee: {'investor_account_id': int, 'strategy_id': int, 'value': Decimal}
update_funds_high_water_mark(funds_hwm, date)
validate_transaction(transactions, skip_compliance_check=False)
    Validates transactions over operational rules, such as time limit and min/max transaction values,
    and compliance rules.

    transactions: [transaction]
        transaction: {'transaction_type': TRANSACTION_TYPES, 'date': date, 'fund_id': int, 'target_instrument_id': int,
                      'shareholder_id': int, 'investor_account_id': int or None, 'source_fund_id': int or None,
                      'portfolio_strategy_id': int or None,
                      'chain_factor_value': float, 'financial_value': decimal or None, 'account_id': int or None,
                      'is_liability_transaction': bool, 'is_asset_transaction': bool}

    returns: {'operational_errors': {fund_id (int): fund_error} or {},
              'compliance_errors': *compliance.check_compliance() output or None,
              'warning_messages': []}
        fund_error: {'fund_name': string, 'errors': [error_msg (string)]}
convert_transactions_by_date(date, fund_navps, preview=None, accept_older=None, affect_assets=None, dont_set_dirty_snapshot=False, update_provisions=True)
    Saves or previews the effects of all transaction conversions due for the given day, at the given funds.
    This skips any allocated funds.

    During snapshot generation, update_provisions must be False to avoid deadlock errors.
    A separate job will handle provisions update.

    date: date
    fund_navps: {fund_id (int): navps (Decimal)}
    preview: boolean or None  # default: False
    accept_older: boolean or None  # default: False
    affect_assets: boolean or None  # default: True
    dont_set_dirty_snapshot: bool
    update_provisions : bool

    returns: {'success': bool, 'error_msg': string or None, 'funds': {fund_id (int): fund}}
        fund: {'shares_delta': Decimal, 'provisions_to_add': [provision], 'provisions_to_change': [provision]}
            provision: {'id': int or None, 'name': string, 'strategy_id': int, 'attribution_strategy_id': int or None,
                        'category_id': int, 'nav_value': Decimal, 'is_settled': bool}
get_allocated_highwatermark_data(date, return_display_info=False, calculate_adjusted_values=False, fund_ids=None, shareholder_ids=None, account_str=None, strategy_ids=None, no_strategy=False, origin_types=None, workflow_phase=None, aggregate=False)
    Obtains information on highwatermark entries for allocated funds which were active as of the given date.

    If 'calculate_adjusted_values' is True, in addition to the information stored in the database,
    this API also returns the entries' values adjusted to the given date
    (using the benchmark's variation since the entry's base date until the given date).

    If 'aggregate' is True, results are aggregated by investor account + strategy.

    date: date
    return_display_info: bool  # default: False
    calculate_adjusted_values: bool  # default: False
    fund_ids: [int] or None
    shareholder_ids: [int] or None
    account_str: string or None  # ID match and/or partial match on name
    strategy_ids: [int] or None
    no_strategy: bool  # default: False
    origin_types: [ALLOCATED_HWM_ORIGINS (string)] or None
    workflow_phase: PERIOD_WORKFLOW_PHASES (int) or None  # default: closing_after_pfee
    aggregate: bool  # default: False

    returns: {'items': [hwm], 'totals': totals, 'aggregated': bool}
        hwm: {'item_id': int, 'fund_id': int, 'investor_account_id': int, 'strategy_id': int or None,
              'base_date': date, 'cost': decimal, 'hurdle': decimal, 'transfer_hwm_percent': decimal or None,
              'benchmark_index_id': int or None, 'benchmark_multiplier': decimal, 'benchmark_additional': decimal}
             # If calculate_adjusted_values is True:
             + {'ref_date': date, 'benchmark_index_variation': decimal or None, 'benchmark_variation': decimal or None,
                'delta_cost': decimal, 'delta_hurdle': decimal, 'delta_value': decimal,
                'adjusted_hurdle': decimal, 'adjusted_value': decimal}
             # If return_display_info is True:
             + {'value': decimal, 'transaction_value': decimal or None,
                'start_date': date, 'end_date': date, 'fund_name': string, 'description': string,
                'currency_id': int, 'currency_prefix': string, 'shareholder_id': int, 'shareholder_full_name': string,
                'investor_account_name': string, 'strategy_name': string or None, 'workflow_phase_display': string,
                'origin_transaction_id': int or None, 'origin_type': ALLOCATED_HWM_ORIGINS (int),
                'origin_type_display': string,
                'impact_type': REDEMPTION_HWM_IMPACT_TYPES (int), 'impact_type_display': string or None,
                'subaccount_gross_balance': decimal or None, 'subaccount_net_balance': decimal or None,
                'subaccount_cost': decimal or None, 'subaccount_adjusted_hurdle': decimal or None,
                'benchmark_index_name': string or None, 'benchmark_full_name': string or None}

        totals: {'cost': decimal, 'hurdle': decimal}
                # If calculate_adjusted_values is True:
                + {'delta_cost': decimal, 'delta_hurdle': decimal, 'delta_value': decimal,
                   'adjusted_hurdle': decimal, 'adjusted_value': decimal}
                # If return_display_info is True:
                + {'transaction_value': decimal, 'value': decimal}

    When aggregation is enabled, the return format changes to:
        hwm: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int or None,
              'cost': decimal, 'hurdle': decimal,
              'benchmark_index_id': int or None, 'benchmark_multiplier': decimal, 'benchmark_additional': decimal}
             # If calculate_adjusted_values is True:
             + {'ref_date': date, 'delta_cost': decimal, 'delta_hurdle': decimal, 'delta_value': decimal,
                'adjusted_hurdle': decimal, 'adjusted_value': decimal}
             # If return_display_info is True:
             + {'value': decimal, 'fund_name': string, 'currency_id': int, 'currency_prefix': string,
                'shareholder_id': int, 'shareholder_full_name': string,
                'investor_account_name': string, 'strategy_name': string or None,
                'benchmark_index_name': string or None, 'benchmark_full_name': string or None,
                'gross_balance': decimal, 'hwm_balance_ratio': decimal}
get_period_data_from_admin(date, fund_ids)
    Access external database to download administrator period processing data.
    This method only retrieves data. To read registered information after database sync
    use process_period.

    date: date
    fund_ids: [int]

    returns: default success dictionary
    # TODO: Error handling
update_original_pnl_items_from_snapshots(date, fund_end_dates, snapshots)
    Creates/deletes PnL items from snapshot assets.

    date: date
    fund_end_dates: {fund_id (int): period end date (date)}
    snapshots: {fund_id (int): snapshot}
        snapshot: {'assets': [asset], 'balances': [balance], 'provisions': [provision], 'errors': [base]}
            base: {'name': str, 'strategy_id': int,
                   'attribution_nominal_value': Decimal, 'attribution_fx_value': Decimal}
            asset: base + {'instrument_id': int}
            balance: base + {'account_id': int}
            provision: base + {'origin_provision_id': int, 'category_id': PROVISION_CATEGORIES (int),
                               'allocate_fx_attribution_separately': bool or None}

    returns: {'items': [item]}
        item: {'item_id': int, 'original_fund_id': int, 'name': str, 'value': Decimal, 'strategy_id': int,
               'type': PNL_ITEM_TYPES (int), 'provision_category_id': PROVISION_CATEGORIES (int) or None,
               'origin_instrument_id': int or None, 'origin_provision_id': int or None,
               'origin_account_id': int or None}
calculate_and_save_performance_fee(date, fund_ids=None, dont_set_dirty_snapshot=False, funds_portfolio_overview=None, force_recalculation=False)
    Calculates and saves performance fee for the givend fund_ids in the date.

    return: default success dictionary
get_pnl_info_for_provision(provision_id)
    Retrieves PnL information for the given provision.

    provision_id: int

    returns: {'item_id': int, 'allocation_id': int, 'allocation_criterion': PNL_ALLOCATION_CRITERIA (int),
              'participation_strategy_id': int or None,
              'participation_investor_accounts': {investor_account_id (int): factor (Decimal)} or None} or {}
get_funds_high_water_marks(date, fund_ids)
get_investor_account_info(ids=None, shareholder_ids=None, fund_ids=None, codes=None, is_active=None)
    Retrieves investor account information.

    ids: [int] or None
    shareholder_ids: [int] or None
    fund_ids: [int] or None
    codes: [string] or None
    is_active: bool or None

    returns: {id (int): investor_account}
        investor_account: {'id': int, 'shareholder_id': int, 'fund_id': int, 'is_active': int, 'code': string,
                           'name': string, 'full_name': string, 'full_name_without_fund': string,
                           'shareholder_name': string, 'shareholder_legal_id': int}
get_bank_account_ids(shareholder_id=None, legal_id=None, partial_legal_id=None, bank_id=None)
    Obtains a list of bank accounts. Can be filtered by shareholder ID, legal ID, legal ID fragment
    and bank ID.

    shareholder_id: int or None
    legal_id: string or None
    partial_legal_id: string or None
    bank_id: int or None

    returns: {'ids': [int]}
edit_redemption_fees(redemptions)
    Edit redemption fees' values.

    redemptions: {transaction_id (int): redemption}
        redemption: {'performance': decimal, 'fee': decimal, 'tax': decimal}

    returns: default success dictionary
update_original_transaction_id(transactions_data)
    Updates original transaction id for redemptions that have multiple installments.

    transactions_data: {transaction_id: original_transaction_id}

    returns default success dictionary
calculate_added_allocated_positions(positions, deltas, return_deltas=False)
    Adds PnL results to the positions of allocated funds (in-memory) and returns the resulting positions.

    positions: [position]
    deltas: [position]
        position: {'fund_id': int, 'investor_account_id': int, 'strategy_id': int,
                   'allocated_value': decimal, 'allocated_pfee': decimal,
                   'delta_allocated_value': decimal, 'delta_allocated_pfee': decimal}  # only if return_deltas=True

    returns: {'positions': [position]}

    Please note that the 'positions' list is modified in-place,
    which may affect the caller if it's running in the same process.
get_consolidated_position(fund_ids=None, account_ids=None, shareholder_ids=None, strategy_ids=None, date=None, group_by_account=False, detailed_by_strategy=False, get_capital_commitment=False, estimate_values=False, date_period_type=None, get_names=False, use_navps_for_liability_conversion=False, use_navps_ex_amortizations=False, use_converting_transactions_for_position=None, use_requesting_transactions_for_position=None, remove_transactions_from_estimative=None, portfolio_nav_by_strategy=None, allocated_fund_ids=None, strategies_by_allocated_fund=None, participations=None)
may_inactivate_investiment_account(account_id)
    Allows only investment accounts without ticket position or with ticket position but no shares

    account_id: int
    returns bool
get_shareholders_last_transaction(shareholder_ids=None, dates_by_shareholder={}, transaction_types=None)
save_data_from_performance_fee_file(date, tickets)
    Saves data from performance fee file.

    return default success dictionary
import_generic_liabilities_positions_file(filename, contents, zero_tickets, date)
get_applicable_tax_rules(investor_account_id, date)
    investor_account_id: int
    date: date

    returns {success: bool, applicable_tax_rules: [TaxRule.to_dict()]}
get_position(fund_ids=None, account_ids=None, shareholder_ids=None, strategy_ids=None, date=None, group_by=2, detailed_by_strategy=False, get_capital_commitment=False, estimate_values=False, date_period_type=None, get_names=False, use_navps_for_liability_conversion=False, use_navps_ex_amortizations=False, use_converting_transactions_for_position=None, use_requesting_transactions_for_position=None, remove_transactions_from_estimative=None, portfolio_nav_by_strategy=None, allocated_fund_ids=None, strategies_by_allocated_fund=None, participations=None, client_ids=None)
    Obtains information on the sum of all tickets owned by the each shareholder/account in each fund,
    in the given date. Accepts optional filters. If not specified, the current date is used.

    fund_ids: [int] or None
    account_ids: [int] or None
    shareholder_ids: [int] or None
    strategy_ids: [int] or None
    date: date or None  # default: today
    group_by_account: boolean  # default: False
    detailed_by_strategy: boolean  # default: False
    get_capital_commitment: boolean  # default: False
    estimate_values: boolean  # default: False
    date_period_type: DATE_PERIOD_TYPES (int) or None  # default: DATE_PERIOD_TYPES.selected_date
    get_names: bool
    use_navps_for_liability_conversion: boolean  # default: False
    use_converting_transactions_for_position: boolean # default: False
    use_requesting_transactions_for_position: boolean # default: False
    remove_transactions_from_estimative: [int] or None

    If 'estimate_values' is True, estimated financial values, share_percentage and the navps used for conversion will also be returned.
    If 'group_by_account' is True, results are grouped by investor account rather than by shareholder.
    If 'detailed_by_strategy' is True, results are specified separately for each strategy in "By Participation" funds.

    If 'use_converting_transactions_for_position' is set, transactions with conversion date less then or equal 'date'
    but not actually converted into shares will be taken into account for positions estimative.
    If 'use_requesting_transactions_for_position', all unconverted transactions will be taken into account.
    If any of those parameters is set, estimate_values will be considered as set to True.
    A list of transactions can be set to be ignored in remove_transactions_from_estimative.

    The following fields were included for performance improvements in the init_day method, to avoid retrieving
    this information multiple times inside a for loop:
    * portfolio_nav_by_strategy
    * allocated_fund_ids
    * strategies_by_allocated_fund
    * participations

    returns: {'results': [result]}
        result: {'fund_id': int, 'shareholder_id': int or None, 'account_id': int or None, 'strategy_id': int or None,
                 'shares': decimal, 'gross_value': decimal or None, 'share_percentage': decimal or None,
                 'committed_value': decimal or None, 'uncalled_value': decimal or None,
                 'invested_value': decimal or None, 'conversion_navps': decimal or None,
                 # If get_names=True:
                 'fund_name': str or None, 'shareholder_name': str or None, 'account_name': str or None,
                 'strategy_name': str or None}

    If both fund_ids and account_ids/shareholder_ids (depending on group_by_account) are specified,
    results are returned for the given pairs even when no matching tickets are found.
get_period_workflow_data(date, fund_ids=None, strategy_ids=None, investor_text=None, statuses=None, has_results=None, retrieve_external=False, flat=False)
    Gets the latest results of period worfklow processing (saved to the database).
    If retrieve_external=True, administrator information is also fetched for comparison.

    date: date
    fund_ids: [int] or None
    strategy_ids: [int] or None
    investor_text: string or None  # searches on shareholder name, shareholder legal ID and investor account name
    statuses: [PERIOD_STATUS (int)] or None
    has_results: bool or None
    retrieve_external:  bool  # default: False
    flat: bool  # default: False

    returns: {'items': [fund}, 'has_external_results': bool, 'items_with_participation_errors': int}
        fund: {'fund_id': int, 'fund_name': string, 'currency_id': int, 'currency_prefix': string,
               'period_id': int or None, 'status': PERIOD_STATUS (int),
               'start_date': date, 'date': date, 'end_date': date, 'previous_end_date': date,
               'can_process_opening': bool, 'can_undo_opening': bool,
               'can_process_closure': bool, 'can_undo_closure': bool, 'can_recalculate': bool,
               'items_with_participation_errors': int, 'has_results': bool, 'subaccounts': [subaccount],
               'results_by_strategy': {strategy_id (int): subaccount}
               'external_result': external_result or None} + result
        subaccount: {'fund_id': int, 'fund_name': string, 'currency_id': int, 'currency_prefix': string,
                     'investor_account_id': int, 'investor_account_name': string,
                     'strategy_id': int, 'strategy_name': string} + result
        result: (all entries are decimals)
                {'previous_balance_net', 'opening_transactions', 'opening_performance_fee_reversal',
                 'opening_transfers', 'opening_balance_gross',
                 'participation_in_strategy', 'participation_in_fund',
                 'pnl_fund_level', 'pnl_strategy_level', 'pnl_investor_account_level', 'pnl_inter_strategy',
                 'pnl_adm_fee', 'pnl_management_fee', 'pnl_adjustment', 'pnl_error', 'pnl_total_gross',
                 'closing_transfers', 'closing_balance_gross_after_transfers',
                 'highwatermark', 'performance_fee_rate', 'calculated_performance_fee', 'performance_fee',
                 'closing_balance_net_before_transactions', 'closing_transactions',
                 'closing_balance_gross', 'closing_balance_net',
                 'rate_of_return_before_mfee', 'rate_of_return_gross', 'rate_of_return_net'}
        external_result:  {'is_external': True, 'subaccounts': [subaccount + {'is_external': True}]} + result

    If flat=True, all kinds of results (per-fund, per-strategy, per-subaccount -- internal and external)
    are returned in the top-level 'items' entry.
generate_rebate_report_xls(start_date, end_date, client_ids, return_file_contents=True)
    Generates xls reports with rebate information.

    start_date: date
    end_date: date
    client_ids: [int] or None

    returns {
        'log': string, 'success': boolean, 'no_results': boolean,
        'files': { 'file_id': int, 'client_id': int, 'template_id': int, 'file_contents: (filename, content, mimetype) }
    }
transfer_shareholder_history(source_investor_account_id, target_investor_account_id)
    Transfers full shareholder history (transactions and tickets) from one account to another.
    'source_investor_account_id': int
    'target_investor_account_id': int

    returns: default success dictionary
unconvert_transactions_by_id(transaction_ids, regular_only=False, dont_set_dirty_snapshot=False)
    Undoes the conversion of the selected transactions.

    'transaction_ids': [int]
    'restrict_allocated': bool or None
    'dont_set_dirty_snapshot': bool

    If 'regular_only' is True, an error will be returned if transactions of allocated funds are passed in.

    If a transaction's fund's snapshot has already been released in the conversion date,
    an exception will be raised.

    returns: {'success': bool, 'error_msg': string or None}
add_client_administrators(client_administrator_dicts)
    Inserts new ClientAdministrator.

    'client_administrator_dicts': [client_administrator_dicts]
        client_administrator_dicts: {'client_id': int, 'administrator_id': int, 'code': str or None}
    returns: default success dictionary
add_transaction_orders(transaction_orders)
    Adds new transaction orders and associated Transactions.
    'transaction_orders': transaction_order
        transaction_order: {'fund_id': int, 'value': decimal, 'type': TRANSACTION_ORDER_TYPES,
                            'request_date': date, 'settlement_date': date, 'conversion_date': date,
                            'description': str or None, 'origin_id': int or None, 'strategy_id': int or None,
                            'origin_content_type_id': int or None, 'request_type': REQUEST_TYPES,
                            'hwm_impact_type': REDEMPTION_HWM_IMPACT_TYPES or None, 'hwm_percentage': decimal or None}

    retunrs: default success dictionary
get_shareholder_data_per_investor_account(account_ids=None)
    Obtains shareholder data for the given investor accounts.
    Returned data is keyed by account ID.

    account_ids: [int] or None

    returns: {account_id (int): shareholder}
        shareholder: {'id': int, 'full_name': string, 'legal_id': string}
convert_transaction_orders(ids)
    Converts all transactions associated with each order.
    'ids': [int]

    retunrs: default success dictionary
get_allocated_fund_participations(date, fund_ids=None, account_ids=None, shareholder_ids=None, strategy_ids=None, accept_older=True)
    Returns the investor participations per account-strategy pair in a specific date.
    Information is obtained from the period processing results.

    date: date
    fund_ids: [int] or None
    account_ids: [int] or None
    strategy_ids: [int] or None
    accept_older: bool

    returns: {'items': [item]}
        item: {'fund_id': int, 'account_id': int, 'shareholder_id': int, 'strategy_id': int,
                'fund_participation': decimal, 'strategy_participation': decimal}
set_transaction_administrator_codes(codes_by_id)
    Sets the administrator code field to the given transactions.

    codes_by_id: {transaction ID (int): code (string)}

    returns: {}
order_positions_by_least_tax(redemption, positions)
    redemption: {'conversion_date': date, 'fund_id': int, 'investor_account_id': int, 'shares': decimal, 'net_value': decimal,
                }
    positions {Ticket.id: {'id': int (Ticket.id), 'start_date': date (Ticket.start_date), 'original_start_date': date (Ticket.original_start_date) or None, 'shares': Decimal (TicketPosition.shares)}}

    returns: {'success': bool, 'ordered_positions_ids': [int (Ticket.id)], 'tax_rates': {Ticket.id: Decimal (tax rate)}}
update_original_pnl_items_from_provisions(new_provisions=None, deleted_provision_ids=None)
    Creates/deletes PnL items from provision additions and deletions.

    new_provisions: [provision] or None
    deleted_provision_ids: [int]
        provision: {'id': int, fund_id': int, 'name': str, 'strategy_id': int, 'start_date': date,
                    'category_id': PROVISION_CATEGORIES (int), 'allocate_fx_attribution_separately': bool or None,
                    'allocation_strategy_id': int or None, 'allocation_criterion': PNL_ALLOCATION_CRITERIA (int),
                    'participation_strategy_id': int or None,
                    'participation_investor_accounts': {investor_account_id (int): factor (Decimal)} or None}

    returns: {'new_item_ids': [int], 'new_allocation_ids': [int], 'deleted_item_ids': [int]}
healthcheck_period_processing(date, fund_ids=None, screen=False, email=False, force_email=False)
    Performs multiple checks in the period processing of one or more funds, and optionally
    displays the results in the screen (print) or by email.
    Email is only sent when there are errors, unless 'force_email' is True

    date: date
    fund_ids: [int] or None
    screen: bool
    email: bool
    force_email: bool

    returns: {fund_id (int): fund}
        fund: {'id': int, 'name': string, 'success': bool, 'results': string}
delete_transaction_orders(ids)
    Delete transaction orders and corresponding transactions.
    'ids': [int]

    retunrs: default success dictionary
Module margin (Margem)
get_extended_margin_info(fund_ids=None, broker_ids=None, status=None, broker_account_ids=None, date=None, ignore_zeroed_provisions=None)
    Retrieves extended information on MarginRequirements an CollateralPosition of a fund on a broker.

    fund_ids: [int] or None
    broker_ids: [int] or None
    status: MARGIN_STATUS (int) or None
    broker_account_ids: [int] or None
    ignore_zeroed_provisions: bool or None

    returns: {'margin_requirements': [margin_requirements],
              'assets_position': [asset_position], 'provisions_position': [provision_position]}
    margin_requirements:{
        'id': int,
        'fund_id': int,
        'fund_name': str,
        'broker_name': str,
        'broker_id': int,
        'status': MARGIN_STATUS (int),
        'required_value': Decimal
    }
    asset_position: {collateral_position_id (int): collateral_position}
        collateral_position: {
            'id': int,
            'instrument_id': int,
            'account_id': int,
            'fund_ids': [int],
            'broker_id': int,
            'full_value': Decimal,
            'collateral_value': Decimal,
            'quantity': Decimal,
            'date': date,
            'price': Decimal,
            'currency_id': int,
            'currency_prefix': str,
        }
    provision_position: {provision_collateral_position_id (int): provision_collateral_position}
        provision_collateral_position: {
            'id': int,
            'provision_id': int,
            'account_id': int,
            'fund_ids': [int],
            'broker_id': int,
            'collateral_value': Decimal,
            'date': date,
            'currency_id': int,
            'currency_prefix': str,
        }
    funds: {fund_id (int): fund_name (str)}
get_collateral_haircuts(instrument_ids)
    Get collateral haircut rules.

    'instrument_ids': [int]
                haircut: {'instrument_id': int, 'max_quantity': decimal, 'haircut_percent': decimal}

    returns: {'instrument_id' (int): haircut_data}
        haircut_data: {'instrument_id': int, 'max_quantity': decimal, 'haircut_percent': decimal}
get_margin_requirement_info(fund_ids=None, broker_ids=None, status=None, broker_account_ids=None, accept_older=True, date=None)
    Retrieves margin requirement information. If no requirement is found for a certain Fund-Broker, returns zero.

    fund_ids: [int] or None
    broker_ids: [int] or None
    status: MARGIN_STATUS (int) or None
    broker_account_ids: [int] or None
    accept_older: boolean
    date: date or None

    returns: {broker_account_id (int): margin_requirement}
    margin_requirement: {
        'margin_requirement_id': int or None,
        'broker_account_id': int,
        'fund_ids': [int],
        'status': MARGIN_STATUS (int) or None,
        'required_value': Decimal,
        'currency_id': int,
        'currency_prefix': str,
        'broker_id': int
    }
get_collateral_positions_info(fund_ids=None, broker_ids=None, broker_account_ids=None, date=None, ignore_zeroed_provisions=None)
    Retrieves collateral position information.

    fund_ids: [int] or None
    broker_ids: [int] or None
    broker_account_ids: [int] or None
    ignore_zeroed_provisions: bool or None

    If ignore_zeroed_provisions is True, remove provisions with collateral value = 0 from results

    returns: {'assets_position': [asset_position], 'provisions_position': [provision_position]}
        asset_position: {collateral_position_id (int): collateral_position}
            collateral_position: {
                'id': int,
                'instrument_id': int,
                'account_id': int,
                'fund_ids': [int],
                'broker_id': int,
                'full_value': Decimal,
                'collateral_value': Decimal,
                'quantity': Decimal,
                'date': date,
                'price': Decimal,
                'currency_id': int,
                'currency_prefix': str,
            }
        provision_position: {provision_collateral_position_id (int): provision_collateral_position}
            provision_collateral_position: {
                'id': int,
                'provision_id': int,
                'account_id': int,
                'fund_ids': [int],
                'broker_id': int,
                'collateral_value': Decimal,
                'date': date,
                'currency_id': int,
                'currency_prefix': str,
            }
set_collateral_haircuts(haircuts)
    Sets collateral haircut rules. If a rule already existis for the same instrument, replaces it.

    'haircuts': [haircut]
                haircut: {'instrument_id': int, 'max_quantity': decimal, 'haircut_percent': decimal}

    returns: {'success': boolean}
update_collateral_positions(date, broker_account_ids=None, fund_ids=None)
    Updates the collateral positions based on the balances, prices and haircut rules.
    If fund IDs and broker accounts are not specified, all accounts will be processed.

    date: datetime.date
    broker_account_ids: [int] or None
    fund_ids: [int] or None

    returns: {'success': bool}
calc_status(broker_account_id, date, required_value)
    Calculates the status for a given MarginRequirement mr based on the CollateralPositions.
    returns: MARGIN_STATUS (int)
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
set_margin_requirements(margin_requirements)
    Sets the MarginRequirement data.

    margin_requirements: [margin_requirement]
    margin_requirement: {
        'broker_account_id': int,
        'date': datetime.date,
        'fund_ids': [int],
        'broker_id': int,
        'required_value': Decimal
    }

    returns: {'success': bool,
              'errors': [str]}
compare_collateral_positions(collateral_positions)
    Compares the given collateral_positions information with the CollateralPosition data reports the differences.

    collateral_positions: [collateral_position]
        collateral_position: {'fund_ids': [int], 'broker_id': int, 'date': date, 'broker_account_id': int,
                              'positions': {'instrument_id'(int): position}, 'provisions': {'provision_id'(int): provision}}
            position: {'instrument_id': int, 'quantity': Decimal, 'value': Decimal}
            provision: {'provision_id': int, 'value': Decimal}

    returns: [discrepancy]
        discrepancy: {'fund_ids': [int], 'broker_id': int, 'date': date, 'broker_account_id': int,
                      'discrepancy': {'instrument_id'(int): instrument_discrepancy},
                      'provision_discrepancy': {'provision_id'(int): provision_discrepancy}}
            instrument_discrepancy: {'instrument_id': int, 'current_quantity': Decimal, 'imported_quantity': Decimal}
            provision_discrepancy: {'provision_id': int, 'current_value': Decimal, 'imported_value': Decimal}
Module market (Mercado)
get_market_parameters(key, market_ids=None, value=None)
    Get extra market parameters.

    key: MARKET_PARAMETER_KEYS or None
    market_ids: [int] or None

    returns: {market_id (int): market_parameter}
        market_parameter: {'id': int, 'market_id': int, 'key': MARKET_PARAMETER_KEYS (string), 'value': string}
get_market_by_acronym(market_ids=None, acronyms=None)
    Returns the market keyed by acronym. Accepts optional filters.

    market_ids: [int] or None
    acronyms: [str] or None

    returns: {acronym (string): [market_id (int)]}
holidays_in_range(start_date, end_date=None, market_id=None, fund_type_id=None)
    Gets the holidays days comprised between the input start/end dates

     start_date: date
    end_date': date
    market_id: int or None
    fund_type_id: int or None

    returns: {'dates': [date]}
add_bank(code, name, country_id)
calc_business_days_delta(date_a, date_b, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None)
    Returns the difference in number of business days between date_a and date_b.
    The result is equivalent to date_a - date_b.
    Holidays may be filtered by asset market or by fund holiday type.

    date_a: date
    date_b: date
    market_id: int or None
    fund_type_id: int or None

    returns: {'days': int}

    Examples:
    >>> print calc_business_days_delta(wednesday, friday)
    {'days': 2}
    >>> print calc_business_days_delta(friday, wednesday)
    {'days': -2}
    >>> print calc_business_days_delta(friday, saturday)
    {'days': 0}
    >>> print calc_business_days_delta(saturday, friday)
    {'days': 0}
    >>> print calc_business_days_delta(friday, next_monday)
    {'days': 1}
    >>> print calc_business_days_delta(next_monday, friday)
    {'days': -1}
get_bank_info(ids=None)
    Retrieves bank information. May be filtered by ID.

    ids: [int] or None

    returns: {bank_id (int): bank}
        bank: {'id': int, 'code': str}
get_market_names(market_ids=None, currency_ids=None, risk_index_ids=None, partial_name=None)
    Retrieves the market's basic information.

    market_ids: [int] or None
    currency_ids: [int] or None
    risk_index_ids: [int] or None

    returns: {market_id (int): market}
        market: {'id': int, 'name': string, 'currency_id': int, 'settlement_days': int, 'black_scholes_index_id': int,
                 'timezone': TIME_ZONE, 'consolidade_executions_on_average_price': bool, 'risk_index_id': int,
                 'currency_exposure_multiplier': decimal, 'mic': string}
get_closest_business_day(date, reverse=None, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None, only_bov_holidays=None)
    Returns the next future date which is a business day (including the date itself, if it qualifies).
    If 'reverse' is True and the given date is not a business day, the closest business day in the past is returned.
    Holidays may be filtered by asset market or by fund holiday type.

    date: date
    reverse: boolean or None
    market_id: int or None
    fund_type_id: int or None

    returns: {'date': date}
get_market_currency(market_ids=None)
    Retrieves the market's preferred currencies.

    market_ids: [int] or None

    returns: {market_id (int): currency_id (int)}
is_business_day_batch(dates, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None)
    Returns whether each specified day is a business day.
    Holidays may be filtered by asset market or by fund holiday type.

    dates: [date]
    market_id: int or None
    fund_type_id: int or None

    returns: {date: bool}
create_state(state_name, country_name)
get_business_days_in_range(start_date, end_date, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None)
    Gets the business days comprised between the input start/end dates
    (themselves included, if they are business days).
    Holidays may be filtered by asset market or by fund holiday type.

    start_date: date
    end_date': date
    market_id: int or None
    fund_type_id: int or None

    returns: {'dates': [date]}
is_business_day(date, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None)
    Returns whether the specified day is a business day.
    Holidays may be filtered by asset market or by fund holiday type.

    date: date
    market_id: int or None
    fund_type_id: int or None

    returns: {'is_business_day': boolean}
get_state_names(state_ids=None)
    Retrieves states' basic information.

    state_ids: [int] or None

    returns: {state_id (int): state}
        state: {'id': int, 'name': string}
get_closest_business_day_dict(dates_dict, reverse=None, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None)
    Returns, for each date, itself or the next future date which is a business day.
    If 'reverse' is True and the given date is not a business day, the closest business day in the past is returned.
    Holidays may be filtered by asset market or by fund holiday type.

    dates: [date]
    reverse: boolean or None
    market_id: int or None
    fund_type_id: int or None
    fund_type_for_conversion_id: int or None

    returns: {input date: corresponding date}
get_country_names(country_ids=None, iso_codes=None)
    Retrieves countries' basic information.

    country_ids: [int] or None
    iso_codes: [str] or None

    returns: {country_id (int): country}
        country: {'id': int, 'name': string, 'iso_code': str}
create_country(country_name)
get_market_country(market_ids=None, country_ids=None, country_codes=None)
    Retrieves the market's country.

    market_ids: [int] or None
    coutry_ids: [int] or None,
    country_codes: [ISO_COUNTRY_CODES (str)] or None

    returns: {market_id (int): market_country}
        market_country: {'id': int, 'country_id': int, 'country_name': string, 'country_code': string}
get_closest_business_day_batch(dates, reverse=None, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None, period_for_operation_generate=None, only_bov_holidays=None)
    Returns, for each date, itself or the next future date which is a business day.
    If 'reverse' is True and the given date is not a business day, the closest business day in the past is returned.
    Holidays may be filtered by asset market or by fund holiday type.

    dates: [date]
    reverse: boolean or None
    market_id: int or None
    fund_type_id: int or None

    returns: {input date: corresponding date}
add_business_days(date, days, market_id=None, fund_type_id=None, fund_type_for_conversion_id=None, fund_type_for_requesting_transactions_id=None, only_bov_holidays=None)
    Adds a number of business days to the given date. Accepts negative deltas.
    Holidays may be filtered by asset market or by fund holiday type.

    date: date
    days: int
    market_id: int or None
    fund_type_id: int or None

    returns: {'date': date, 'all_dates': [date]}
get_holidays_by_fund_type(start_date, end_date, holiday_type_ids=None)
    Retrieves all holidays in the given range for each fund type.

    start_date: date
    end_date: date

    returns: {fund_type_id: [date]} or {}
get_morningstar_market_codes(market_ids)
    Retrieves the morningstar code by ID

    market_ids: [int]

    return: {market_id (int) : {'morningstar_code': int, 'name': str}}
get_holidays_in_range_for_markets(market_ids, start_date, end_date=None)
    Gets the holidays days comprised between the input start/end dates for each market.

    start_date: date
    end_date': date
    market_id: int or None
    fund_type_id: int or None

    returns: {'market_id': [date]}
Module options (Opes)
get_strike_prices(instrument_ids, date=None)
    Gets the strike price for option instruments.

    instrument_ids: [int]
    date: date or None

    If date is None, the latest entry is used.

    returns: {instrument_id (int): price (Decimal)}
exercise_options(options, user_id)
    Apply the effects of exercising the given options.

    options: [option]
        option: {'option_id': int, 'quantity': decimal, 'fund_id': int, 'broker_id': int,
                 'date': date, 'settlement_date': date}
before_snapshot_generation(date, fund_ids, **kwargs)
get_strike_prices_and_dates(instrument_ids, date=None)
    Returns strike price information about each option given.
get_future_options(ids=None, min_strike_date=None, max_strike_date=None)
    Obtains a list of all options whose underlying instrument is a future instrument.

    ids: [int]
    max_strike_date: date

    returns: {instrument_id (int): future_options}  or None
        future_options: {'id': int, 'underlying_instrument_id': int}
calculate_option_prices(instrument_ids=None, fund_ids=None, date=None)
    Calculates option prices, deltas and volatilities using Black&Scholes model.

    Prices in D(0) are calculated using the implied volatility of D(-1).

    instrument_ids: [int] or None
    fund_ids: [int] or None
    date: date or None

    Returns: {instrument_id (int): {'success': bool, 'error_message': string}}
get_details_for_portfolio(date, instrument_id_list)
    Returns the portfolio column names and values that are specific to this module. The group
    name is hard-coded and is returned on the first level of the output.

    'date': date
    'instrument_id_list': [int]

    returns: {'group_display_name': string, 'columns': [columns], 'extra_data': {extra_data},
              'tooltips': {tooltips}, 'buttons': {buttons}}
    column: {'display_name': string, 'format': formats, 'column_identifier': string}
    extra_data: {'column_identifier': any, ...} # 'any' means it depends on the column
    tooltips: {'column_identifier': string, ...}
    buttons: {'column_identifier': URL, ...}
add_option_instruments(option_instruments)
    Inserts new option instruments.

    'option_instruments': [option_instrument]
        option_instrument: {'name': str, 'symbol': str, 'market_id': int, 'isin_code': str, 'issuer_id': int
                            'strike_date': date, 'strike_price': decimal, 'underlying_instrument_id': int,
                            'option_type': OPTION_TYPES(int), 'exercise_style': EXERCISE_STYLES(int),
                            'pricing_rule': PRICING_RULES(int), 'series': str or None, 'price_divisor': int or None,
                            'is_monitoring_enabled': boolean or None, 'bloomberg_pricing_source': str or None,
                            'bloomberg_ticker': str or None, 'round_lot': int or None, 'settlement_days': int or None}
    returns: default success dictionary
get_option_info_by_series(options_by_series)
    TODO: fill docs
    option_by_series: [option_series_pair]
        option_series_pair: (series (str), strike (Decimal))
calculate_exposure_prices(prices_dict, instrument_ids, date)
    Gets the current price of the instruments in the input list used to calculate exposure.
    The exposure price for options is calculated with the underlying instrument price multiplied by the delta option
    price are used to calculate exposure.
    The returned value is always 'per unit', regardless of the existence of a multiplier.

    prices_dict: dictionary containing prices data

    instrument_ids: [instrument_id]

    date: (date)

    returns: {instrument_id (int): price (Decimal)}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
compare_options_pricing(file_prices, date)
    Compares imported prices against local pricing information.

    file_prices: {instrument_id (int): [price]}
        price: { 'file_price': decimal, 'file_delta': decimal, 'file_vol': decimal,
                'instrument_id': int,
                'is_in_portfolio': int (should be boolean) }

    returns: {instrument_id (int): [compared_price]}
        compared_price: price + {'nav_unit_value': decimal, 'delta': decimal}
get_option_instruments_to_fill()
get_options_info(ids=None, underlying_instrument_ids=None, strike_date_from=None, strike_date_to=None, option_types=None, include_strike_price=False)
    Obtains basic information for option instruments.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    underlying_instrument_ids: [int] or None
    strike_date_from: date or None
    strike_date_to: date or None
    option_types: [OPTION_TYPES (int)] or None
    include_strike_price: bool


    returns: {instrument_id (int): info}
        info: {'id': int, 'option_type': OPTION_TYPES (int), 'strike_date': date, 'pricing_rule': PRICING_RULES (int),
               'underlying_instrument_id': int, 'underlying_instrument_name': unicode, 'underlying_factor': float, 'is_flexible': boolean,
               'market_price_max_age': int, 'series': str or None}
recalculate_prices(date)
    Recalculates prices for the given date, for all options contained in any fund's portfolio.
update_option_instrument(_id, new_strike_price, new_strike_date, new_strike_price_date=None)
    Updates an existing option instrument to a new strike price and date.

    id: int
    new_strike_price: decimal
    new_strike_date: date
    new_strike_price_date: date # the date from which the new strike price is valid
    returns: default success dictionary
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
black_scholes(underlying_price, strike_price, interest_rate, days_to_expiration, volatility=None, call_price=None, put_price=None, is_future=False, is_business_days=True)
    Returns the call/put prices (or volatility) and greeks of European options on stocks or futures.
    If volatility is provided, then call and put prices are calculated. If call or put price is provided,
    then volatility is calculated. In any case, all values are returned, unless all three inputs are
    provided, in which case an error is returned.

    The parameter 'is_business_days' is true by default and considers 252 business days per year. If expliciply
    made false, then a 360-day year is considered.

    If 'is_future' is true, then Black's model is applied instead of Black-Scholes. However, the only difference
    in this case is the underlying price, which is brought to present value using the given interest rate.

    'underlying_price': decimal
    'strike_price': decimal
    'interest_rate': decimal       # annual rate in %
    'days_to_expiration': decimal
    'volatility': decimal or None  # volatility in %
    'is_future': boolean or None
    'call_price': decimal or None
    'put_price': decimal or None

    returns: {'put_price': decimal, 'call_price': decimal, 'put_delta': decimal, 'call_delta': decimal,
              'put_theta': decimal, 'call_theta': decimal, 'put_rho': decimal, 'call_rho': decimal,
              'vega': decimal, 'gamma': decimal, 'implied_volatility': decimal}
get_option_price_info(date, prices=None, vols=None, strike_prices=None)
    For a given option instrument, find additional information on its price. Usually there are two scenarios: the price
    has delta/vol missing, or the volatility is known and price/delta is needed.

    date: date
    prices: {instrument_id (int): price} or None
    vols = {instrument_id (int): vol} or None
    strike_prices = {instrument_id (int): decimal} or None

    returns: {instrument_id: option_price_info} or {}
        option_price_info: {'delta': decimal, 'vol': decimal, 'price': decimal} or None
save_imported_prices(prices, date, price_source, override_vol_of_next_prices=False)
    Saves prices imported from file after user confirmation.
    If override_vol_of_next_prices is True, copies vol of each price to the price of the next day

    prices: {instrument_id (int): price}
        price: {'price': decimal, 'delta': decimal or None, 'vol': decimal or None}
    'date': date
    'price_source': PRICE_SOURCES (int)
    'override_vol_of_next_prices': bool

    returns: {'success': bool}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
Module portfolio (Carteira)
get_assets_attribution(fund_id, start_date, end_date=None, navps_variation=None, distribute_error=False, calculate_currency_attributions=None, group_provisions=True, instrument_ids=None, consolidate_strategies=True, strategy_ids=None, look_through_enabled=False, currency_id=None, include_first_date=False)
    Returns portfolio assets and provision attributions between dates. It joins lending assets into their underlying
    instruments for the calculation.
    If provision grouping is requested, provisions are aggregated by some pre-specified categories,
    and the remaining ones are grouped in "Others" category.
    Optionally, it can distribute error between navps_variation and total attribution.
    If look-through is enabled, the snapshot type will be altered accordingly.

    fund_id: int
    start_date: date
    end_date: date or None
    navps_variation: decimal or None
    distribute_error: bool  # default: False
    group_provisions: bool  # default: True
    instrument_ids: [int] or None
    consolidate_strategies: bool # default: True
    strategy_ids: [int] or None
    look_through_enabled: bool # default: False
    currency_id: int or None
    include_first_date: bool  # default: False

    returns: {'assets': assets, 'provisions': provisions, 'attribution_error': decimal, 'attribution_sum': decimal,
              'total_currency_attribution': decimal}
        assets: {instrument_id (int): attribution} if consolidate_strategies = True
                {strategy_id (int): {instrument_id: attribution}} if consolidate_strategies = False
        provisions: {category_id or provision_id (int): Decimal or None}
            attribution: {'attribution': Decimal or None, 'currency_attribution': Decimal or None,
                          'non_currency_attribution': Decimal or None, 'average_exposure': Decimal}
get_periods(date, fund_ids=None, statuses=None, only_multiday_funds=False, test_status_changes=False, period_for_operation_generate=None)
    Returns each selected fund's portfolio period which contain the given date.

    date: date
    fund_ids: [int] or None
    statuses: [PERIOD_STATUS (int)] or None
    only_multiday: bool  # default: False
    test_status_changes: bool  # default: False

    returns: {fund_id (int): period}
        period: {'fund_id': int, 'periodicity': PORTFOLIO_PERIODICITES (int), 'period_id': int or None,
                 'status': PERIOD_STATUS (int), 'start_date': date, 'end_date': date, 'previous_end_date': date,
                 'can_process_pnl': bool, 'can_recalculate': bool}
                +  # only if test_status_changes is True:
                {'can_process_opening': bool, 'can_undo_opening': bool,
                 'can_process_closure': bool, 'can_undo_closure': bool}

    The return value 'can_process_pnl' refers to whether snapshot calculation in the given period should
    process PnL allocation. This usually is False only on pre-migration dates, which should not be recalculated,
    and in post-closure dates.

    If only_multiday_funds is True, results are returned only for funds which have a non-daily period.
get_portfolio_nav_by_strategy(date, fund_ids, accept_older=True)
    Returns the funds' NAVs per strategy, in the given date, in the funds' currencies.
    Only 'current' snapshot types are considered.

    date: date
    fund_ids: [int]
    accept_older: bool  # default: True

    returns: {fund_id (int): fund or None}
        fund: {'actual_date': date, 'nav': decimal, 'nav_by_strategy': {strategy_id (int): nav (decimal)}
save_consolidated_attributions(attributions, enable_lt)
    Saves consolidated attributions.

    attributions: [item]
        item: {'fund_id': int, 'date': date, 'attrib_by_asset': attrib_by_asset, 'attrib_by_issuer': attrib_by_issuer}
            attrib_by_asset: {(name, instrument_id): attrib_dict}
            attrib_by_issuer: {(name, issuer_id): attrib_dict}
            attrib_by_provision_category: {(name, provision_category_id): attrib_dict}
            attrib_by_currency: {(name, currency_id): attrib_dict}
                attrib_dict: {'month': decimal, 'quarter': decimal, 'year': decimal, 'from_start': decimal,
                              'nominal_month': decimal, 'nominal_quarter': decimal, 'nominal_year': decimal,
                              'nominal_from_start': decimal
                              'curency_month': decimal, 'curency_quarter': decimal, 'curency_year': decimal,
                              'curency_from_start': decimal,
                              # Only for assets:
                              'exposure_month': decimal, 'exposure_quarter': decimal, 'exposure_year': decimal,
                              'exposure_from_start': decimal}

    enable_lt: bool # default True

    returns: default success dict
set_period_status(fund_id, end_date, status)
    Changes the period status for the given fund and period end date.
    A Period entry is created if it doesn't exist yet.

    fund_id: int
    end_date: date
    status: PERIOD_STATUS (int)

    returns: {'period_id': int}
get_instruments_group_exposure_for_allocation(instrument_ids, date, fund_ids, use_gross_nav=False)
    A instrument group may be flagged to have its instruments used together for allocation.
    This api returns for each instrument the group it belongs to and the group exposure.

    If the instrument belongs to a group which does not have the flag 'use_together_for_allocation' = True,
    no group information will be returned.

    returns {instrument_id (int): group}
        group: {'id': int, 'name': string, 'show_instruments_as_group': boolean, 'instrument_ids': [int], 'exposure': Decimal}
replace_external_snapshot_provisions(snapshot_id, provision_list)
    Temporary method to replace all provisions from an external snapshot by the provisions provided as parameters.
    Used since Mellon does not use provision categorization properly in anbima xml file.

    snapshot_id: int
    provisions_list: [provision]
        provision: {'name': str, 'nav_value': decimal, 'category': int, 'settlement_date': date or missing}

    returns: default success dictionary
get_first_open_snapshot(fund_id)
    Returns the fund's oldest portfolio snapshot that can still be edited.
    This is usually yesterday's snapshot (if in the morning)
    or today's snapshot (after yesterday's snapshot is released).

    fund_id: int

    returns: {'snapshot_id': int, 'date': date} or {}

    Returns an empty dictionary if no matching open snapshot was found.
is_navps_approved(date, fund_ids=None)
    Checks if fund has navps approved for the given date.

    date: Date
    fund_ids: [int]

    returns {fund_id: bool}
save_external_snapshots(snapshots, price_source)
    Creates or updates snapshots for external funds.

    'snapshots': [snapshot]
        snapshot: {'external_fund_id': int, 'nav': Decimal, 'navps': Decimal, 'snapshot_date': date}
    'price_source': PRICE_SOURCES (int)

    returns: ...
    TODO: DOCS
update_operations(operation_changes, propagate_to_exec_allocs=False)
    Updates operation information.

    Number values in 'operation_changes' are the new values (NOT deltas). Values with None or missing will not be changed.
    If an extra_values dictionary is supplied, informed entries will be modified and missing entries will be kept-as-is.
    Entries in the current extra_values dictionary may be deleted by passing their keys to the 'extra_values_to_delete'
    argument.

    'operation_changes': {operation_id (int): operation}
        # all values are optional
        operation: {'quantity': decimal, 'price': decimal, 'extra_values': dict, 'extra_values_to_delete': [string],
                    'brokerage_fee': decimal, 'emoluments_value': decimal, 'carrying_brokerage_fee': decimal,
                    'asset_settlement_date': date, 'payment_settlement_date': date,
                    'date': date, 'account_id': int, 'payment_account_id': int, 'is_confirmed': bool}
    propagate_to_exec_allocs: bool (If true propagates brokerage fee changes to ExecutionAllocations)
    returns: {}
delete_transfers(transfer_ids)
    Deletes portfolio transfers and related operations.

    ids: [int]
    returns: default success dictionary
get_instrument_average_price_by_fund(instrument_ids, fund_ids, date, entry_data=None)
    Calculates the average price of all instruments operation.
    If entry_data is provided, calculate only from this date onwards.

    For each instrument and fund, get historical average operations price.
    'fund_ids': [int]
    'instrument_ids': [int]
    'date': date
    'entry_data': {'entry_date': date, 'entry_data_by_fund_and_instrument': [entry_data_by_fund_and_instrument]} or None
            entry_data_by_fund_and_instrument: {'fund_id': int, 'instrument_id': int,
                                                'entry_price': decimal, 'entry_quantity': decimal}

    returns: {instrument_id (int): {fund_id (int): average_price (decimal),
                                    'total_instrument_avg_price': average_price (decimal))}
get_portfolios_compare(fund_id_1, date_1, fund_id_2, date_2, full_look_through=None, order_by=None, group_by=None, group_provisions=True, attribution_look_through=False, currency_id=None)
    Returns a comparison between two portfolios (general info, assets and consolidated provisions).
    If portfolios are from the same fund, it also returns the attribution for each asset and for the consolidated
    provisions. In this case, it also returns the attribution error (delta between navps variation and
    attributions sum).

    If both fund_id_1 = fund_id_2 and date_1 = date_2, this method returns a comparison between the last online and
    current snapshots of the provided fund/date.

    The optional flag 'attribution_look_through' enables look-through attributions for a pre-determined view. Note that
    this and full_look_through cannot be True at the same time.

    fund_id_1: int
    date_1: date
    fund_id_2: int
    date_2: date
    full_look_through: bool  # default: True
    order_by: one of 'exposure', 'attribution'  # default: 'exposure'
    group_by: int or None (GROUP_BY_OPTIONS)
    group_provisions: bool  # default: True  # groups by category and currency. Forced to True if funds are different
    currency_id: int

    returns: {'portfolio_1_data': portfolio_overview, 'portfolio_2_data': portfolio_overview, 'delta': portfolio_delta,
              'asset_groups': asset_group, 'currency_exposures': currency_exposures,
              'attribution_error': decimal or None, 'total_currency_attribution': decimal or None} or {}
        portfolio_overview: {'nav': decimal, 'shares': decimal, 'gross_navps': decimal, 'navps': decimal}
        portfolio_delta : {'nav': decimal, 'shares': decimal, 'gross_navps': decimal, 'navps': decimal}
        asset_group: {group_identifier (string): group} or {}
        group_identifier: one of: 'stocks', 'options', 'futures', 'funds', 'bonds', 'cash', 'provisions'
            group: {'assets': [asset]}
                asset: {'instrument_id': int, 'name': string,
                        'portfolio_1': portfolio_asset_values, 'portfolio_2': portfolio_asset_values,
                        'delta': portfolios_asset_delta,
                        # Only if the portfolios are from the same fund.
                        'attribution': decimal, 'currency_attribution': decimal, 'non_currency_attribution': decimal,
                        'average_exposure': decimal,
                        # In addition, only if provision grouping is disabled.
                        'provision_id': int or None, 'category_id': int}
                    portfolios_asset_delta : {'absolute': portfolio_asset_values, 'percentage': portfolio_asset_values}
                    portfolio_asset_values: {'quantity': decimal, 'exposure': decimal, 'nav_value': decimal,
                                             'nav_percentage': decimal, 'price': price, 'price_url': string, 'old_price': boolean}
                        price: {'instrument_id': int, 'nav_unit_value': Decimal, 'exposure_unit_value': Decimal,
                                'average_value': Decimal, 'price_divisor': Decimal, 'price_source': int, 'actual_date': date,
                                'extra_values': JSON, 'generated_on': datetime, 'modified_on': datetime,
                                'corporate_actions_factor': float, 'price_id': int, 'administrator_id': int or None}
        currency_exposures: {'currency_id': int, 'name': string, 'portfolio_1': currency_exposure,
                             'portfolio_2': currency_exposure, 'delta': {'absolute': currency_exposure,
                                                                         'percentage': currency_exposure}
                            }
            currency_exposure: {'exposure': decimal, 'delta_adjusted_exposure': decimal}
get_position_by_asset_manager(date, fund_ids, currency_id)
    Returns the total invested amount in all fund instruments associated with a each asset manager.

    fund_ids: [int] or None
    date: date
    currency_i: int

    returns: {'items': [item]}
        item: {'asset_manager': str, 'total_investment': decimal, 'investment_percentage': decimal}
set_nav_adjustments(*args, **kwargs)
update_operations_settlement(ids_by_date, dont_set_dirty_snapshot=False)
    Updates the settlement date of existing operations.

    ids_by_date: {new date: [operation_id (int)] }
    dont_set_dirty_snapshot: bool  # default: False

    Returns: default sucess dictionary
get_current_gross_and_net_nav(fund_ids=None, date=None, accept_older=None, use_managerial_nav=None)
    Retrieves the NAV of each specified fund's current snapshot.

    If use_managerial_nav is True, the managerial NAV are used rather than the official NAV, if they exist.

    If date is None, lastest NAV is returned.

    funds: [fund_id (int)]
    date: date or None
    accept_older: bool or None  # default: True
    use_managerial_nav: bool or None  # default: False

    returns: {fund_id (int): NAV (decimal)}
get_portfolio_transfer_info(start_date=None, end_date=None, fund_id=None, is_automatic=None)
    Retrieves portfolio transfers' info. Accepts optional filters.

    'start_date': date or None
    'end_date': dat or None
    'fund_id': int or None

    returns: {'transfers': [transfer] or None, 'errors': [Django form error] or None}
        transfer: {'transfer_id': int, 'instrument_id': int, 'instrument_name': str, 'date': date, 'quantity': Decimal,
                   'account_from_id': int, 'account_to_id': int, 'account_from_name': str, 'account_to_name': str,
                   'strategy_from_id': int, 'strategy_to_id': int, 'strategy_from_name': str, 'strategy_to_name': str,
                   'is_automatic': boolean}
snapshot_freeze(fund_id, date, nav=None, shares=None, navps=None)
    Undoes the freezing of one or more snapshots.

    snapshots: [snapshot]
        snapshot: {'fund_id': int, 'date': date, 'values': [str]}

    Valid values are: 'nav', 'navps' and 'shares'.

    returns: default success dict
instruments_maturity_forecast(start_date=None, days=None)
        Looks for instruments that are in position in at least one portfolio and which matury date is within a few days.
        If start_date is not informed, it is considered as today.

        start_date: date or None  # default: today
        days: int or None  # default: 3
        fund_ids: [int] or None
    Search
        returns: {instrument (int): instrument}
            instrument: {'instrument_id': int, 'instrument_name': string, 'fund_ids': [int], 'fund_names': string,
                      'maturity_date': date}
get_portfolio_assets_avg(fund_id, calculation_past_days_avg=60, date=None, operations=None, full_look_through=None, look_through_instrument_ids=None)
    TODO: Implement

    Returns the same as get_portfolio_assets, but calculated over the average of last X days, where
    X is the calculation_past_days_avg param.
get_navps_variation_inside_periods(fund_ids, reference_date, period_type, period_value, include_benchmarks=False, from_fund_start=False, convert_to_fund_currency=True, force_fund_currency_inside_period=None)
    Retrieve navps variations inside given periods (in months) until the reference_date.
    If period_type is 'month', retrieve month-by-month variations.
    If period_type is 'year', retrieve year-by-year variations.
    If include_benchmarks is True, also include benchmark varions in the same periods.
    If from_fund_start is True, include an extra variation period (from fund start date until the yearliest requested date).
    If convert_to_fund_currency is True, convert benchmark values to fund currency before computing variations

    force_fund_currency_inside_period is a workarround to enforce a certain currency for variations
    which star_date fall inside this period. The most appropriate solution for this would be to build the audit module,
    that would register the fund's currency changes through time.
    # TODO (VTaquette): change force_fund_currency_inside_period to a better solution

    'fund_ids': [int]
    'period_type': 'month' or 'year'
    'period_value': int
    'include_benchmarks': bool
    'force_fund_currency_inside_period': {(start_date, end_date): currency_id}

    returns: {fund (int): {'variations': [variation_by_period], 'benchmarks': [benchmarks] or None}}
        benchmarks: {benchmark_id (int): {'benchmark_id': int, 'benchmark_name': str, 'variations': [variation_by_period]}}
        variation_by_period: {'start_date': date, 'end_date': date, 'variation': decimal}
get_provision_category_info(ids=None, auto_accept_provisions=None)
    Returns the provision categories info.

    ids: [int]

    returns: {provision_category_id (int): {'id' (int), 'name' (str),
    'mellon_codes' (str) 'anbima_codes': str, 'auto_accept_provisions' (boolean),
    'pnl_allocation_criterion': PNL_ALLOCATION_CRITERIA}}

    Note: provision category IDs are the values in PROVISION_CATEGORIES.
set_positions_by_strategy(strategy_positions_to_set)
    Overrides strategies position for a certain snapshot.
    'strategy_positions_to_set': {'snapshot_id': int,
                                  'position_by_instrument_id': position_by_instrument_id}
                                  position_by_instrument_id: {instrument_id (int): position_by_strategy (JSON)}

    returns: This method does not return anything
get_latest_date_of_consolidate_attribution_by_asset(fund_ids)
    For each fund, returns the latest date in PeriodAttributionByAsset table.
    fund_ids: [int]

    returns: {fund_id (int): date (date)}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
get_average_nav(fund_ids, start_date, end_date)
    Returns simple average nav for each fund in the given period.

    'fund_ids': [int]
    'start_date': date
    'end_date': date

    returns: {fund_id (int): average_nav (decimal)}
send_mail_release_portfolio_report(fund_id, date)
get_snapshots_by_period(fund_id, start_date, end_date, s_type)
    Returns all fund's portfolio snapshot in provided period.

    fund_id: int
    start_date, end_date: date
    type: SNAPSHOT_TYPES

    returns: {'snapshot_id': snapshot}
        snapshot: {'snapshot_id': int or None, 'date': date or None, 'navps': decimal or None,
                    'navps_ex_amortizations': decimal or None}

    Returns an empty dictionary if no matching snapshot was found.
get_portfolio_from_snapshot(snapshot_ids, get_comparison=None, prefer_comparison_with_navps=True)
    Retrieves basic data for a snapshot ID.

    snapshot_id: [int]
    get_comparison: bool or None  # default: False

    returns: {snapshot_id (int): snapshot}
        snapshot: {'fund_id': int, 'date': date, 'status': SNAPSHOT_STATUS (int), 'comparison_id': int or None} or {}

    Returns an empty dictionary if the given ID is invalid.
has_attribution_data_for_period(fund_id, start_date, end_date, currency_id)
    Checks if the given fund has attribution data calculated with the provided
    currency_id in the period between start_date and end_date

    return {fund_id (int) : bool }
compare_snapshots(internal_snapshot_id, external_snapshot_id)
    Compares an internal (system-generated) snapshot and a corresponding external (imported) snapshot,
    and saves the differences found.

    internal_snapshot_id: int
    external_snapshot_id: int

    If the internal snapshot's status is Online and a comparison already exists, it is updated.
    In any other case a new comparison is created.

    returns: {'comparison_id': int}
set_snapshot_incoming_file_id(snapshot_ids, file_id=None, success=None)
    Sets snapshots' imported file IDs.

    snapshot_ids: [int]
    file_id: int or None
    success: bool or None

    returns: {'success': bool}
get_portfolio_overview_date_range(start_date, end_date, fund_ids=None, types=None, only_current=True, only_official_date=True, group_by_date=True, group_by_date_and_type=False, accept_older=None)
    Returns the portfolio overview in each date in the given range.
    'start_date': date
    'end_date': date
    'fund_ids': [int] or None
    'types': [SNAPSHOT_TYPE (int)] or None
    'only_current':  bool  # default: True
    'only_official_date':  bool  # default: True
    'group_by_date': bool  # default: True
    'group_by_date_and_type': bool  # default: False

    If accept_older is True and no snapshot exists for the given date, the closest snapshot
    going back in time will be selected. Snapshots copied from another date will have the original_date field filled

    If 'types' is specified, 'only_current' is ignored.
    If 'group_by_date' is enabled, only the latest entry (sorted by 'generated_on') is returned per fund-date pair.
    If 'group_by_date_and_type' is enabled, it takes precedence over 'group_by_date', and the latest entry
    per fund-date-type combination is returned. If both are disabled, all matched snapshots are returned.

    returns: {'items': [snapshot]}
        snapshot: {'id': int, 'fund_id': int, 'fund_name': string, 'date': date, 'is_official_date': bool,
                    'original_date': date, 'navps_ex_amortization':decimal,
                   'type': SNAPSHOT_TYPES (int), 'type_display': string,
                   'status': SNAPSHOT_STATUS (int), 'status_display': string,
                   'nav': decimal, 'navps': decimal, 'gross_navps': decimal, 'shares': decimal}
get_portfolio_instruments(fund_ids=None, date=None, instrument_type_ids=None, skip_zeroed_positions=False)
    Returns a list of ids of instruments in each input fund's portfolio on the provided date.
    If no date is passed, get the latest snapshots of portfolio.
    If skip_zeroed_positions is True, does not include assets with quantity = 0

    fund_ids: [int]
    date: date
    instrument_type_ids: [INSTRUMENT_TYPES (int)]

    returns: {fund_id(int): [instrument_id]}
        instrument_id: int
generate_portfolio_tb_posicoes_file(date=None, fund_ids=None, fund_group_ids=None, is_xls=True, view_zero_quantities=False)
    Generates an xls/sql file containing fund's porftolio data, using de "TB_POSICOES" (xpg) layout.

    date: date or None
    fund_ids: [int] or None
    is_xls: bool # Default: True

    returns: default success dictionary + {'file_ids': [int]}
get_provision_category_for_mellon_names()
    Returns the provision categories keyed by Mellon names.
    Please note that norm_str() has been applied on the dictionary's keys, and must be applied by the caller
    on the desired key as well before accessing the dictionary with [] or get().

    returns: {name (str): PROVISION_CATEGORIES (int)}
edit_operations(operations, skip_compliance_check=None)

    Returns: default success dictionary
add_operations(operations, auto_generate_snapshots=None, return_ids_on_input=False, skip_cash_provisions=False, report_missing_position_errors=True, dont_set_dirty_snapshot=False, skip_compliance_check=True, skip_asset_provisions=False, provision_value_decimal_places=None, provision_value_rounding_rule=None)
    Saves a group of asset operations to the database.

    'operations': [operation]
        operation: {'fund_id': int, 'instrument_id': int, 'account_id': int or None,
                    'date': date, 'asset_settlement_date': date, 'payment_settlement_date': date,
                    'type': OPERATION_TYPES (int) or None, 'quantity': decimal, 'price': decimal or None,
                    'no_cash_impact': bool or None, 'payment_account_id': int or None,
                    'payment_currency_id': int or None, 'payment_exchange_rate': decimal or None,
                    'broker_id': int or None, 'strategy_id': int or None, 'pnl_allocation_strategy_id': int or None,
                    'basket_id': int or None, 'origin_id': int or None, 'origin_content_type_id': int or None,
                    'deduce_strategy': {'instrument_id': int, 'date': date, 'split_operations': bool or None} or None,
                    'extra_values': dict or None, 'origin_instrument_id': int or None,
                    'brokerage_fee': decimal or None, 'rebate_percent': decimal or None,
                    'brokerage_in_account_currency': bool or None # default False,
                    'rollover_base_price': decimal or None, 'is_confirmed': bool or None
                    'is_system_generated': bool or None, 'emoluments_value': decimal or None,
                    yield_value: decimal or None, 'carrying_broker_id': int or None,
                    'carrying_brokerage_fee': decimal or None
                    }
    'auto_generate_snapshots': bool or None  # default: True  (only if date < today)
    'skip_cash_provisions': bool or None  # default: False
    'report_missing_position_errors': bool or None # default: True
    'dont_set_dirty_snapshot': bool  # default: False
    'skip_asset_provisions': bool or None # default: False
    'provision_value_decimal_places': decimal or None (applyes decimal places to provision value generated from operation)
    'provision_value_rounding_rule': decimal or None (applyes rounding rule to provision value generated from operation)

    'quantity' should be negative if selling an asset.
    'price' should always be positive and is the unit value in the instrument's currency.

    Either 'strategy_id' or 'deduce_strategy' should be supplied.
    If 'deduce_strategy' is used, the strategy ID(s) are inferred from the positions at the given date.

    If 'brokerage_fee' is set, the payment provision will include this value.
    It is assumed to be in the instrument's currency, unless 'brokerage_in_account_currency' is True,
    in which case it is considered to be in the payment account's currency.

    If price is 0/None, the instrument is a Future, Swap, Rollover or Forward, or if 'no_cash_impact' is True,
    the payment provision will not be created, unless there is a brokerage fee; in this case, a provision
    will be created with only the fee's value.
    If 'skip_cash_provisions' is True, no payment provision will be created (even if there is a brokerage fee).
    If 'skip_asset_provisions' is True, no asset provision will be created (even if there is a brokerage fee).

    If 'return_ids_on_input' is True, input operations will be changed, adding the newly created object id.

    The asset settlement account ('account'), if specified, must be in the instrument's currency.

    The operation may settle in a different currency from the instrument, by setting 'payment_currency_id'
    to a currency differing from the instrument's currency, or by setting 'payment_account_id' to an account
    in a different currency (if both are informed, their currencies must match, or an Exception will be raised).
    If that happens, currency conversion will be performed, using 'payment_exchange_rate' if supplied,
    otherwise using the system's rate at the operation date. 'payment_exchange_rate' is expected to be in the
    direction: from the instrument's currency to the payment account's currency.

    If operation involves a rollover instrument, also creates automatically the derived operations on underlying instruments.

    returns: {'success': bool, 'operation_ids': [int]}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_exposure_by_asset(start_date, end_date, fund_ids=None, instrument_ids=None, currency_ids=None, sort_by_exposure=True, assets_as_columns=False, strategy_consolidation=1, lookthrough=True, instrument_type_ids=None, funds_as_columns=False, group_by=None)
    Returns information on multiple funds' exposures to assets/issuers/currencies in a date range,
    as well as basic snapshot overview info, in tabular format.
    Please note that this API is database-intensive.

    start_date: date
    end_date: date
    fund_ids: [int] or None
    instrument_ids: [int] or None
    currency_ids: [int] or None
    sort_by_exposure: bool  # default: True (if false, will sort alphabetically)
    group_by_currency: bool  # default: False
    group_by_issuer: bool  # default: False
    assets_as_columns: bool  # default: False
    instrument_type_ids: [int] or None

    Only one of 'group_by_currency' or 'group_by_issuer' or 'group_by_sector' may be selected.
    A ValueError will be raised if more than one is True.

    If assets_as_columns and funds_as_columns are False:
    returns: {'items': [item], 'columns': None}
        item: {'date': date, 'fund_name': string, 'navps': decimal, 'nav': decimal, 'name': string,
               'currency_name': string, 'exposure': decimal, 'decimal_places_nav': int, 'decimal_places_navps': int}

    If assets_as_columns:
    returns: {'items': [item], 'columns': [string]}
        item: {'date': date, 'fund_name': string, 'navps': decimal, 'nav': decimal, 'name': string,
               'assets': [decimal or None]}

    If funds_as_columns:
    # TODO (VTaquette): fix documentation
    returns: {'items': [item], 'columns': [string]}
        item: {'date': date, 'fund_name': string, 'navps': decimal, 'nav': decimal, 'name': string,
               'assets': [decimal or None]}
is_portfolio_released(fund_id, dates)
    For each input date, tells whether the fund's snapshot for that day has been released (approved).

    'fund_id': int
    'dates': [date]

    returns: {date: boolean or None}

    If the snapshot doesn't exist yet for a given date, that day's value is None.
set_snapshot_dirty(fund_ids, date)
    Marks the given funds' snapshots as being dirty, i.e. requiring recalculation, from the given date onwards.

    fund_ids: [int]
    date: date
    save: bool  # whether to save in the database or just update the cache

    returns: {'success': bool}
old_get_operations(ids=None, fund_ids=None, dates=None, date_type=None, start_date=None, end_date=None, types=None, sent_to_administrator=None, is_confirmed=None, instrument_ids=None, broker_id=None, strategy_id=None, group_aggregation=None, origin_ids=None, origin_content_type_id=None, payment_settlement_date=None, asset_start_settlement_date=None, account_ids=None, include_inactive_funds=False, basket_ids=None, instrument_types=None, include_instrument_type=False, broker_ids=None)
    Retrieves operation information. Accepts optional filters.
    Depending on group_aggregation , operations can be grouped into ('date', 'asset_settlement_date, 'fund_id', 'instrument_id',
    'side'). For grouped results, the 'price' key will be the weighted average over all operation prices in the group
    and the 'quantity' will be the sum of quantities in the group. Specific operation fields, such as 'account' and
    'strategy', will be set to None in grouped results. Also in groups, the 'id' key for operation will be an unique
    id representing the group. In this case, it's possible to get the operation_ids of the group in the 'operation_ids'
    field.

    ids: [int] or None
    fund_ids: [int] or None
    dates: [date] or None
    date_type: TRANSACTION_FILTER_DATE_TYPES (int) or None  # default: conversion_date
    start_date: date or None
    end_date: date or None
    types: [OPERATION_TYPES (int)] or None
    sent_to_administrator: boolean or None
    is_confirmed: boolean or None
    instrument_ids: [int] or None
    broker_id: int or None
    strategy_id: int or None
    group_aggregation: OPERATION_AGGREGATION_TYPE (int) or None
    origin_ids: [int] or None
    origin_content_type_id: int or None
    payment_settlement_date: date or None
    asset_start_settlement_date: date or None
    account_ids: [int] or None
    include_inactive_funds: bool  # default: False
    basket_ids: [int] or None
    instrument_types: [INSTRUMENT_TYPES] or None
    include_instrument_type: bool
    broker_ids: [int] or None

    returns: {id (str or int): operation_or_group}
        operation_or_group: {'id': int, 'fund_id': int, 'is_confirmed': bool, 'instrument_id': int, 'strategy_id': int,
                             'account_id': int, 'type': OPERATION_TYPES (int),
                             'is_confirmed': bool, 'sent_to_administrator': bool,
                             'date': date, 'asset_settlement_date': date, 'payment_settlement_date': date,
                             'quantity': Decimal, 'price': Decimal, 'financial_value': Decimal,
                             'origin_id': int or None, 'origin_content_type_id': int or None, 'broker_id': int,
                             'extra_values': dict, 'instrument_name':str, 'fund_name': str, 'strategy_name':str,
                             'account_name': str, 'broker_name': str or None, 'brokerage_fee': Decimal
                             'payment_exchange_rate': Decimal or None, 'payment_currency_id': int,
                             'payment_account_id': int,
                             # Fields present only when there is aggregation
                             'operation_ids': [int]}
is_snapshot_dirty(fund_ids, date)
    Returns whether the given funds' current snapshots in the selected date are dirty.

    fund_ids: [int]
    date: date

    returns: {fund_id (int): bool}
replace_external_snapshot_account_ids(snapshot_id, accounts_by_balance)
    Temporary method to replace all account_ids from an external snapshot by the balances provided as parameters.
    Used since xml version 4.1 does not supply any account info.

    snapshot_id: int
    accounts_by_balance: {balance (Decimal): account_ids}

    returns: default success dictionary
asset_exists_by_instrument(instrument_id=None)
    Check if a instrument was ever allocated to a snapshot
get_attribution_value_by_snapshot(snapshot_ids)
get_counters()
    Returns information on the counters and locks used for snapshot generation.

    returns: {'snapshot_generation': {
        'full': bool, # ongoing generate-all requests (all funds for a given date)
        'active': bool, # ongoing generation requests of any type
        'waiting': bool,  # requests waiting for the Save lock to be available
        'saving': bool,  # requests inside the Save section
    }}
get_instruments_group_exposure(group_id, fund_ids, date, use_gross_nav)
    Gets the exposure (as a percentage of the NAV) of the input funds to the specified group of instruments.

    group_id: int
    fund_ids: int
    date: date

    returns {group_id (int): group_exposure_by_fund}
        group_exposure_by_fund: {fund_id (int) : exposure (Decimal)}
get_reason_for_snapshot_generation_failure(fund_id, date, user_id)
    Returns a human-readable reason explaining why a snapshot could not be recalculatd.

    fund_id: int
    date: date
    user_id: int

    returns: {'reason': string}
get_snapshots_for_date(fund_ids, date=None, accept_older=None, only_current=None, only_official_date=None, only_released=None)
get_funds_first_snapshot(fund_ids, values=None)
    Returns the fund's oldest portfolio snapshot

    fund_ids: [int] or None
    values: [str] or None

    returns: {'fund_id': snapshot} or {}
        snapshot: {portfolio.Snapshot.values() or 'values'}

    Returns an empty dictionary if no matching open snapshot was found.
get_latest_date_with_navps(fund_ids)
    Returns, for each fund, the latest date with a NAVPS.

    fund_ids: [int]

    returns: {fund_id (int): date}
save_confirm_operation_by_ids(operation_ids=None, action=True)
    Updates the given fund operations is_confirmed to True

    operations_ids: list
    action: bool # confirm, unconfirm (confirm = default)

    returns: {'success': bool, 'error_msg': string or None}
get_funds_portfolio_overview_for_trading(date, fund_ids, preferences, accept_older=True)
has_attribution_data_for_currency(snapshot_id, currency_id)
    Checks if the given snapshot has attribution data calculated for the provided currency_id

    return bool
get_snapshots_from_comparisons(comparison_ids)
    Get snapshots of portfolios involved in comparison

    'comparison_id': [Int]

    returns: {'internal_snapshot':Object,'external_snapshot':Object}
get_assets(date=None, end_date=None, fund_ids=None, snapshot_ids=None, instrument_ids=None, instrument_type_ids=None, merge_lending_instruments=True, skip_currency_instruments=True, include_balances_and_provisions=False, group_provisions=False, group_balances=False, consolidate_strategies=True, combine_fund_output=False, accept_older=True, display_currency_id=None, custom_consolidation=None, segregate_related=False, operations=None)
    Returns a list of assets in each input fund's portfolio on the provided date.

    This method differs from 'get_portfolio_assets' since it looks only for basic information of the assets,
    does not perform look-through, and is optimized for multiple funds.

    date: date or None
    end_date: date or None
    fund_ids: [int] or None
    snapshot_ids: [int] or None
    instrument_ids: [int] or None
    instrument_type_ids: [INSTRUMENT_TYPES (int)] or None
    merge_lending_instruments: bool  # default: True
    skip_currency_instruments: bool  # default: True
    include_balances_and_provisions: bool  # default: False
    group_provisions: bool  # default: False
    group_balances: bool  # default: False
    consolidate_strategies: bool  # default: True
    combine_fund_output: bool  # default: False
    accept_older: bool  # default: True
    display_currency_id: int or None
    consolidate_snapshots: bool # default: False
    segregate_related: bool # default: False

    By default, only current-type snapshots are considered.
    However, if snapshot IDs are supplied, type-checking is disabled and the specified snapshots are returned.
    One of either date or snapshot_ids must be supplied.

    If end_date is informed, the (start) date argument is required, accept_older is set to false,
    and combine_fund_output is set to true.

    If group_provisions is True, provisions are grouped by category + currency (+ strategy).
    If group_balances is True, cash balances are grouped by currency (+ strategy).

    Please note that all prices and financial values are in the display currency, which is each fund's currency
    by default (if display_currency_id is not informed). Assets' exchange rates are from the original currency
    to the display currency.

    returns: {fund_id (int) or 'entries': [asset], [balance] or [provision]}
        base: {'date': date, 'name': string, 'type_name': string, 'nav_value': Decimal,
               'attribution': Decimal, 'attribution_value': Decimal,
               'currency_id': int, 'original_currency_id': int, 'exchange_rate': Decimal or None}
              # if consolidate_strategies is False:
              + {'strategy_id': int, 'strategy_name': string}
              # if combine_fund_output is True:
              + {'fund_id': int, 'fund_name': string}
        asset: base + {'instrument_id': int, 'type_id': int, 'quantity': Decimal, 'price': Decimal,
                       'available_quantity': Decimal, 'provisioned_quantity': Decimal, ''collateral_quantity': Decimal'}
                      # if merge_lending_instruments is True:
                      + {'lent_quantity': Decimal, 'borrowed_quantity': Decimal}
        balance: base
        provision: base + {'category_id': int, 'category_name': string, 'provision_id': int or missing, 'origin_id': int, 'origin_instrument_id':int or None, 'extra_values': {extra_values}}
            extra_values: {'start_date': date or missing, 'transferred_fx_attribution': Decimal or missing, 'transferred_attribution': Decimal or missing}
get_portfolios_overview_report_info(date=None, group_type=None, accept_older=True, fund_ids=None, include_vol_data=False, include_benchmark_data=False, include_usd_nav=False, include_12m_nav=False, include_gross_navps=False, include_net_captation_data=False, include_6m_profitability=False, include_12m_profitability=False, include_18m_profitability=False, include_24m_profitability=False, include_36m_profitability=False, include_60m_profitability=False, include_fund_start_profitability=False, include_funds_start_date=False, include_cash_balance=False, include_adm_fee=False, include_pfee=False)
    Returns funds' profitability data.
    If the date is not supplied, the latest snapshot for each fund is used.
    If accept_older is True and no snapshot exists for the given date, the closest snapshot
    going back in time will be selected.

    If administrator navps is approved, use it's value instead of internal snapshot value.

    'date': date or None
    'group_type': FUND_GROUP_TYPES or None # default FUND_GROUP_TYPES.for_portfolios_overview_report
    'accept_older': bool or None  # default: True
    'fund_ids': [int] or None
    'include_vol_data': bool # default: True
    'include_benchmark_data': bool # default: True
    'include_usd_nav': bool # default: False
    'include_12m_nav': bool # default: False
    'include_gross_navps': bool # default: False
    'include_net_captation_data': bool # default: False
    'include_6m_profitability': bool # default: False
    'include_12m_profitability': bool # default: False
    'include_18m_profitability': bool # default: False
    'include_24m_profitability': bool # default: False
    'include_36m_profitability': bool # default: False
    'include_60m_profitability': bool # default: False
    'include_fund_start_profitability': bool # default: False
    'include_funds_start_date': bool # default: False
    'include_cash_balance': bool # default: False
    'include_adm_fee': bool # default: False
    'include_pfee': bool # default: False

    returns: {'groups': [group],
            'indices': [index],
            'include_vol_data': bool,
            'include_benchmark_data': bool,
            'include_usd_nav': bool,
            'include_12m_nav': bool,
            'include_gross_navps': bool,
            'include_net_captation_data': bool,
            'include_6m_profitability': bool,
            'include_12m_profitability': bool,
            'include_18m_profitability': bool,
            'include_24m_profitability': bool,
            'include_36m_profitability': bool,
            'include_60m_profitability': bool,
            'include_fund_start_profitability': bool,
            'total_aum': decimal,   # total NAV of funds contained in at least one group
            'total_usd_aum': decimal or None,
            'funds_with_no_group': str #list of fund_names of funds not included in any group.
                                    Only applicable if a group_type is provided
            }

            group: {'group_name': str,
                    'total_brl_nav': decimal,
                    'total_usd_nav': decimal,
                    'aum_percentage': decimal,
                    'items': [item]}
            index: {'instrument_name': str,
                    'price_date': date,
                    'price': decimal,
                    '..._profitability': decimal, # one item for each selected period
                    }
get_provision_category_for_codes(codes=None, file_type=None)
    Returns the provision categories keyed by codes.
    Returned values are None for specified codes with no associated category.
    If the codes list is omitted, all registered codes are returned.

    codes: [int]

    returns: {code (int): provision_category_id (int) or None}

    Note: provision category IDs are the values in PROVISION_CATEGORIES.
undo_snapshot_freeze(snapshots)
    Undoes the freezing of one or more snapshots.

    snapshots: [snapshot]
        snapshot: {'fund_id': int, 'date': date, 'values': [str]}

    Valid values are: 'nav', 'navps' and 'shares'.

    returns: default success dict
release_snapshots(*args, **kwargs)
get_position_by_strategy(date, fund_ids, currency_id)
    Returns the total invested amount in each strategy.

    fund_ids: [int] or None
    date: date
    currency_id: int

    returns: {'items': [item]}
        item: {'strategy_id': int, 'strategy_name': str, 'total_investment': decimal, 'investment_percentage': decimal}
set_date_as_holiday_for_snapshots(holidays)
    Marks any existing snapshots matching the given date and holiday information as non-official snapshots.

    holidays: [holiday]
        holiday: {'holiday_date': date, 'is_recurring': boolean, 'recurrence_year_end': int or None,
                  'fund_holiday_types': [int]}

    returns: {'success': bool, 'error_msg': string or None, 'funds_affected': {fund_id (int): name (string)}}
get_instruments_exposure(instrument_ids, fund_ids, use_portfolio_price=None, use_managerial_nav=None, date=None, return_nav=False, price_by_instrument=None, spare_provisions=None, strategy_ids=None, use_gross_nav=False)
    Gets the exposure (as a percentage of the NAV), the quantity, value and unit_value of the input funds to
    the specified input instrument.

    If use_portfolio_price is True, the exposure is calculated with the portfolio price, otherwise the exposure
    is calculated with the latest price of the Instrument from the Assets module.
    Optionally, an specific price may be passed as parameter. So this price will be used instead of current price.
    Note that if use_portfolio_price is True, the price is already in the funds currency, but if not an exchange
    rate must be applied.

    If use_managerial_nav is True, the exposure is calculated with the managerial NAVs if they exist.
    If a date is set, all values returned will consider the snapshots and prices of that day.
    If return_nav is True, the nav of each fund will be returned, for optimization.

    If spare_provisions is set, the NAVs will be increased/decreased by the values given for each fund.

    instrument_ids: [int]
    fund_ids: [fund_id (int)]
    use_portfolio_price: bool or None  # default: True
    use_managerial_nav: bool or None  # default: False
    spare_privisions: {fund_id: decimal}
    strategy_ids: [int] or None

    returns: {instrument_id (int): exposure_by_fund }
        exposure_by_fund : {fund_id (int): fund}
        fund: {'exposure': Decimal, 'quantity': Decimal, 'value': Decimal, 'unit_value': Decimal}
save_snapshot(fund_id, date, values, assets, balances, provisions, snapshot_type, copy_types=None, currency_exposures=None, is_official_date=None, force_status=None, reopen=False, compare=True, stream=None, incoming_file_id=None, look_through_investment_tree=None, custodian_id=None, administrator_id=None, template=None, replace_imported_xmls=None)
    Saves a calculated snapshot to the database. Afterwards, runs a new comparison if the fund has at least
    one current and one administrator snapshot at the given date.

    If 'reopen' is False (default), an error will be issued when attempting to save a current snapshot
    at a date where the portfolio had already been released.
    If 'compare' is True (the default), a comparison will be run against the administrator snapshot if it exists.

    fund_id: int
    date: date
    values: {'nav': decimal, 'navps': decimal, 'shares': decimal, 'gross_navps': decimal,
             'managerial_nav': decimal or None, 'navps_variation_previous_day': decimal or None
             'navps_ex_amortizations': decimal}
    assets: [asset]
    balances: [balance]
    provisions: [provision]
    currency_exposures: [currency_exposure] or None
    snapshot_type: SNAPSHOT_TYPES (int)
    copy_types: [SNAPSHOT_TYPES (int)] or None
    is_official_date: boolean or None
    reopen: boolean  # default: False
    compare: boolean  # default: True
    stream: stream or None  # enables profiling
    look_through_investment_tree: json or None
    template: None or SNAPSHOT_TEMPLATES (int)
    incoming_file_id: int or None
        asset: {'name': string, 'instrument_id': instrument_id or None, 'nav_unit_value': decimal, 'nav_value': decimal,
                'quantity': decimal, 'provisioned_quantity': decimal, 'collateral_quantity': decimal,
                'quantities_by_strategy': {strategy_id (int): decimal},
                'lending_underlying_instrument_id': int, 'original_currency_id': int or None,
                'attribution': Decimal or None, 'attribution_nominal_value': Decimal, 'attribution_fx_value': Decimal,
                'extra_values': {value_identifier (string): value (any)} or None, 'lent_quantity': decimal or none, 'borrowed_quantity': decimal or none}
        balance: {'name': string, 'account_id': int or None, 'nav_value': decimal, 'original_currency_id': int or None,
                  'value_by_strategy': {strategy_id (int): decimal}, 'attribution': Decimal or None,
                  'attribution_nominal_value': Decimal, 'attribution_fx_value': Decimal,
                  'extra_values': {value_identifier (string): value (any)} or None}
        provision: {'name': string, 'category_id': int, 'is_settled': boolean, 'settlement_date': date or None,
                    'nav_value': decimal, 'value_by_strategy': {strategy_id (int): decimal},
                    'original_currency_id': int or None,
                    'attribution': Decimal or None, 'attribution_nominal_value': Decimal,
                    'attribution_fx_value': Decimal, 'extra_values': {value_identifier (string): value (any)} or None}

    returns: {'snapshot_id': int, 'comparison_id': int or None} or {'error_msg': string}
get_portfolio_assets(fund_ids=None, date=None, include_lending_quantities=None, operations=None, check_look_throughs=None, full_look_through=None, force_full_look_through=None, look_through_instrument_ids=None, get_attribution_breakdown=False, snapshot_id=None, accept_older=None, group_provisions=None, skip_cleared_provisions=None, skip_currency_instruments=None, currency_id=None, fund_multipliers=None, strategy_ids=None, consolidate_strategies=True, investment_vehicle_accounts_for_nav=False, combine_entries=False, instrument_ids=None, skip_looked_through_instruments=False, exclude_instrument_ids=None, consolidate_agreements=False, filter_relevant_swap_positions=False)
    Returns the fund's asset portfolio at the specified date with detailed information.
    Look-through can be enabled in a per-instrument basis or in full depth.
    Operations not yet committed to the database can optionally be incorporated to the snapshot.
    If accept_older is True and no snapshot exists for the given date, the closest snapshot
        going back in time will be selected.

    If multiple fund IDs are passed, their assets are *consolidated*.
    In this case, lookthrough is automatically disabled (lookthrough arguments are ignored),
    'snapshot_id' is ignored, 'accept_older' is ignored and 'date' is required.
    If 'currency_id' is not specified, one of the funds will be selected randomly and its currency will be used.
    Fund multipliers can be indicated with the 'fund_multipliers' parameter.

    Funds' assets can be optionally filtered by strategy. The way results are presented depend on the flag
    consolidate_strategies; if True (the default), one entry will be returned per asset, with strategy information
    inside it; if False, one entry will be returned per asset-strategy pair.

    If the date is not supplied, the latest snapshot for the fund is used.
    If no snapshot ID is given, only snapshots with the 'current' type are considered.

    The optional flag 'include_lending_quantities' adds the lent quantities (of the current lending agreements)
    to the total quantity of each asset
    The optional flag' skip_currency_instruments' causes currency instruments not to be included in 'assets'.

    If 'combine_entries' is True, assets, balances and provisions are combined into a single 'entries' key.
    In this case, 'skip_currency_instruments' is automatically set to True.

    If 'full_look_through' is True, the system applies LT to all internal funds where enable_full_lookthrough=True.
    If 'force_full_look_through' is True, the system applies LT to all internal funds, regardless of their LT parametrization.

    'fund_ids': [int] or None
    'date': date or None
    'include_lending_quantities': bool or None  # default: False
    'operations': [operation] or None
        operation: {'fund_id': int or None, 'instrument_id': int, 'quantity': Decimal, 'side': ORDER_SIDES (int),
                    'price': Decimal, 'instant_settlement: bool or None}
    'check_look_throughs': bool or None  # default: False
    'full_look_through': bool or None  # default: False
    'look_through_instrument_ids': [int] or None
    'get_attribution_breakdown': bool # default False
    'snapshot_id': int or None
    'accept_older': bool or None  # default: False
    'group_provisions': bool or None  # default: True
    'skip_cleared_provisions': bool or None  # default: False
    'currency_id': int or None
    'fund_multipliers': {fund_id (int): mult_info} or None
        mult_info: {'multiplier': Decimal, 'by_strategy': {strategy_id (int): multiplier (Decimal)} or None/missing}
    'strategy_ids': [int] or None
    'consolidate_strategies': bool  # default: True
    'investment_vehicle_accounts_for_nav': bool or None # default False
    'combine_entries': bool  # default: False
    'instrument_ids': [int] or None

    returns: {'snapshot_id': int or None, 'fund_ids': [int], 'date': date, 'nav': decimal,
              'look_through_fund_ids': [look_through_fund_id (int)],
              'currency_id': int, 'currency_exchange_source_ids': [int]} or {}
              + {'assets': [asset], 'balances': [balance], 'provisions': [provision]} # if 'combine_entries' is False
              + {'entries': [asset/balance/provision]}                                # if 'combine_entries' is True
        asset: {'item_id': int or None, 'instrument_id': int,
                'type_id': int, 'type_identifier': string, 'display_type': string,
                'name': string, 'quantity': decimal, 'available_quantity': decimal, 'look_through_quantity': decimal,
                'lent_quantity': decimal, 'borrowed_quantity': decimal, 'provisioned_quantity': decimal,
                'collateral_quantity': decimal, 'lender_collateral_quantity': decimal, 'look_through_quantities': look_through_quantities,
                'nav_unit_value': decimal, 'old_nav_unit_value': decimal, 'delta_price': decimal, 'nav_value': decimal,
                'exposure_value': decimal, 'issuer_id': int,
                'price_date': date, 'price_generated_on': datetime, 'price_source': PRICE_SOURCES,
                'attribution': decimal, 'attribution_nominal_value': decimal, 'attribution_fx_value': decimal,
                'strategy_id': int or None, 'strategy_name': string or None,
                'quantities_by_strategy': {strategy_id (int): quantity (decimal)},
                # The remaining fields are optional (may be None/missing) depending
                # on the instrument type and other attributes.
                'can_look_through': boolean, 'is_looking_through': boolean,
                'exchange_rate': decimal, 'original_currency_id': int, 'original_nav_value': decimal,
                'original_nav_unit_value': decimal, 'expiration_date': date,
                'settlement_price': decimal, 'vol': decimal, 'delta': decimal,
                'swap_underlying_nav_unit_value': decimal,
                'yield': decimal, 'clean_mid': decimal}
            look_through_quantities: {fund_id (int): {'quantity': decimal, 'fund_id': int}}
        balance: {'instrument_id': int, 'item_id': int, 'display_type': string,
                  'account_id': int or None, 'name': string, 'nav_value': decimal,
                  'exposure_value': decimal, 'attribution': decimal, 'attribution_nominal_value': decimal,
                  'attribution_fx_value': decimal, 'strategy_id': int or None, 'strategy_name': string or None,
                  'value_by_strategy': {strategy_id (int): value (decimal)},
                  # The remaining fields are optional (may be None/missing).
                  'exchange_rate': decimal, 'original_currency_id': int, 'original_nav_value': decimal}
        provision: {'instrument_id': int, 'item_id': int or None, 'display_type': string,
                    'category_id': int, 'name': string, 'origin_provision_id': int or None,
                    'nav_value': decimal, 'exposure_value': decimal, 'is_settled': boolean, 'settled_quantity': decimal,
                    'attribution': decimal, 'attribution_nominal_value': decimal, 'attribution_fx_value': decimal,
                    'strategy_id': int or None, 'strategy_name': string or None,
                    'value_by_strategy': {strategy_id (int): value (decimal)},
                    # The remaining fields are optional (may be None/missing).
                    'exchange_rate': decimal, 'original_currency_id': int, 'original_nav_value': decimal,
                    'allocate_fx_attribution_separately': bool}

    Returns an empty dictionary if no suitable portfolio snapshot exists for the given date.

    If skip_looked_through_instruments is False (the default), lookthrough-enabled assets will have None
    in the 'nav_value' field. Otherwise, they will not be returned at all.

    If consolidate_by_strategy is True (default), 'strategy_id' and 'strategy_name' are None.
get_instruments_quantity(iids, fund_ids, date, snapshot_ids=None, strategy_ids=None, use_gross_nav=None, get_group_exposure=True, instrument_type_identifiers=None)
    Retrieves the current quantity of instruments in the fund portfolios.

    iids: [int] or None
    fund_ids: [int] or None
    strategy_ids: [int] or None
    snapshot_ids: [int] or None
    date: date

    returns: {instrument_id (int): funds, 'groups': group_position}
        funds: {fund_id (int): position}
            position: {'quantity': int, 'instrument_type': INSTRUMENT_TYPE_IDENTIFIERS, 'nav': Decimal, 'group_quantity': int}
        group_position: { group_id: group_fund_position }
            group_fund_position: { fund_id: instrument_quantity }
                instrument_quantity: { instrument_id : Decimal }
get_current_nav(fund_ids=None, date=None, accept_older=None, use_managerial_nav=None)
    Retrieves the NAV of each specified fund's current snapshot.

    If use_managerial_nav is True, the managerial NAV are used rather than the official NAV, if they exist.

    If date is None, lastest NAV is returned.

    funds: [fund_id (int)]
    date: date or None
    accept_older: bool or None  # default: True
    use_managerial_nav: bool or None  # default: False

    returns: {fund_id (int): NAV (decimal)}
add_portfolio_transfers(transfers, **kwargs)
    Registers instrument transfers between portfolios (possibly changing account/strategy).

    transfers: [transfer]
        transfer: {'instrument_id': int, 'date': date, 'quantity': Decimal,
                   'account_from_id': int, 'account_to_id': int,
                   'strategy_from_id': int, 'strategy_to_id': int, 'price': Decimal or None,
                   'is_automatic': bool or None (default: False)}
    **kwargs: accepts all named parameters of API portfolio.add_operations()

    returns: {'success': bool, 'transfer_ids': [int]}
get_portfolio_comparison_details(comparison_ids, discrepancy_filter_types=None)
    Returns the comparison detailed (discrepancies) data for the given comparison_id.

    comparison_ids: [int]
    discrepancy_filter_types : [DISCREPANCY_TYPES_FOR_FILTERING (int)] or None

    returns: {comparison_id (int): item or None}
        item: {'snapshot': snapshot, 'comparison': comparison}
        snapshot: {'fund_id': int, 'fund_name': string, 'fund_currency': currency, 'date': date,
                   'status': SNAPSHOT_STATUS (int), 'unconverted_transactions': [transaction] }
            currency: {'id': int, 'name': string, 'name_plural': string, 'prefix': string, 'acronym': string}
            transaction: {'transaction_id': int or None, 'conversion_date': date, 'value': decimal, 'is_converted': boolean,
                          'redemption_shares': decimal or None}
        comparison: {'comparison_id': int, 'status': COMPARISON_STATUS (int), 'status_class': string,
                          'status_name': string, 'internal_snapshot_id': int, 'external_snapshot_id': int,
                          'incoming_file_id': int or None, 'incoming_file_log_url': string or None,
                          'nav_absolute_difference': decimal, 'nav_relative_difference': decimal,
                          'navps_absolute_difference': decimal, 'navps_relative_difference': decimal,
                          'profitability_absolute_difference': decimal or None, 'compared_on': datetime,
                          'profitability_relative_difference': decimal or None, 'asset_groups': [group]}
                group: {'identifier': string, 'discrepancies': [discrepancy], 'has_details': bool}
                    discrepancy: {'id': int, 'name': string, 'description': string, 'type': DISCREPANCY_TYPES (int),
                                  'can_accept': boolean, 'nav_value_diff': decimal, 'nav_value_percent_diff': decimal,
                                  'unit_value_diff': decimal or None, 'unit_value_percent_diff': decimal or None,
                                  'instrument_original_currency_id': int or None, exchange_rate: decimal or None,
                                  'is_agreement': bool or None, 'details': details or None}
                        details: {'internal': [{'name': string, 'value': decimal}],
                                  'external': [{'name': string, 'value': decimal}],
                }
get_provision_category_for_anbima_codes(codes=None, administrator_id=None)
    Returns the provision categories keyed by Anbima codes.
    Returned values are None for specified codes with no associated category.
    If the codes list is omitted, all registered codes are returned.

    codes: [int]

    returns: {code (int): provision_category_id (int) or None}

    Note: provision category IDs are the values in PROVISION_CATEGORIES.
recalculate_snapshots_after_adding_operations(operations, user_id)
get_navps_variation_multiple_periods(fund_ids, reference_date, periods, from_fund_start=False, include_benchmarks=False, normalize_results=None, convert_to_fund_currency=True, force_fund_currency_inside_period=None)
    Retrieve navps variations in given periods (in months) until the reference_date.
    If from_fund_start is True, include an extra variation period (from fund start date until reference_date).
    If include_benchmarks is True, also include benchmark varions in the same periods.
    normalize_results may assume the values 'monthly' or 'annualy'
    If convert_to_fund_currency is True, convert benchmark values to fund currency before computing variations

    force_fund_currency_inside_period is a workarround to enforce a certain currency for variations
    which star_date fall inside this period. The most appropriate solution for this would be to build the audit module,
    that would register the fund's currency changes through time.
    # TODO (VTaquette): change force_fund_currency_inside_period to a better solution

    'fund_ids': [int]
    'periods': [int]
    'include_benchmarks': bool
    'normalize_results': str
    'from_fund_start': bool
    'force_fund_currency_inside_period': {(start_date, end_date): currency_id}

    retunrs: {fund (int): {'variations': variation_by_period, 'benchmarks': benchmarks or None}}
        variation_by_period: {num_months (int): variation (decimal), 'from_start': variation)
        benchmarks: {benchmark_id (int): {'benchmark_id': int, 'benchmark_name': str, 'variations': [variation_by_period]}}
set_snapshot_dirty_multiple_dates(entries)
    Marks the given funds' snapshots as being dirty, i.e. requiring recalculation, from the given dates onwards.
    The API code is optimized to handle multiple entries by fund effectively.

    entries: [entry]
        entry: {'fund_id': int, 'date': date}

    returns: {'success': bool}
get_instrument_exposure(instrument_id, fund_ids, use_portfolio_price=None, use_managerial_nav=None, date=None, return_nav=False, price=None, spare_provisions=None, strategy_ids=None, use_gross_nav=False)
    Gets the exposure (as a percentage of the NAV), the quantity, value and unit_value of the input funds to
    the specified input instrument.

    If use_portfolio_price is True, the exposure is calculated with the portfolio price, otherwise the exposure
    is calculated with the latest price of the Instrument from the Assets module.
    Optionally, an specific price may be passed as parameter. So this price will be used instead of current price.
    Note that if use_portfolio_price is True, the price is already in the funds currency, but if not an exchange
    rate must be applied.

    If use_managerial_nav is True, the exposure is calculated with the managerial NAVs if they exist.
    If a date is set, all values returned will consider the snapshots and prices of that day.
    If return_nav is True, the nav of each fund will be returned, for optimization.

    If spare_provisions is set, the NAVs will be increased/decreased by the values given for each fund.

    Instruments' group exposure are only returned in case a date is provided.

    instrument_id: int
    fund_ids: [fund_id (int)]
    use_portfolio_price: bool or None  # default: True
    use_managerial_nav: bool or None  # default: False
    spare_privisions: {fund_id: decimal}
    strategy_ids: [int] or None

    returns: {fund_id (int): fund}
        fund: {'exposure': Decimal, 'quantity': Decimal, 'value': Decimal, 'unit_value': Decimal}
copy_snapshots(snapshot_ids, snapshot_type)
    Creates a fixed copy of one or more snapshots. The copy's snapshot type must be specified, and cannot be 'current'.

    snapshot_ids: [int]
    snapshot_type: SNAPSHOT_TYPES (int) or None

    returns: {source_snapshot_id (int): copy_snapshot_id (int)}
get_equities_exposure_for_dates(dates, fund_ids)
    Returns the equity exposure information for the given funds in all provided dates.

    dates: [Date]
    fund_ids [int]

    returns {fund_id: {equity_exposure_info}}
        equity_exposure_info: {date: value}
get_fofs_position_by_redemption_term(date, fund_id)
    Returns the total expore (nav %) for each redeption term of invested funds.

    fund_id: int
    date: date

    returns: {'items': [item] or None, 'errors': [Django form error] or None}
             item: {'redeption_term': int, 'mandate': decimal, 'exposure': decimal}
get_attribution_data_for_snapshots(snapshot_ids, currency_id)
    Gets attribution data from AttributionBreakdown Table

    returns {snapshot_id : snapshot}
        snapshot: {'assets': {asset_id: item_attribution},
                   'provisions': {provision_id: item_attribution},
                   'balances': {balance_id : item_attribution}
        item_attribution: {'attribution_value': Decimal, 'attribution_fx_value': Decimal}
get_instrument_position(instrument_ids=None, fund_ids=None, snapshot_ids=None, strategy_ids=None, date=None, include_lending_quantities=None, accept_older=None, instrument_type_identifiers=None, prices=None, use_gross_nav=None, get_group_exposure=False)
    Retrieves the current quantity of instruments and their corresponding value and unit_value in the fund portfolios.
    If no date is provided gets the latest portfolio.
    If accept older is True (default), gets the closest snapshot to the given date.

    instrument_id: [int] or None
    fund_ids: [int] or None
    strategy_ids: [int] or None
    snapshot_ids: [int] or None
    date: date or None
    include_lending_quantities: bool or None  # default: True
    accept_older: bool or None  # default: True
    instrument_type_identifiers: [INSTRUMENT_TYPE_IDENTIFIERS (string)]
    prices: {instrument_id: decimal} or None

    returns: {instrument_id (int): funds}
        funds: {fund_id (int): position}
            position: {'quantity': Decimal, 'value': Decimal, 'unit_value': Decimal,
                       'exposure_value': Decimal, 'exposure_unit_value': Decimal, 'nav': Decimal, 'name': str}

    All values are in the fund's currency. 'quantity' is always the number of units, and
    'unit_value'/'exposure_unit_value' are the prices per unit, even when the asset is negotiated in multiplier blocks.
get_navps_variations(fund_id, date=None, snapshot=None, num_days=None, display_currency_id=None, fallback_to_first_snapshot=False)
    Calculates the given fund's NAV per share variation ratio with regard to the previous
    day, month, year and also to the last online value. Only snapshots with the 'current' type are considered.

    If num_days is provided, also calculates the variation the given number of calendar days.

    If the date is not supplied, the latest snapshot for the fund is used.
    If a snapshot is given, the date parameter is also required.

    If a snapshot is given, whenever its values have been currency-converted beforehand, the used currency
    must be present in snapshot['currency_id'], or the results will be miscalculated.

    For funds which don't have snapshot reaching as back as one of the variations, by default None will be returned
    for the longer variations (e.g. navps_variation_prev_year i.e. 12M variation, for a 2-month-old fund).
    However, if fallback_to_first_snapshot is set to True, those variations will use the fund's first snapshot as a base
    (in that same example, the 12M variation will actually return the 2-month variation).

    'fund_id': int
    'date': date or None
    'snapshot': {'id': int, 'type': SNAPSHOT_TYPES (int), 'navps': Decimal, 'last_online_navps': Decimal or None,
                'navps_variation_previous_day': Decimal or None, 'currency_id': int or None}
    'num_days': int or None

    returns: {'date': date, navps_variation_previous_day': decimal or None, 'navps_variation_previous_month': decimal or None,
              'navps_variation_previous_year': decimal or None, 'navps_variation_last_online': decimal or None,
              'navps_variation_this_month': decimal or None, 'navps_variation_this_year': decimal or None,
              'navps_variation_num_days': decimal or None} or {}

    All returned variations are fractions (so 20.35% is represented as 0.2035).
    Returns the date of the lastest portfolio used to compute variations.
    Returns an empty dictionary if no suitable portfolio snapshot exists for the given date.
get_snapshots_by_fund_and_date(keys, values=None)
    Returns the snapshots for a group of (fund, date) pairs.
    If no snapshot was found for a given pair, that pair doesnt appear in the return dictionary

    keys: [(fund_id, date)]
    values: [str] or None

    returns: {(fund_id, date): portfolio.Snapshot.values() or 'values'}
release_portfolio_allocated_funds(fund_ids, date, release=None)
    If release is True (default), marks portfolio snapshots as released (approved).
    Fails if a snapshot had already been released.

    If release is False, reopens released portfolio snapshots.
    Fails if the snapshot had not been released.

    fund_ids: [int]
    date: date
    release: boolean or None  # default: True

    returns: default success dictionary
get_avg_nav(average_nav_months, fund_id=None, date=None, accept_older=None, only_current=None, only_official_date=None, snapshot_id=None, only_released=False)
    Retrieves the average NAV for the given fund

    If date is None, lastest snapshot is used as a reference.

    average_nav_months: int
    fund_id: int or None
    date: date or None
    accept_older: bool or None  # default: True
    only_current: bool or None
    only_official_date: bool or None
    snapshot_id: int or None
    use_managerial_nav: bool or None  # default: False

    returns: {fund_id (int): NAV (decimal)}
get_total_aum(date, currency_id)
    Returns the total aum for the specified date in the given currency.
    date: date
    currency_id: int
get_navps_for_liability_conversion(fund_ids, date, only_admin=False)
    Returns the navps for liability conversion of the given funds in a specified date.
    First look for the latest administrator snapshots on the specified date for each fund.
    If no administrator snapshot is found for that date, look for the latest current snapshot (created locally).
    If only_admin is set to True, doesn't look for current snapshots in case it didn't find an administrator snapshot.

    fund_ids: [int]
    date: date
    only_admin: bool (default: False)

    returns: {fund_id (int): Decimal} or {}
calculate_attribution(*args, **kwargs)
get_portfolio_navs_by_fund_and_date(fund_ids, start_date=None, end_date=None)
    Returns the portfolio nav on each date inside the provided period.
    'fund_id': int
    'start_date': date
    'end_date': date

    returns: {fund_id (int): {date (date): {'date': date, 'nav': decimal, 'managerial_nav': decimal}}
get_content_type_for_operation()
    Returns the content type ID for the Operation model.

    returns: {'id': int}
check_portfolios_released(fund_ids, date)
    For each input fund, tells whether the fund's snapshot for that day has been released (approved).

    'fund_ids': [int]
    'dates': [date]

    returns: {fund_id: boolean or None}

    If the snapshot doesn't exist yet for a given date, that day's value is None.
get_price_vs_exposure_evolution(fund_id=None, asset_id=None, issuer_id=None, start_date=None, end_date=None)
    Returns the price vs exposure in a period.

    fund_id: int
    start_date: date
    end_date: date
    asset_id: int
    issuer_id: int

    returns: {'items': evolution, 'asset_ids': [int]}
        evolution: {'fund_id': int, name': string (asset or issuer name), 'values': value, 'start_date': date, 'end_date': date}
            value: { 'date': date, 'exposure': Decimal, 'price': Decimal}
get_fund_variation(fund_id, dates)
    calculate navps of every tuple of dates in dates of the given fund

    'fund_id': int
    'dates': array of [initial_date, final_date]

    returns: {'date': date, navps_variation_previous_day': decimal or None, 'navps_variation_previous_month': decimal or None,
              'navps_variation_previous_year': decimal or None, 'navps_variation_last_online': decimal or None,
              'navps_variation_this_month': decimal or None, 'navps_variation_this_year': decimal or None} or {}

    All returned variations are fractions (so 20.35% is represented as 0.2035).
    Returns the date of the lastest portfolio used to compute variations.
    Returns None for periods which have no portfolio snapshot available (e.g. year variation for a 4-months-old fund).
    Returns an empty dictionary if no suitable portfolio snapshot exists for the given date.
get_currency_exposures(snapshot_ids)
    Returns the currency exposure information for the provided snapshots.

    snapshot_ids: [int]

    returns: {snapshot_id (int): currency_exposures} or {}
       currency_exposures: {currency_id (int): exposure}
          exposure: {'name': string, 'exposure': int, 'delta_adjusted_exposure': int}
get_portfolio_periods_in_range(fund_ids, start_date=None, end_date=None)
    Return information about fund periods between a range of dates. Only returns period registered on database.
get_master_fund(fund_ids, date, return_none=True)
    Returns the master fund for the given fund ids.

    fund_ids: [int]
    date: Datetime
    return_none: bool

    returns: {fund_id [Int] : master_fund_id [Int or None]}
get_fund_nav_by_group(date=None, fund_ids=None, group_type=None, accept_older=True, include_usd_nav=False)
    Returns nav info by fund group.
    'date': date or None
    'group_type': FUND_GROUP_TYPES or None # default FUND_GROUP_TYPES.for_portfolios_overview_report
    'accept_older': bool or None  # default: True
    'fund_ids': [int] or None
    'include_vol_data': bool # default: True
    'include_benchmark_data': bool # default: True
    'include_usd_nav': bool # default: False
    'include_12m_nav': bool # default: False
    'include_gross_navps': bool # default: False
    'include_net_captation_data': bool # default: False
    'include_6m_profitability': bool # default: False
    'include_12m_profitability': bool # default: False
    'include_18m_profitability': bool # default: False
    'include_24m_profitability': bool # default: False
    'include_36m_profitability': bool # default: False
    'include_60m_profitability': bool # default: False
    'include_fund_start_profitability': bool # default: False
    'include_funds_start_date': bool # default: False
    'include_cash_balance': bool # default: False
    'include_adm_fee': bool # default: False
    'include_pfee': bool # default: False

    returns: {'groups': [group],
        'total_aum': decimal,   # total NAV of funds contained in at least one group
        'total_usd_aum': decimal or None,
        'funds_with_no_group': str #list of fund_names of funds not included in any group.
                                Only applicable if a group_type is provided
        }
        group: {'group_name': str,
                'total_brl_nav': decimal,
                'total_usd_nav': decimal,
                'aum_percentage': decimal,
                'items': [item]}
        item: {'fund_id': int,
                'fund_name': str,
                'brl_nav': decimal,
                'usd_nav': decimal,
                'navps': decimal,
                'date': date
                }
get_portfolio_comparison(date, status=None, administrator_ids=None, custodian_ids=None, fund_group_ids=None, fund_ids=None)
    Returns all active funds' portfolio snapshots and comparisons basic information at the specified date.
    Accepts optional filters.

    If no date is informed, D-1 is used.

    'date': date or None
    'status': [COMPARISON_SUMMARIZED_STATUS (int)] or None
    'administrator_ids': [int] or None
    'custodian_ids': [int] or None
    'fund_group_ids': [int] or None
    'fund_ids': [int] or None

    returns: {'items': [portfolio], 'date': date}
        portfolio: {'snapshot_id': int, 'snapshot_status': SNAPSHOT_STATUS (int), 'snapshot_status_name': string,
                    'summarized_status': SUMMARIZED_SNAPSHOT_STATUS (int), 'summarized_status_name': string,
                    'summarized_status_class': string, 'date': date, 'generated_on': datetime,
                    'fund_id': int, 'fund_name': string, 'nav': decimal, 'shares': decimal or None, 'navps': decimal,
                    'gross_navps': decimal, 'last_online_navps': decimal, 'comparison': comparison or None,
                    'is_navps_approved': boolean or None, 'is_navps_frozen': boolean, 'is_allocated': boolean,
                    'places_nav': int, 'places_shares': int, 'places_navps': int}
            comparison:  {'comparison_id': int, 'status': COMPARISON_STATUS (int), 'incoming_file_id': int or None,
                          'incoming_file_log_url': string or None, 'reprocess_external_url: string or None,
                          'can_release_with_adjustment': bool or None} +
                         # All remaining fields are decimal or None.
                         {'nav_internal', 'nav_external', 'nav_diff_absolute', 'nav_diff_relative',
                          'shares_internal', 'shares_external', 'shares_diff_absolute', 'shares_diff_relative',
                          'profitability_internal', 'profitability_external',
                          'profitability_diff_absolute', 'profitability_diff_relative',
                          'pnl_internal', 'pnl_external', 'pnl_diff_absolute', 'pnl_diff_relative',
                          'navps_internal', 'navps_external', 'navps_diff_absolute', 'navps_diff_relative',
                          'navps_diff_absolute_financial_impact'}
is_portfolio_official_date(fund_ids, dates)
    For each fund/date pair, returns whether the fund has an official portfolio in such date.
    (pt-br: "tem cota no dia")

    fund_ids: [int]
    dates: [date]

    returns: {date: {fund_id (int): bool}}
get_cash_amount(date, fund_id, currency_id, cash_instrument_types, assets=None, fund_nav=None)
    Returns the total cash amount

    date: date
    fund_ids: int
    currency_id: in
    cash_instrument_types: [INSTRUMENT_TYPE_IDENTIFIERS] instument types to be considered as cash

    returns
        { fund_id: { 'cash_amount': Decimal, 'cash_exposure': Decimal }
accept_discrepancies(*args, **kwargs)
update_operations_sent_to_administrator(ids, sent_to_administrator)
    Updates sent_to_administrator attribute of existing operations.

    Returns: default sucess dictionary
get_operations(ids=None, fund_ids=None, dates=None, date_type=None, start_date=None, end_date=None, types=None, sent_to_administrator=None, is_confirmed=None, instrument_ids=None, broker_id=None, strategy_id=None, group_aggregation=None, origin_ids=None, origin_content_type_id=None, payment_settlement_date=None, asset_start_settlement_date=None, account_ids=None, payment_account_ids=None, include_inactive_funds=False, basket_ids=None, instrument_types=None, include_instrument_type=False, broker_ids=None)
    Retrieves operation information. Accepts optional filters.
    Depending on group_aggregation , operations can be grouped into ('date', 'asset_settlement_date, 'fund_id', 'instrument_id',
    'side'). For grouped results, the 'price' key will be the weighted average over all operation prices in the group
    and the 'quantity' will be the sum of quantities in the group. Specific operation fields, such as 'account' and
    'strategy', will be set to None in grouped results. Also in groups, the 'id' key for operation will be an unique
    id representing the group. In this case, it's possible to get the operation_ids of the group in the 'operation_ids'
    field.

    ids: [int] or None
    fund_ids: [int] or None
    dates: [date] or None
    date_type: TRANSACTION_FILTER_DATE_TYPES (int) or None  # default: conversion_date
    start_date: date or None
    end_date: date or None
    types: [OPERATION_TYPES (int)] or None
    sent_to_administrator: boolean or None
    is_confirmed: boolean or None
    instrument_ids: [int] or None
    broker_id: int or None
    broker_ids: [int] or None
    strategy_id: int or None
    group_aggregation: OPERATION_AGGREGATION_TYPE (int) or None
    origin_ids: [int] or None
    origin_content_type_id: int or None
    payment_settlement_date: date or None
    asset_start_settlement_date: date or None
    account_ids: [int] or None
    payment_account_ids: [int] or None
    include_inactive_funds: bool  # default: False
    basket_ids: [int] or None
    instrument_types: [INSTRUMENT_TYPES] or None
    include_instrument_type: bool

    returns: {id (str or int): operation_or_group}
        operation_or_group: {'id': int, 'fund_id': int, 'is_confirmed': bool, 'instrument_id': int, 'strategy_id': int,
                             'account_id': int, 'type': OPERATION_TYPES (int),
                             'is_confirmed': bool, 'sent_to_administrator': bool,
                             'date': date, 'asset_settlement_date': date, 'payment_settlement_date': date,
                             'quantity': Decimal, 'price': Decimal, 'financial_value': Decimal,
                             'origin_id': int or None, 'origin_content_type_id': int or None, 'broker_id': int,
                             'extra_values': dict, 'instrument_name':str, 'fund_name': str, 'strategy_name':str,
                             'account_name': str, 'broker_name': str or None, 'brokerage_fee': Decimal,
                             'emoluments_value': Decimal,
                             'payment_exchange_rate': Decimal or None, 'payment_currency_id': int,
                             'payment_account_id': int, 'side': OPERATION_SIDES,
                             'is_confirmed: bool, 'is_system_generated': bool, 'carrying_broker_id': int,
                             'carrying_brokerage_fee': decimal or None, 'carrying_broker_name': str or None,
                             # Fields present only when there is aggregation
                             'operation_ids': [int]}
generate_snapshots_multiple_dates(dates, fund_ids=None, fund_names_str=None, reopen=None, release=None, use_dummy_with=None)
    Calls generate_snapshots sequentialy, for given dates.
send_portfolio_overview_email(date, fund_ids, collumn_options=None, single_email_all_funds=False)
    Sends an email with the same content as the report "Tabela de Rentabilidade" (portfolios overview).
    If single_email_all_funds is True, sends all content in one single email. Otherwise send one email for each fund.
    date: date
    fund_ids: [int]
    collumn_options: {} # defined which collumns should be included in result

    NOTE: this API should preferably be called outside any database transactions (e.g. async(atomic=False))
    to avoid deadlocks.

    returns: default success dict
get_fund_transaction_suggestions(fund_id, date)
    Returns the suggested transactions for funds in which the given fund invests.
    Results are chained recursively for funds with their portfolios in the system.

    fund_id: int

    returns: {'transactions': [transaction]}
        transaction: {'temp_id': int, 'parent_temp_id': int, 'fund_id': int, 'parent_fund_id': int,
                      'instrument_id': int, 'parent_shareholder_id': int, 'fund_is_managed': bool,
                      'chain_factor_value': float, 'chain_factor_shares': float}
get_previous_unreleased_snapshots(fund_id=None, date=None, snapshot_id=None)
get_provision_category_for_mellon_codes(codes=None)
    Returns the provision categories keyed by Mellon codes.
    Returned values are None for specified codes with no associated category.
    If the codes list is omitted, all registered codes are returned.

    codes: [int]

    returns: {code (int): provision_category_id (int) or None}

    Note: provision category IDs are the values in PROVISION_CATEGORIES.
get_position_by_invested_fund(date, fund_ids)
    Returns the total invested amount in all fund instruments.

    fund_ids: [int] or None
    date: date

    returns: {'items': [item]}
        item: {'fund': str, 'asset_manager': str, 'number_of_fofs': int, 'nav': decimal, 'total_investment': decimal,
               'investment_percentage': decimal}
get_funds_containing_instruments(instrument_ids)
    Retrieves all funds that the instrument has positions diferent from Zero.

    instrument_id: int

    returns: {instrument_id: {fund_id (int): fund_name (string)}}
get_portfolio_navps_evolution(fund_ids, start_date, end_date, benchmarks=None, type_=None, time_frame=None, use_administrator_values=False, convert_to_fund_currency=False)
    Returns the navps of a portfolio in a period.
    Optionally, benchmarks can be passed to compare with the navps evolution.
    If convert_to_fund_currency is True, convert benchmark values to fund currency before calculating variations
    BUT IF FUNDS_IDS CONTAINS MORE THAN ONE FUND, AND THIS OPTION IS USED, THIS METHOD WILL USE THE FIRST FUND CURRENCY

    fund_ids: [int]
    start_date: date
    end_date: date
    benchmarks: [{'indice_id': int, 'multiplier': Decimal or None # default: 1,
                  'additional': Decimal or None # default: 0}] or None
    type: PROFITABILITY_REPORT_TYPES

    returns: {'items': [navps_evolution]}
        navps_evolution: {'fund_id': int or None, 'indice_id': int or None, 'name': string (name of fund or indice),
                          'values': [value]}
            value: {'date': date, 'value': Decimal}
get_operations_grouped_by_fund_group(date, types=None, group_type=4)
    Get operations of a single date and group them by fund groups of a certain type (ex: family).
    'date': date
    'types': [OPERATION_TYPES]
    'group_type': FUND_GROUP_TYPES

    returns: {id (str or int): operation_or_group}
        operation_or_group: {'id': int, 'fund_id': int, 'instrument_id': int, 'strategy_id': int, 'account_id': int,
                            'type': OPERATION_TYPES (int),
                            'date': date, 'asset_settlement_date': date, 'payment_settlement_date': date,
                            'quantity': Decimal, 'price': Decimal, 'sent_to_administrator': bool,
                            'origin_id': int or None, 'origin_content_type_id': int or None, 'broker_id': int,
                            'extra_values': dict, 'instrument_name':str, 'fund_name': str, 'strategy_name':str,
                            'account_name': str, 'broker_name': str or None, 'instrument_type': int,
                            # Fields present only when group_results is True.
                            'operation_ids': [int]}
get_operations_rebate_percent(operation_ids)
    Retrieves rebate percents defined per operations.

    operation_ids: [int]

    returns: {operation_id (int): operation_rebate_percent}
        operation_rebate_percent: {'rebate_percent': decimal or None, 'id': int}
get_exposure_by_strategy(fund_id, date=None)
    Returns total exposure for each strategy for the given fund and date
    fund_id: int
    date: date

    returns: {strategy_id (int): strategy}
        strategy: {'strategy_id': int, 'strategy_name': string}
                   'exposure': decimal}
            asset: {'instrument_id': int, 'instrument_name': string, 'instrument_type_name': string,
                    'instrument_type_identifier': INSTRUMENT_TYPE_IDENTIFIERS (string),
                    'quantity': decimal, 'financial_value': decimal, 'financial_value_delta': decimal,
                    'attribution_by_strategy': decimal,
                    'price': decimal, 'price_variation': decimal or None}
get_assets_by_strategy(fund_id, date, variation_date=None, strategy_ids=None, instrument_ids=None, include_lending_quantities=None, flat=None, retrieve_variations=True)
    Returns a portfolio snapshot's assets grouped by strategy. May be filtered by strategy.
    If a variation date is supplied, the variation (profitability) between 'variation_date' and 'date' is calculated.

    fund_id: int
    date: date
    variation_date: date or None
    strategy_ids: [int] or None
    instrument_ids: [int] or None
    include_lending_quantities: boolean or None  # default: False
    flat: boolean or None  # default: False

    returns: {strategy_id (int): strategy}
        strategy: {'strategy_id': int, 'strategy_name': string, 'children': {strategy_id (int): strategy} or None,
                   'assets': [asset]}
            asset: {'instrument_id': int, 'instrument_name': string, 'instrument_type_name': string,
                    'instrument_type_identifier': INSTRUMENT_TYPE_IDENTIFIERS (string),
                    'quantity': decimal, 'financial_value': decimal, 'financial_value_delta': decimal,
                    'attribution_by_strategy': decimal, 'original_currency_id': int,
                    'price': decimal, 'price_variation': decimal or None}

    When 'flat' is False (the default), sub-strategies will not be returned in the root dictionary, and 'children'
    will contain strategy dictionaries recursively. When 'flat' is True, all strategies will be returned in the
    root dictionary, and 'children' will be None.

    All financial values are in the fund's currency.
delete_operations(operation_ids, delete_related_transactions=False, delete_related_executions=False, dont_set_dirty_snapshot=False)
    Deletes from the database all operations with the provided ids.
    Provisions and postings created for these operations are also deleted.

    Origin model instances (such as Allocation, Transaction or LendingAgreement) are NOT deleted by default.
    Exceptions may be activated with the following parameters:
    - delete_related_transactions (for transactions from the Liabilities module)
    - delete_related_executions (for allocations from the Execution module. Note: this will raise an Exception
                                 if there are multiple allocations for the corresponding executions)

    operation_ids: [int]
    delete_related_transactions: bool  # default: False
    dont_set_dirty_snapshot: bool

    returns: {'success': boolean}
get_comparisons(ids=None, internal_id=None, external_id=None)
    Gets comparison objects
    ids: [int]
    internal_id: int
    external_id: int

    returns {comparison_id: compared_on, id, internal_snapshot_id, external_snapshot_id, external_snapshot_type,
    external_snapshot_admin_id, external_snapshot_custodian_id}
get_portfolio_assets_for_display(fund_ids=None, date=None, accept_older=None, full_look_through=None, look_through_instrument_ids=None, view_zero_items=None, snapshot_id=None, currency_id=None, fund_multipliers=None, include_underlying_prices=None, strategy_ids=None, strategy_behavior=1, asset_group_mode=1, sort_assets_by_strategy=False, group_by=1, operations=None, sort_bonds_alphabetically=False, consolidate_agreements=False, future_yield_as_price=False)
    Returns the fund's (or funds') asset portfolio at the specified date with detailed information.
    Look-through can be enabled in a per-instrument basis or in full depth.

    If multiple fund IDs are passed, their assets are *consolidated*. In this case, 'snapshot_id' is ignored.
    If 'currency_id' is not specified, one of the funds will be selected randomly and its currency will be used.
    Fund multipliers can be indicated with the 'fund_multipliers' parameter.

    Funds' assets can be optionally filtered by strategy. The way results are presented depend on strategy_behavior;
    the default value is 'consolidate'.

    Assets are consolidated by instrument, and grouped by instrument area. Exceptions are:
    - Available cash (currency instruments) is represented in the 'cash' group,
      consolidated by currency.
    - Provisioned cash (currency instruments) is represented in the 'provisions' group,
      consolidated by provision category.
    - Lending instruments are represented as lent quantities in the underlying instruments.

    If the date is not supplied, the latest snapshot for the fund is used.
    If no snapshot ID is given, only snapshots with the 'current' type are considered.

    Items with no total quantity are displayed if the attribution is non-zero (usually, this means the position
    was cleared in the snapshot's date) or the lending quantity is non-zero. If 'view_zero_items' is True,
    all recorded items are displayed (usually, this happens between the trade and settlement dates).

    A display currency can be forced with the 'currency_id' parameter. Conversion will be performed if necessary.

    'fund_ids': [int] or None
    'date': date or None
    'accept_older': bool or None  # default: False
    'full_look_through': bool or None,
    'look_through_instrument_ids': [int] or None
    'view_zero_items': bool or None  # default: False
    'snapshot_id': int or None
    'currency_id': int or None
    'fund_multipliers': {fund_id (int): mult_info} or None
        mult_info: {'multiplier': Decimal, 'by_strategy': {strategy_id (int): multiplier (Decimal)} or None/missing}
    'strategy_ids': [int] or None
    'strategy_behavior': ASSET_STRATEGY_AGGREGATION_BEHAVIORS (int) or None  # default: 'consolidate'
    'group_by': GROUP_BY_OPTIONS (int) or None # default: by issuer
    'operations': see get_portfolio_assets input

    returns: {'groups' {group_identifier (string): group}, 'snapshot_id': int or None, 'fund_ids': [int], 'date': date,
              'nav': decimal, 'look_through_fund_ids': [look_through_fund_id (int)], 'currency_id': int} or {}
        group_identifier: one of 'stocks', 'options', 'futures', 'funds', 'bonds', 'cash', 'provisions'
        group: {'identifier': string, 'groupments': [groupment], 'has_actions': bool, 'has_attribution': bool}
            groupment: {'name': string or None, 'total_exposure', 'assets': [asset]}
                asset: {'item_id': int, 'name': string, 'nav_value': decimal,
                    'actions': [identifier (string)], 'tooltips': {field_name (string): tooltip_group},
                    # The remaining fields are present only for instrument-based asset groups.
                    'instrument_id': int, 'instrument_type_identifier': string,
                    'can_look_through': boolean, 'is_looking_through': boolean,
                    'nav_unit_value': decimal, 'expiration_date': date or None, 'attribution': decimal,
                    'attribution_nominal': decimal, 'attribution_fx': decimal,
                    'quantity': decimal, 'available_quantity': decimal, 'exposure_value': decimal, 'exposure': decimal,
                    'lent_quantity': decimal, 'borrowed_quantity': decimal, 'provisioned_quantity': decimal,
                    'nav_percentage': decimal, 'collateral_quantity': decimal, 'look_through_quantity': decimal,
                    'decimal_places': int, 'original_currency_id': int, 'underlying_factor': decimal,
                    'cash_value_if_exercised': decimal, 'cash_value_if_exercised_error': string or None
                    'is_ETF_issuer': bool or None, 'is_currency_derivative': bool or None, 'is_equity_derivative': bool or None,
                    'exposure_if_exercised': decimal or None, 'issuer_id': int or None}
                tooltip_group: {identifer (string): string}

    Returns an empty dictionary if no suitable portfolio snapshot exists for the given date.
approve_navps(fund_id, date, is_approved, is_auto_approved=None)
    If is_approved is True, mark administrator portfolio as is_navps_approved.
    If administrator provides an integration mechanism, communicates whether
    the navps has been aprroved or reproved.

    If is_auto_approved is True, is_approved is also considered True

    fund_id: int
    date: date
    is_approved: boolean
    is_auto_approved: boolean

    returns: default success dictionary
get_operations_total_quantity_by_origin_id(origin_ids, origin_content_type_id, end_date=None)
    origin_ids: [int]
    origin_content_type_id: int
    end_date: date
get_first_snapshot_by_instrument(fund_ids=None, instrument_ids=None, exclude_instrument_ids=None, only_current=False, update_on_full_liquidation=False)
    Returns the fund's oldest portfolio snapshot that can contains a certain instrument.

    fund_id: int
    instrument_id: int

    returns: {instrument_id (int): info_by_fund}
        info_by_fund: {fund_id (int): {'snapshot_id': int, 'date': date}}

    Returns an empty dictionary if no matching open snapshot was found.
get_operations_by_origin(origins)
    Retrieves operations that match the given origins.

    origins: [origin]
        origin: {'origin_id': int, 'origin_content_type_id': int}

    returns: {operation_id (int): operation}
        provision: {'id': int, 'origin_id': int, 'origin_content_type_id': int}
send_message_on_portfolio_released_error(date, message, debug_text=None)
update_operations_strategy(ids_by_strategy, dont_set_dirty_snapshot=False)
    Updates the strategy of existing operations.

    ids_by_strategy: {new strategy_id (int): [operation_id (int)] }
    dont_set_dirty_snapshot: bool

    Returns: default sucess dictionary
mark_snapshot_email_as_sent(fund_ids, date)
    Sets current snapshotof given funds and date attribute "email_sent" as True"
get_external_snapshots_overview(fund_ids=None, date=None, accept_older=None)
    Returns external fund's portfolio overview at the specified date.

    If the date is not supplied, the latest snapshot for the fund is used.
    If accept_older is True and no snapshot exists for the given date, the closest snapshot
    going back in time will be selected.

    'fund_ids': [int] or None
    'date': date or None
    'accept_older': bool or None  # default: False

    returns: {'fund_id' (int): snapshot}
            snapshot: {'id': int, 'date': date, 'fund_id': int, 'generated_on': datetime,
                        'nav': decimal, 'shares': decimal, 'gross_navps': decimal, 'navps': decimal} or {}

    Returns an empty dictionary if no suitable portfolio snapshot exists.
get_current_snapshot(fund_id, date=None, accept_older=None)
    Returns the fund's current (internal) snapshot at the given date.

    If the date is not supplied, the latest snapshot for the fund is used. This is usually today's snapshot.
    If accept_older is True and no snapshot exists for the given date, the closest snapshot
    going back in time will be selected. (if the date is not specified, this parameter is ignored)

    fund_id: int
    date: date or None
    accept_older: bool or None  # default: False

    returns: {'snapshot_id': int, 'date': date, 'nav': Decimal, 'status': SNAPSHOT_STATUS,
              'navps_ex_amortizations': decimal, 'navps': Decimal, 'shares': Decimal } or {}

    Returns an empty dictionary if no matching snapshot was found.
get_performance_statistics(fund_ids, reference_date, periods, lanes, start_date, convert_to_fund_currency=True)
    For each benchmark associated to each fund, returns the number of days
    from start_date to reference_date
    that the navps variation on each given period was inside each lane.
    If convert_to_fund_currency is True, convert benchmark values to fund currency before computing variations
    'fund_ids': [int]
    'periods': [int] (in days)
    'lanes': [int]
    'start_date': datetime

    Example:
        periods = [252, 504, 756] # 12, 24 and 36 months
        lanes = [1, 1.2, 1.4]

    Then the api will return the number of days the navps variation was inside each of this lanes:

    Below 100% of benchmark
    Between 100% and 120% of benchmark
    Between 120% and 140% of benchmark
    Above 140% of benchmark

    returns: {fund_id (int): statistics_by_benchmark}
            statistics_by_benchmark: {benchmark_id (int): statistics_by_period}
            statistics_by_period: {num_months(int): statistics_by_lane
            statistics_by_lane: (num_ocorrencies (int))}
compare_snapshots_batch(snapshot_pairs_dict)
    Compares multiple pairs of internal-external snapshots.
    Note: this method currently is not any more efficient than the individual compare_snapshots API.

    snapshot_pairs_dict: {internal snapshot ID (int): external snapshot ID (int)}

    returns: {'comparison_ids': {internal snapshot ID (int): comparison ID (int)}}
update_comparisons(internal_snapshot_id, external_snapshot_id=None)
    Updates comparisons related to the internal_snapshot_id.
    If external_snapshot_id is passed it will be considered the last external snapshot of the pair
     (SNAPSHOT_TYPE, SNAPSHOT_TEMPLATE, custodian_id) or (SNAPSHOT_TYPE, SNAPSHOT_TEMPLATE, administrator_id)
    returns compare_snapshots result by external_snapshot_id
recalculate_snapshot_totals(date, no_currencies_in_assets_bug=None)
    Re-calculates the given date's portfolio snapshots' totals without rebuilding the asset tables.
    If 'no_currencies_in_assets_bug' is True, it is assumed that currency instruments are not
    present in the assets table, and adds up values from the provisions and balances tables.

    date: date
    no_currencies_in_assets_bug: boolean  # default: False

    returns: {'count': int}
import_portfolio_transfer_xls(filename, contents)
    Imports and processes a file containing portfolio transfers.

    files: [file]
        file: {'filename': string, 'contents': string}

    returns: data = {
        'success'
        'messages'
        'file_identifier'
        'log'
        'item_count'
    }
get_snapshots_from_comparison(comparison_id)
    Get snapshots of portfolios involved in comparison

    'comparison_id': Int

    returns: {'internal_snapshot':Object,'external_snapshot':Object}
get_portfolio_overview(fund_id=None, date=None, accept_older=None, only_current=None, only_official_date=None, snapshot_id=None, currency_id=None, average_nav_months=None, only_released=False)
    Returns the fund's portfolio overview at the specified date.
    If snapshot_id is supplied, all other arguments are ignored.

    If the date is not supplied, the latest snapshot for the fund is used.
    If accept_older is True and no snapshot exists for the given date, the closest snapshot
    going back in time will be selected.
    If only_current is True (the default), only current snapshots are considered.
    If only_official_date is True, only official-date snapshots are considered.
    If no snapshot ID is given, preference is given to the snapshot with 'current' type.
    If a currency ID is given, the NAV/NAVPS values will be converted to it if the fund's currency is different.

    'fund_id': int or None
    'date': date or None
    'accept_older': bool or None  # default: False
    'only_current': bool or None  # default: True
    'only_official_date': bool or None  # default: False
    'snapshot_id': int or None
    'currency_id': int or None
    'only_released': bool or None  # default: False

    returns: {'snapshot_id': int, 'type': SNAPSHOT_TYPES (int), 'status': SNAPSHOT_STATUS (int), 'date': date,
              'is_official_date': bool, 'fund_has_daily_portfolios': bool, 'generated_on': datetime, 'nav': decimal,
              'shares': decimal, 'gross_navps': decimal, 'navps': decimal, 'last_online_navps': decimal,
              'comparison_id': int or None, 'all_snapshots': [alt_snapshot], 'navps_ex_amortizations': decimal,
              'administrator_snapshot_id': int or None, 'is_navps_approved': boolean or None,
              'navps_variation_previous_day': decimal or None, 'look_through_investment_tree': json or None,
              'managerial_nav': decimal, 'is_frozen_navps': bool, 'is_frozen_nav': bool, 'is_frozen_shares': bool,
              'administrator_navps': decimal or None, 'administrator_nav': decimal or None,
              'administrator_shares: decimal or None} or {}
        alt_snapshot: {'snapshot_id': int, 'type': SNAPSHOT_TYPES (int), 'generated_on': datetime, 'selected': bool}

    Returns an empty dictionary if no suitable portfolio snapshot exists.
get_equities_exposure(assets_for_display, ignone_assets_without_issuer=True, ignore_ETF_issuers=True, ignore_strategy_ids=None)
    Computes the exposure of equities instruments (stocks, stock options and stock-index futures)
    grouped by underlying_instrument

    assets_for_display: see get_portfolio_assets_for_display() return
    ignone_assets_without_issuer: bool
    ignore_ETF_issuers: bool
    ignore_strategy_ids: [int]

    returns: {'exposure_by_underlying': exposure_by_underlying, 'issuer_by_underlying': issuer_by_underlying,
              'included_instrument_ids': [int]}
        exposure_by_underlying = {underlying_instrument_id (int):
                                    'exposure_value': decimal, 'if_exercised': decimal}
        issuer_by_underlying = {underlying_instrument_id (int): issuer_id (int)}
Module stocks (Aes)
set_stock_market_cap(values=[])
    Updates stocks market cap, issued shares and outstanding shares.

    values: [{stock_id (int): {field_name (str): value (decimal)}, date: Date}]
    returns default success dictionary
get_stock_type(ids=None)
    Returns the stock type for matching elements. Optional filters are available.

    'ids': [int] or None

    returns: {id (int): STOCK_TYPES (int)}
get_unit_composition(instrument_ids=None)
    Gets the composition for unit instruments.

    instrument_ids: [int]

    returns: {unit_instrument_id (int): [{'instrument_id': int, 'quantity': Decimal}]}
get_market_cap_by_date(instrument_ids=None, start_date=None, end_date=None)
    Returns the market cap, issued and outstanding shares values for the given stock instruments, by date.

    instrument_ids: [int] or None,
    start_date: date or None
    end_date: date or None

    returns { (instrument_id, date): mkt_cap_data}
        mkt_cap_data: {'current_issuer_market_cap': decimal or None, 'float_shares': decimal or None,
                        'shares_outstanding': decimal or None, 'issuer_id': int or None, 'currency_id': int}
get_current_issuer_market_cap(asset_ids=None, date=None, accept_older=True, issuer_ids=None)
    Returns the current_issuer_market_cap value for the given stock instruments.

    asset_ids: [int] or None,
    date: date or None
    accept_older: bool # default True
    issuer_ids: [int] or None

    returns { asset_id: {'current_issuer_market_cap': decimal or None, 'float_shares': decimal or None,
                        'shares_outstanding': decimal or None, 'issuer_id': int or None, 'currency_id': int}
get_market_cap(instrument_ids, date, accept_older=False)
    Returns the market cap, issued and outstanding shares values for the given stock instruments, by date.

    instrument_ids: [int] or None,
    start_date: date or None
    end_date: date or None
    accept_older: bool

    returns { (instrument_id, date): mkt_cap_data}
        mkt_cap_data: {'current_issuer_market_cap': decimal or None, 'float_shares': decimal or None,
                        'shares_outstanding': decimal or None, 'issuer_id': int or None, 'currency_id': int}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    If keep_old is set to True, MarketCaps with the same date will be erased and if set to False or None, will override previous ones

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_stocks_info(ids=None, values=None, is_monitoring_enabled=None, mktcap_monitoring_enabled=None, stock_types=None, issuer_ids=None, is_active=None)
    Obtains basic stock information filtered by ID.

    ids: [int]

    returns: {stock_id (int): stock}
        stock: {'id': int, 'stock_type': STOCK_TYPES (int), 'mktcap_monitoring_enabled': boolean
        'float_shares': Decimal, 'shares_outstanding': Decimal, 'current_issuer_market_cap': Decimal}
convert_stocks(stocks)
    Convert subscription receipts stocks into ON/PN stocks.
add_stock_instruments(stock_instruments)
    Inserts new stock instruments.

    'stock_instruments': [stock_instrument]
        stock_instrument: {'name': str, 'symbol': str, 'market_id': int, 'isin_code': str, 'issuer_id': int
                        'stock_type': STOCK_TYPES, 'price_divisor': int or None, 'is_monitoring_enabled': boolean or None,
                        'bloomberg_pricing_source': str or None, 'bloomberg_ticker': str or None, 'settlement_days': int or None}
    returns: default success dictionary
Module strategy (Estratgia)
get_strategies(flat=None, only_leaves=None, names=None, use_cache=True)
    Returns all registered strategies.

    flat: bool or None  # default: False
    only_leaves: bool or None  # default: False
    name: [string] or None
    use_cache: bool or None (default True)

    returns: {strategy_id (int): strategy}
        strategy: {'id': int, 'name': string, 'parent_id': int or None, 'children': [int] or [strategy],
                   'is_liquid': bool or missing, 'use_for_allocation': bool or missing}

    When 'flat' is False (the default), sub-strategies will not be returned in the root dictionary, and 'children'
    will contain strategy dictionaries recursively. When 'flat' is True, all strategies will be returned in the
    root dictionary, and 'children' will contain only immediate children's IDs.

    If 'only_leaves' is True or 'name' is supplied, flat mode is forced.
get_default_strategy_for_execution(instrument_ids=None, fund_ids=None, only_explicit=False)
    Returns the default strategy by instrument and fund, according to the following priority:
        insturment default > fund default > global default
    If 'only_explicit' is True, only returns strategy if explicit set on instrument or fund
    instrument_ids: [int] or None
    fund_ids: [int] or None
    only_explicit: bool # default False

    returns: {(instrument_id, fund_id): strategy_id}
get_default_strategy()
    Returns the default strategies.

    returns: {'strategy_id': int, 'strategy_name': string,
              'lending_strategy_id': int, 'lending_strategy_name': string,
              'cash_strategy_id': int or None, 'cash_strategy_name': string or None,
              'overnight_strategies': [overnight_strategy] or None}
                  overnight_strategy: {'id': int, 'name': str}

    If STRATEGY_USE_CASH_STRATEGY is disabled in the settings, cash_* results are None.
get_strategies_as_choices(only_leaves=None)
    Returns all strategies in the format for form fields' 'choices' parameter, using optgroups for parent strategies.

    only_leaves: boolean or None  # default: True

    returns: [parent or leaf]
        parent: (name (string), [leaf])
        leaf: (strategy_id (int), name (string))
Module swaps (Swaps)
get_underlying_instrument(ids=None)
    Returns the underlying instrument for the provided ids.

    ids: [int]

    returns: {instrument_id (int): underlying_instrument_id (int)}
get_content_type_for_swap_agreement()
    Returns the content type ID for the SwapAgrement model.

    returns: {'id': int}
update_swap_admin_codes(agreements)
    agreements: [agreement]
        agreement: {id (int): admin_code (str)}
get_swaps_info(ids=None, maturity_date_from=None, maturity_date_to=None, underlying_instrument_types=None, underlying_instrument_ids=None)
    Obtains basic information for swap instruments.
    Accepts optional filters.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    maturity_date_from: date or None
    maturity_date_to: date or None
    underlying_instrument_types: [int] or None
    underlying_instrument_ids: [int] or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'maturity_date': date, 'underlying_instrument_id': int, 'swap_lot': float}
read_swap_settlements_from_xls(files)
    Reads a swap settlement files
before_snapshot_generation(date, fund_ids, **kwargs)
    Creates and updates provisions for swap agreements.
set_last_confirmed_date(agreement_ids, date)
    Sets the last date when the provisions where confirmed.

    returns default success dictionary
undo_settlements(settlements)
    Undoes the effect of agreement settlement.

    settlements: [settlement]
        settlement: {'agreement_id': int, 'date': date}
add_swap_agreement(swap_agreements)
    Adds swap agreements.

    swap_agreements: [swap_agreement]
        swap_agreement: {'agreement_id': int or None, 'fixed_swap_instrument_id': int or None, 'strategy_id': int or None,
                         'fixed_instrument_id': int or None, 'floating_instrument_id': int or None,
                         'floating_hurdle_over': decimal, 'floating_additional_hurdle': decimal, 'fixed_hurdle_over': decimal,
                         'fixed_additional_hurdle': decimal, 'cetip_code': int (string?), 'broker_id': int, 'lot': decimal,
                         'fund_id': int, 'account_id': int, 'start_date': date, 'end_date': date, 'quantity': decimal,
                         'unit_value': decimal, 'currency_rate': decimal, 'market_id': int, 'exchange_coupon': string,
                         'admin_code': string,}

    if agreement id is set, information will be updated
settle_swap_agreements(settlements)
    Settles swap agreements, settling the provisions created.

    settlement: {agreement_id (int): agr_settlement}
        agr_settlement: {'date': date, 'quantity': decimal or None, 'notional': decimal or None, 'rate': decimal,
                         'unit_value': decimal, 'is_confirmed': True}
calculate_exposure_prices(prices_dict, date)
    Gets the current price of the instruments in the input list used to calculate exposure.
    The returned value is always 'per unit', regardless of the existence of a multiplier.

    prices_dict: dictionary containing prices data

    returns: {instrument_id (int): price (Decimal) or None}
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
read_swap_agreements_from_xls(files)
    Reads a XLS file with swap agreements.
get_swap_agreements(ids=None, fund_ids=None, broker_id=None, date_type=None, start_date=None, end_date=None, cetip_code=None, show_settled_agreements=False, strategy_ids=None, admin_code=None, account_ids=None)
    Retrieves swap agreements information.
override_provision_values(agreements)
    Overrides the provisions values of a given provisions, in the given dates.

    agreements: {agreement_id: provisions_and_dates}
        provisions_and_dates: {date: provisions}
        provisions: {PROVISION_CATEGORIES.swap_retribution(int): decimal or None, PROVISION_CATEGORIES.swap_cost(int): decimal or None}
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
init_day(date)
    Settles swap agreements with due date equals date minus 1 day.
delete_agreements(agreement_ids)
    Deletes swaps agreements in batch.

    agreement_ids: [int]

    returns: {}
Module overnight (Compromissadas)
transfer_instrument_history(id_being_transfered, id_transfered_to, keep_old=None)
    Changes every ForeignKey referencing 'id_being_transfered' to reference 'id_transfered_to' instead.
    'keep_old' is not used but must be kept for compatibility reasons.

    ids_transfered: [int]
    id_transfered_to: int
    keep_old: bool or None

    returns: {'success': bool, 'messages': [str]}
get_underlying_instrument(ids=None)
    Returns the underlying instrument for the provided ids.

    ids: [int]

    returns: {instrument_id (int): underlying_instrument_id (int)}
get_instrument_currencies_for_exposure(ids=None)
    Retrieves the instruments' currency for currency exposure purposes.

    ids: [int] or None

    returns: {instrument_id (int): currency_id (int) or None}
get_overnight_info(ids=None, underlying_instrument_types=None)
    Obtains basic information for overnight instruments.
    Accepts optional filters.
    Returns only active instruments, except if ids are provided.

    ids: [int] or None
    underlying_instrument_types = [int] or None

    returns: {instrument_id (int): info}
        info: {'id': int, 'underlying_instrument_id': int, 'overnight_price': decimal, 'return_date': date}
init_day(date)
    Performs all tasks required by the module when the system date changes to the given date, such
    as creating a new portfolio snapshot, processing scheduled tasks, etc.

    'date': date

    returns: {'success': boolean, 'log': string or None}
Module trading (Trading)
order_manage_calculate_from_delta_quantity(delta_quantity, date, instrument_id, fund_id, price, order_ids=None, side=None, display_currency_id=None, fund_currency_id=None)
    Calculate final_exposure, delta_quantity from a fund.
    'delta_quantity': int
    'date': datetime
    'instrument_id': int
    'fund_id': int
    'price': int
    'side': int
    'order_ids': [int]
    'display_currency_id': int or None
    'fund_currency_id': int or None

    returns: {
        'delta_quantity': int,
        'delta_exposure': int,
        'delta_financial': int,
        'final_quantity': int,
        'final_exposure': int,
        'final_financial': int,
        }
order_manage_calculate_from_final_exposure(final_exposure, instrument_id, fund_id, date, price, side, order_ids=None, display_currency_id=None)
get_allocated_order_quantities_suggestion(rule_id, instrument_id, date, price, side=None, total_quantity=None, fund_ids=None, basket_id=None, order_ids=None)
order_manage_calculate_funds_values(allocation_rule_id, fund_id, instrument_id, date, price, side=None, delta_quantity=None, final_exposure=None)
    Calculate delta_quantity of all funds in the allocation rule, given the allocation_rule_id
    'allocation_rule_id' : int
    'instrument_id': int
    'fund_id': int
    'date': string
    'price': int
    'side': int or None
    'delta_quantity': int or None
    'final_exposure': int or None

    returns: { 'success': bool, 'allocation_by_fund': {allocation_fund} }
        if allocation method == equalize exposure:
        'allocation_fund: {
            fund_id: {'final_exposure': Decimal}
        }
        'allocation_fund: {
            fund_id: {'delta_quantity': Decimal}
        }
suggest_allocation(execution_group_info, user_id, fund_ids=None, allocation_method=None, quick_allocate=None, strategy_id=None, skip_compliance_check=None, compliance_errors=None, check_round_lot=None, spare_provisions=None, basket_id=None, instruments_affected_by_compliance=None)